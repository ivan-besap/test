!function(ce, Z) {
    "object" == typeof exports && typeof module < "u" ? Z(exports) : "function" == typeof define && define.amd ? define(["exports"], Z) : Z((ce = typeof globalThis < "u" ? globalThis : ce || self).Popper = {})
}(this, function(ce) {
    "use strict";
    function Z(E) {
        if (null == E)
            return window;
        if ("[object Window]" !== E.toString()) {
            var T = E.ownerDocument;
            return T && T.defaultView || window
        }
        return E
    }
    function de(E) {
        return E instanceof Z(E).Element || E instanceof Element
    }
    function W(E) {
        return E instanceof Z(E).HTMLElement || E instanceof HTMLElement
    }
    function ot(E) {
        return typeof ShadowRoot < "u" && (E instanceof Z(E).ShadowRoot || E instanceof ShadowRoot)
    }
    var V = Math.max
      , Ke = Math.min
      , Fe = Math.round;
    function Ie() {
        var E = navigator.userAgentData;
        return null != E && E.brands && Array.isArray(E.brands) ? E.brands.map(function(T) {
            return T.brand + "/" + T.version
        }).join(" ") : navigator.userAgent
    }
    function We() {
        return !/^((?!chrome|android).)*safari/i.test(Ie())
    }
    function Ne(E, T, z) {
        void 0 === T && (T = !1),
        void 0 === z && (z = !1);
        var O = E.getBoundingClientRect()
          , q = 1
          , N = 1;
        T && W(E) && (q = E.offsetWidth > 0 && Fe(O.width) / E.offsetWidth || 1,
        N = E.offsetHeight > 0 && Fe(O.height) / E.offsetHeight || 1);
        var j = (de(E) ? Z(E) : window).visualViewport
          , B = !We() && z
          , U = (O.left + (B && j ? j.offsetLeft : 0)) / q
          , K = (O.top + (B && j ? j.offsetTop : 0)) / N
          , J = O.width / q
          , Q = O.height / N;
        return {
            width: J,
            height: Q,
            top: K,
            right: U + J,
            bottom: K + Q,
            left: U,
            x: U,
            y: K
        }
    }
    function Te(E) {
        var T = Z(E);
        return {
            scrollLeft: T.pageXOffset,
            scrollTop: T.pageYOffset
        }
    }
    function pe(E) {
        return E ? (E.nodeName || "").toLowerCase() : null
    }
    function Me(E) {
        return ((de(E) ? E.ownerDocument : E.document) || window.document).documentElement
    }
    function M(E) {
        return Ne(Me(E)).left + Te(E).scrollLeft
    }
    function Ce(E) {
        return Z(E).getComputedStyle(E)
    }
    function me(E) {
        var T = Ce(E);
        return /auto|scroll|overlay|hidden/.test(T.overflow + T.overflowY + T.overflowX)
    }
    function D(E, T, z) {
        void 0 === z && (z = !1);
        var O, q, Q, le, se, re, N = W(T), j = W(T) && (le = (Q = T).getBoundingClientRect(),
        se = Fe(le.width) / Q.offsetWidth || 1,
        re = Fe(le.height) / Q.offsetHeight || 1,
        1 !== se || 1 !== re), B = Me(T), U = Ne(E, j, z), K = {
            scrollLeft: 0,
            scrollTop: 0
        }, J = {
            x: 0,
            y: 0
        };
        return (N || !N && !z) && (("body" !== pe(T) || me(B)) && (K = (O = T) !== Z(O) && W(O) ? {
            scrollLeft: (q = O).scrollLeft,
            scrollTop: q.scrollTop
        } : Te(O)),
        W(T) ? ((J = Ne(T, !0)).x += T.clientLeft,
        J.y += T.clientTop) : B && (J.x = M(B))),
        {
            x: U.left + K.scrollLeft - J.x,
            y: U.top + K.scrollTop - J.y,
            width: U.width,
            height: U.height
        }
    }
    function Ee(E) {
        var T = Ne(E)
          , z = E.offsetWidth
          , O = E.offsetHeight;
        return Math.abs(T.width - z) <= 1 && (z = T.width),
        Math.abs(T.height - O) <= 1 && (O = T.height),
        {
            x: E.offsetLeft,
            y: E.offsetTop,
            width: z,
            height: O
        }
    }
    function ke(E) {
        return "html" === pe(E) ? E : E.assignedSlot || E.parentNode || (ot(E) ? E.host : null) || Me(E)
    }
    function xe(E) {
        return ["html", "body", "#document"].indexOf(pe(E)) >= 0 ? E.ownerDocument.body : W(E) && me(E) ? E : xe(ke(E))
    }
    function tt(E, T) {
        var z;
        void 0 === T && (T = []);
        var O = xe(E)
          , q = O === (null == (z = E.ownerDocument) ? void 0 : z.body)
          , N = Z(O)
          , j = q ? [N].concat(N.visualViewport || [], me(O) ? O : []) : O
          , B = T.concat(j);
        return q ? B : B.concat(tt(ke(j)))
    }
    function ei(E) {
        return ["table", "td", "th"].indexOf(pe(E)) >= 0
    }
    function Et(E) {
        return W(E) && "fixed" !== Ce(E).position ? E.offsetParent : null
    }
    function He(E) {
        for (var T = Z(E), z = Et(E); z && ei(z) && "static" === Ce(z).position; )
            z = Et(z);
        return z && ("html" === pe(z) || "body" === pe(z) && "static" === Ce(z).position) ? T : z || function(O) {
            var q = /firefox/i.test(Ie());
            if (/Trident/i.test(Ie()) && W(O) && "fixed" === Ce(O).position)
                return null;
            var N = ke(O);
            for (ot(N) && (N = N.host); W(N) && ["html", "body"].indexOf(pe(N)) < 0; ) {
                var j = Ce(N);
                if ("none" !== j.transform || "none" !== j.perspective || "paint" === j.contain || -1 !== ["transform", "perspective"].indexOf(j.willChange) || q && "filter" === j.willChange || q && j.filter && "none" !== j.filter)
                    return N;
                N = N.parentNode
            }
            return null
        }(E) || T
    }
    var Se = "top"
      , ue = "bottom"
      , Ae = "right"
      , _e = "left"
      , Ge = "auto"
      , lt = [Se, ue, Ae, _e]
      , ve = "start"
      , ht = "end"
      , Je = "viewport"
      , ge = "popper"
      , kt = lt.reduce(function(E, T) {
        return E.concat([T + "-" + ve, T + "-" + ht])
    }, [])
      , it = [].concat(lt, [Ge]).reduce(function(E, T) {
        return E.concat([T, T + "-" + ve, T + "-" + ht])
    }, [])
      , F = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"];
    function At(E) {
        var T = new Map
          , z = new Set
          , O = [];
        function q(N) {
            z.add(N.name),
            [].concat(N.requires || [], N.requiresIfExists || []).forEach(function(j) {
                if (!z.has(j)) {
                    var B = T.get(j);
                    B && q(B)
                }
            }),
            O.push(N)
        }
        return E.forEach(function(N) {
            T.set(N.name, N)
        }),
        E.forEach(function(N) {
            z.has(N.name) || q(N)
        }),
        O
    }
    function It(E, T) {
        var z = T.getRootNode && T.getRootNode();
        if (E.contains(T))
            return !0;
        if (z && ot(z)) {
            var O = T;
            do {
                if (O && E.isSameNode(O))
                    return !0;
                O = O.parentNode || O.host
            } while (O)
        }
        return !1
    }
    function ct(E) {
        return Object.assign({}, E, {
            left: E.x,
            top: E.y,
            right: E.x + E.width,
            bottom: E.y + E.height
        })
    }
    function ze(E, T, z) {
        return T === Je ? ct(function(O, q) {
            var N = Z(O)
              , j = Me(O)
              , B = N.visualViewport
              , U = j.clientWidth
              , K = j.clientHeight
              , J = 0
              , Q = 0;
            if (B) {
                U = B.width,
                K = B.height;
                var le = We();
                (le || !le && "fixed" === q) && (J = B.offsetLeft,
                Q = B.offsetTop)
            }
            return {
                width: U,
                height: K,
                x: J + M(O),
                y: Q
            }
        }(E, z)) : de(T) ? ((N = Ne(O = T, !1, "fixed" === z)).top = N.top + O.clientTop,
        N.left = N.left + O.clientLeft,
        N.bottom = N.top + O.clientHeight,
        N.right = N.left + O.clientWidth,
        N.width = O.clientWidth,
        N.height = O.clientHeight,
        N.x = N.left,
        N.y = N.top,
        N) : ct(function(O) {
            var q, N = Me(O), j = Te(O), B = null == (q = O.ownerDocument) ? void 0 : q.body, U = V(N.scrollWidth, N.clientWidth, B ? B.scrollWidth : 0, B ? B.clientWidth : 0), K = V(N.scrollHeight, N.clientHeight, B ? B.scrollHeight : 0, B ? B.clientHeight : 0), J = -j.scrollLeft + M(O), Q = -j.scrollTop;
            return "rtl" === Ce(B || N).direction && (J += V(N.clientWidth, B ? B.clientWidth : 0) - U),
            {
                width: U,
                height: K,
                x: J,
                y: Q
            }
        }(Me(E)));
        var O, N
    }
    function fe(E) {
        return E.split("-")[0]
    }
    function Xe(E) {
        return E.split("-")[1]
    }
    function te(E) {
        return ["top", "bottom"].indexOf(E) >= 0 ? "x" : "y"
    }
    function Be(E) {
        var T, z = E.reference, O = E.element, q = E.placement, N = q ? fe(q) : null, j = q ? Xe(q) : null, B = z.x + z.width / 2 - O.width / 2, U = z.y + z.height / 2 - O.height / 2;
        switch (N) {
        case Se:
            T = {
                x: B,
                y: z.y - O.height
            };
            break;
        case ue:
            T = {
                x: B,
                y: z.y + z.height
            };
            break;
        case Ae:
            T = {
                x: z.x + z.width,
                y: U
            };
            break;
        case _e:
            T = {
                x: z.x - O.width,
                y: U
            };
            break;
        default:
            T = {
                x: z.x,
                y: z.y
            }
        }
        var K = N ? te(N) : null;
        if (null != K) {
            var J = "y" === K ? "height" : "width";
            switch (j) {
            case ve:
                T[K] = T[K] - (z[J] / 2 - O[J] / 2);
                break;
            case ht:
                T[K] = T[K] + (z[J] / 2 - O[J] / 2)
            }
        }
        return T
    }
    function pt(E) {
        return Object.assign({}, {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }, E)
    }
    function St(E, T) {
        return T.reduce(function(z, O) {
            return z[O] = E,
            z
        }, {})
    }
    function dt(E, T) {
        void 0 === T && (T = {});
        var O = T.placement
          , q = void 0 === O ? E.placement : O
          , N = T.strategy
          , j = void 0 === N ? E.strategy : N
          , B = T.boundary
          , U = void 0 === B ? "clippingParents" : B
          , K = T.rootBoundary
          , J = void 0 === K ? Je : K
          , Q = T.elementContext
          , le = void 0 === Q ? ge : Q
          , se = T.altBoundary
          , re = void 0 !== se && se
          , ae = T.padding
          , y = void 0 === ae ? 0 : ae
          , e = pt("number" != typeof y ? y : St(y, lt))
          , i = E.rects.popper
          , s = E.elements[re ? le === ge ? "reference" : ge : le]
          , a = function Re(E, T, z, O) {
            var U, K, J, q = "clippingParents" === T ? (K = tt(ke(U = E)),
            de(J = ["absolute", "fixed"].indexOf(Ce(U).position) >= 0 && W(U) ? He(U) : U) ? K.filter(function(Q) {
                return de(Q) && It(Q, J) && "body" !== pe(Q)
            }) : []) : [].concat(T), N = [].concat(q, [z]), B = N.reduce(function(U, K) {
                var J = ze(E, K, O);
                return U.top = V(J.top, U.top),
                U.right = Ke(J.right, U.right),
                U.bottom = Ke(J.bottom, U.bottom),
                U.left = V(J.left, U.left),
                U
            }, ze(E, N[0], O));
            return B.width = B.right - B.left,
            B.height = B.bottom - B.top,
            B.x = B.left,
            B.y = B.top,
            B
        }(de(s) ? s : s.contextElement || Me(E.elements.popper), U, J, j)
          , r = Ne(E.elements.reference)
          , n = Be({
            reference: r,
            element: i,
            strategy: "absolute",
            placement: q
        })
          , o = ct(Object.assign({}, i, n))
          , l = le === ge ? o : r
          , c = {
            top: a.top - l.top + e.top,
            bottom: l.bottom - a.bottom + e.bottom,
            left: a.left - l.left + e.left,
            right: l.right - a.right + e.right
        }
          , d = E.modifiersData.offset;
        if (le === ge && d) {
            var g = d[q];
            Object.keys(c).forEach(function(p) {
                var m = [Ae, ue].indexOf(p) >= 0 ? 1 : -1
                  , x = [Se, ue].indexOf(p) >= 0 ? "y" : "x";
                c[p] += g[x] * m
            })
        }
        return c
    }
    var ut = {
        placement: "bottom",
        modifiers: [],
        strategy: "absolute"
    };
    function Mt() {
        for (var E = arguments.length, T = new Array(E), z = 0; z < E; z++)
            T[z] = arguments[z];
        return !T.some(function(O) {
            return !(O && "function" == typeof O.getBoundingClientRect)
        })
    }
    function je(E) {
        void 0 === E && (E = {});
        var z = E.defaultModifiers
          , O = void 0 === z ? [] : z
          , q = E.defaultOptions
          , N = void 0 === q ? ut : q;
        return function(j, B, U) {
            void 0 === U && (U = N);
            var K, J, Q = {
                placement: "bottom",
                orderedModifiers: [],
                options: Object.assign({}, ut, N),
                modifiersData: {},
                elements: {
                    reference: j,
                    popper: B
                },
                attributes: {},
                styles: {}
            }, le = [], se = !1, re = {
                state: Q,
                setOptions: function(y) {
                    var e = "function" == typeof y ? y(Q.options) : y;
                    ae(),
                    Q.options = Object.assign({}, N, Q.options, e),
                    Q.scrollParents = {
                        reference: de(j) ? tt(j) : j.contextElement ? tt(j.contextElement) : [],
                        popper: tt(B)
                    };
                    var t, i, a, r, s = (t = [].concat(O, Q.options.modifiers),
                    i = t.reduce(function(a, r) {
                        var n = a[r.name];
                        return a[r.name] = n ? Object.assign({}, n, r, {
                            options: Object.assign({}, n.options, r.options),
                            data: Object.assign({}, n.data, r.data)
                        }) : r,
                        a
                    }, {}),
                    a = Object.keys(i).map(function(a) {
                        return i[a]
                    }),
                    r = At(a),
                    F.reduce(function(n, o) {
                        return n.concat(r.filter(function(l) {
                            return l.phase === o
                        }))
                    }, []));
                    return Q.orderedModifiers = s.filter(function(a) {
                        return a.enabled
                    }),
                    Q.orderedModifiers.forEach(function(a) {
                        var n = a.options
                          , l = a.effect;
                        if ("function" == typeof l) {
                            var c = l({
                                state: Q,
                                name: a.name,
                                instance: re,
                                options: void 0 === n ? {} : n
                            });
                            le.push(c || function() {}
                            )
                        }
                    }),
                    re.update()
                },
                forceUpdate: function() {
                    if (!se) {
                        var y = Q.elements
                          , e = y.reference
                          , t = y.popper;
                        if (Mt(e, t)) {
                            Q.rects = {
                                reference: D(e, He(t), "fixed" === Q.options.strategy),
                                popper: Ee(t)
                            },
                            Q.reset = !1,
                            Q.placement = Q.options.placement,
                            Q.orderedModifiers.forEach(function(l) {
                                return Q.modifiersData[l.name] = Object.assign({}, l.data)
                            });
                            for (var i = 0; i < Q.orderedModifiers.length; i++)
                                if (!0 !== Q.reset) {
                                    var s = Q.orderedModifiers[i]
                                      , a = s.fn
                                      , r = s.options;
                                    "function" == typeof a && (Q = a({
                                        state: Q,
                                        options: void 0 === r ? {} : r,
                                        name: s.name,
                                        instance: re
                                    }) || Q)
                                } else
                                    Q.reset = !1,
                                    i = -1
                        }
                    }
                },
                update: (K = function() {
                    return new Promise(function(y) {
                        re.forceUpdate(),
                        y(Q)
                    }
                    )
                }
                ,
                function() {
                    return J || (J = new Promise(function(y) {
                        Promise.resolve().then(function() {
                            J = void 0,
                            y(K())
                        })
                    }
                    )),
                    J
                }
                ),
                destroy: function() {
                    ae(),
                    se = !0
                }
            };
            if (!Mt(j, B))
                return re;
            function ae() {
                le.forEach(function(y) {
                    return y()
                }),
                le = []
            }
            return re.setOptions(U).then(function(y) {
                !se && U.onFirstUpdate && U.onFirstUpdate(y)
            }),
            re
        }
    }
    var Ue = {
        passive: !0
    }
      , zt = {
        name: "eventListeners",
        enabled: !0,
        phase: "write",
        fn: function() {},
        effect: function(E) {
            var T = E.state
              , z = E.instance
              , O = E.options
              , q = O.scroll
              , N = void 0 === q || q
              , j = O.resize
              , B = void 0 === j || j
              , U = Z(T.elements.popper)
              , K = [].concat(T.scrollParents.reference, T.scrollParents.popper);
            return N && K.forEach(function(J) {
                J.addEventListener("scroll", z.update, Ue)
            }),
            B && U.addEventListener("resize", z.update, Ue),
            function() {
                N && K.forEach(function(J) {
                    J.removeEventListener("scroll", z.update, Ue)
                }),
                B && U.removeEventListener("resize", z.update, Ue)
            }
        },
        data: {}
    }
      , Xt = {
        name: "popperOffsets",
        enabled: !0,
        phase: "read",
        fn: function(E) {
            var T = E.state;
            T.modifiersData[E.name] = Be({
                reference: T.rects.reference,
                element: T.rects.popper,
                strategy: "absolute",
                placement: T.placement
            })
        },
        data: {}
    }
      , ti = {
        top: "auto",
        right: "auto",
        bottom: "auto",
        left: "auto"
    };
    function qt(E) {
        var T, z = E.popper, O = E.popperRect, q = E.placement, N = E.variation, j = E.offsets, B = E.position, U = E.gpuAcceleration, K = E.adaptive, J = E.roundOffsets, Q = E.isFixed, le = j.x, se = void 0 === le ? 0 : le, re = j.y, ae = void 0 === re ? 0 : re, y = "function" == typeof J ? J({
            x: se,
            y: ae
        }) : {
            x: se,
            y: ae
        };
        se = y.x,
        ae = y.y;
        var e = j.hasOwnProperty("x")
          , t = j.hasOwnProperty("y")
          , i = _e
          , s = Se
          , a = window;
        if (K) {
            var r = He(z)
              , n = "clientHeight"
              , o = "clientWidth";
            r === Z(z) && "static" !== Ce(r = Me(z)).position && "absolute" === B && (n = "scrollHeight",
            o = "scrollWidth"),
            (q === Se || (q === _e || q === Ae) && N === ht) && (s = ue,
            ae -= (Q && r === a && a.visualViewport ? a.visualViewport.height : r[n]) - O.height,
            ae *= U ? 1 : -1),
            (q === _e || (q === Se || q === ue) && N === ht) && (i = Ae,
            se -= (Q && r === a && a.visualViewport ? a.visualViewport.width : r[o]) - O.width,
            se *= U ? 1 : -1)
        }
        var l, g, p, x, v, c = Object.assign({
            position: B
        }, K && ti), d = !0 === J ? (g = {
            x: se,
            y: ae
        },
        p = Z(z),
        x = g.y,
        {
            x: Fe(g.x * (v = p.devicePixelRatio || 1)) / v || 0,
            y: Fe(x * v) / v || 0
        }) : {
            x: se,
            y: ae
        };
        return se = d.x,
        ae = d.y,
        Object.assign({}, c, U ? ((l = {})[s] = t ? "0" : "",
        l[i] = e ? "0" : "",
        l.transform = (a.devicePixelRatio || 1) <= 1 ? "translate(" + se + "px, " + ae + "px)" : "translate3d(" + se + "px, " + ae + "px, 0)",
        l) : ((T = {})[s] = t ? ae + "px" : "",
        T[i] = e ? se + "px" : "",
        T.transform = "",
        T))
    }
    var Ot = {
        name: "computeStyles",
        enabled: !0,
        phase: "beforeWrite",
        fn: function(E) {
            var T = E.state
              , z = E.options
              , O = z.gpuAcceleration
              , q = void 0 === O || O
              , N = z.adaptive
              , j = void 0 === N || N
              , B = z.roundOffsets
              , U = void 0 === B || B
              , K = {
                placement: fe(T.placement),
                variation: Xe(T.placement),
                popper: T.elements.popper,
                popperRect: T.rects.popper,
                gpuAcceleration: q,
                isFixed: "fixed" === T.options.strategy
            };
            null != T.modifiersData.popperOffsets && (T.styles.popper = Object.assign({}, T.styles.popper, qt(Object.assign({}, K, {
                offsets: T.modifiersData.popperOffsets,
                position: T.options.strategy,
                adaptive: j,
                roundOffsets: U
            })))),
            null != T.modifiersData.arrow && (T.styles.arrow = Object.assign({}, T.styles.arrow, qt(Object.assign({}, K, {
                offsets: T.modifiersData.arrow,
                position: "absolute",
                adaptive: !1,
                roundOffsets: U
            })))),
            T.attributes.popper = Object.assign({}, T.attributes.popper, {
                "data-popper-placement": T.placement
            })
        },
        data: {}
    }
      , Dt = {
        name: "applyStyles",
        enabled: !0,
        phase: "write",
        fn: function(E) {
            var T = E.state;
            Object.keys(T.elements).forEach(function(z) {
                var O = T.styles[z] || {}
                  , q = T.attributes[z] || {}
                  , N = T.elements[z];
                W(N) && pe(N) && (Object.assign(N.style, O),
                Object.keys(q).forEach(function(j) {
                    var B = q[j];
                    !1 === B ? N.removeAttribute(j) : N.setAttribute(j, !0 === B ? "" : B)
                }))
            })
        },
        effect: function(E) {
            var T = E.state
              , z = {
                popper: {
                    position: T.options.strategy,
                    left: "0",
                    top: "0",
                    margin: "0"
                },
                arrow: {
                    position: "absolute"
                },
                reference: {}
            };
            return Object.assign(T.elements.popper.style, z.popper),
            T.styles = z,
            T.elements.arrow && Object.assign(T.elements.arrow.style, z.arrow),
            function() {
                Object.keys(T.elements).forEach(function(O) {
                    var q = T.elements[O]
                      , N = T.attributes[O] || {}
                      , j = Object.keys(T.styles.hasOwnProperty(O) ? T.styles[O] : z[O]).reduce(function(B, U) {
                        return B[U] = "",
                        B
                    }, {});
                    W(q) && pe(q) && (Object.assign(q.style, j),
                    Object.keys(N).forEach(function(B) {
                        q.removeAttribute(B)
                    }))
                })
            }
        },
        requires: ["computeStyles"]
    }
      , xt = {
        name: "offset",
        enabled: !0,
        phase: "main",
        requires: ["popperOffsets"],
        fn: function(E) {
            var T = E.state
              , O = E.name
              , q = E.options.offset
              , N = void 0 === q ? [0, 0] : q
              , j = it.reduce(function(J, Q) {
                return J[Q] = (se = T.rects,
                re = N,
                ae = fe(le = Q),
                y = [_e, Se].indexOf(ae) >= 0 ? -1 : 1,
                t = (t = (e = "function" == typeof re ? re(Object.assign({}, se, {
                    placement: le
                })) : re)[0]) || 0,
                i = ((i = e[1]) || 0) * y,
                [_e, Ae].indexOf(ae) >= 0 ? {
                    x: i,
                    y: t
                } : {
                    x: t,
                    y: i
                }),
                J;
                var le, se, re, ae, y, e, t, i
            }, {})
              , B = j[T.placement]
              , K = B.y;
            null != T.modifiersData.popperOffsets && (T.modifiersData.popperOffsets.x += B.x,
            T.modifiersData.popperOffsets.y += K),
            T.modifiersData[O] = j
        }
    }
      , Ct = {
        left: "right",
        right: "left",
        bottom: "top",
        top: "bottom"
    };
    function Oe(E) {
        return E.replace(/left|right|bottom|top/g, function(T) {
            return Ct[T]
        })
    }
    var Yt = {
        start: "end",
        end: "start"
    };
    function gt(E) {
        return E.replace(/start|end/g, function(T) {
            return Yt[T]
        })
    }
    var at = {
        name: "flip",
        enabled: !0,
        phase: "main",
        fn: function(E) {
            var T = E.state
              , z = E.options
              , O = E.name;
            if (!T.modifiersData[O]._skip) {
                for (var q = z.mainAxis, N = void 0 === q || q, j = z.altAxis, B = void 0 === j || j, U = z.fallbackPlacements, K = z.padding, J = z.boundary, Q = z.rootBoundary, le = z.altBoundary, se = z.flipVariations, re = void 0 === se || se, ae = z.allowedAutoPlacements, y = T.options.placement, e = fe(y), t = U || (e !== y && re ? function(u) {
                    if (fe(u) === Ge)
                        return [];
                    var b = Oe(u);
                    return [gt(u), b, gt(b)]
                }(y) : [Oe(y)]), i = [y].concat(t).reduce(function(u, b) {
                    return u.concat(fe(b) === Ge ? function st(E, T) {
                        void 0 === T && (T = {});
                        var q = T.boundary
                          , N = T.rootBoundary
                          , j = T.padding
                          , B = T.flipVariations
                          , U = T.allowedAutoPlacements
                          , K = void 0 === U ? it : U
                          , J = Xe(T.placement)
                          , Q = J ? B ? kt : kt.filter(function(re) {
                            return Xe(re) === J
                        }) : lt
                          , le = Q.filter(function(re) {
                            return K.indexOf(re) >= 0
                        });
                        0 === le.length && (le = Q);
                        var se = le.reduce(function(re, ae) {
                            return re[ae] = dt(E, {
                                placement: ae,
                                boundary: q,
                                rootBoundary: N,
                                padding: j
                            })[fe(ae)],
                            re
                        }, {});
                        return Object.keys(se).sort(function(re, ae) {
                            return se[re] - se[ae]
                        })
                    }(T, {
                        placement: b,
                        boundary: J,
                        rootBoundary: Q,
                        padding: K,
                        flipVariations: re,
                        allowedAutoPlacements: ae
                    }) : b)
                }, []), s = T.rects.reference, a = T.rects.popper, r = new Map, n = !0, o = i[0], l = 0; l < i.length; l++) {
                    var c = i[l]
                      , d = fe(c)
                      , g = Xe(c) === ve
                      , p = [Se, ue].indexOf(d) >= 0
                      , m = p ? "width" : "height"
                      , x = dt(T, {
                        placement: c,
                        boundary: J,
                        rootBoundary: Q,
                        altBoundary: le,
                        padding: K
                    })
                      , v = p ? g ? Ae : _e : g ? ue : Se;
                    s[m] > a[m] && (v = Oe(v));
                    var k = Oe(v)
                      , S = [];
                    if (N && S.push(x[d] <= 0),
                    B && S.push(x[v] <= 0, x[k] <= 0),
                    S.every(function(u) {
                        return u
                    })) {
                        o = c,
                        n = !1;
                        break
                    }
                    r.set(c, S)
                }
                if (n)
                    for (var C = function(u) {
                        var b = i.find(function(w) {
                            var _ = r.get(w);
                            if (_)
                                return _.slice(0, u).every(function(X) {
                                    return X
                                })
                        });
                        if (b)
                            return o = b,
                            "break"
                    }, h = re ? 3 : 1; h > 0 && "break" !== C(h); h--)
                        ;
                T.placement !== o && (T.modifiersData[O]._skip = !0,
                T.placement = o,
                T.reset = !0)
            }
        },
        requiresIfExists: ["offset"],
        data: {
            _skip: !1
        }
    };
    function $e(E, T, z) {
        return V(E, Ke(T, z))
    }
    var Zt = {
        name: "preventOverflow",
        enabled: !0,
        phase: "main",
        fn: function(E) {
            var Ye, di, T = E.state, z = E.options, O = E.name, q = z.mainAxis, N = void 0 === q || q, j = z.altAxis, B = void 0 !== j && j, le = z.tether, se = void 0 === le || le, re = z.tetherOffset, ae = void 0 === re ? 0 : re, y = dt(T, {
                boundary: z.boundary,
                rootBoundary: z.rootBoundary,
                padding: z.padding,
                altBoundary: z.altBoundary
            }), e = fe(T.placement), t = Xe(T.placement), i = !t, s = te(e), a = "x" === s ? "y" : "x", r = T.modifiersData.popperOffsets, n = T.rects.reference, o = T.rects.popper, l = "function" == typeof ae ? ae(Object.assign({}, T.rects, {
                placement: T.placement
            })) : ae, c = "number" == typeof l ? {
                mainAxis: l,
                altAxis: l
            } : Object.assign({
                mainAxis: 0,
                altAxis: 0
            }, l), d = T.modifiersData.offset ? T.modifiersData.offset[T.placement] : null, g = {
                x: 0,
                y: 0
            };
            if (r) {
                if (N) {
                    var p, m = "y" === s ? Se : _e, x = "y" === s ? ue : Ae, v = "y" === s ? "height" : "width", k = r[s], S = k + y[m], C = k - y[x], h = se ? -o[v] / 2 : 0, u = t === ve ? n[v] : o[v], b = t === ve ? -o[v] : -n[v], w = T.elements.arrow, _ = se && w ? Ee(w) : {
                        width: 0,
                        height: 0
                    }, X = T.modifiersData["arrow#persistent"] ? T.modifiersData["arrow#persistent"].padding : {
                        top: 0,
                        right: 0,
                        bottom: 0,
                        left: 0
                    }, I = X[m], R = X[x], H = $e(0, n[v], _[v]), G = i ? n[v] / 2 - h - H - I - c.mainAxis : u - H - I - c.mainAxis, ie = i ? -n[v] / 2 + h + H + R + c.mainAxis : b + H + R + c.mainAxis, ne = T.elements.arrow && He(T.elements.arrow), ye = null != (p = d?.[s]) ? p : 0, Le = k + ie - ye, De = $e(se ? Ke(S, k + G - ye - (ne ? "y" === s ? ne.clientTop || 0 : ne.clientLeft || 0 : 0)) : S, k, se ? V(C, Le) : C);
                    r[s] = De,
                    g[s] = De - k
                }
                if (B) {
                    var qe, Ze = r[a], ft = "y" === a ? "height" : "width", mt = Ze + y["x" === s ? Se : _e], Pe = Ze - y["x" === s ? ue : Ae], we = -1 !== [Se, _e].indexOf(e), Pt = null != (qe = d?.[a]) ? qe : 0, si = we ? mt : Ze - n[ft] - o[ft] - Pt + c.altAxis, ai = we ? Ze + n[ft] + o[ft] - Pt - c.altAxis : Pe, Rt = se && we ? (di = $e(si, Ze, Ye = ai)) > Ye ? Ye : di : $e(se ? si : mt, Ze, se ? ai : Pe);
                    r[a] = Rt,
                    g[a] = Rt - Ze
                }
                T.modifiersData[O] = g
            }
        },
        requiresIfExists: ["offset"]
    }
      , _t = {
        name: "arrow",
        enabled: !0,
        phase: "main",
        fn: function(E) {
            var T, o, l, z = E.state, O = E.name, q = E.options, N = z.elements.arrow, j = z.modifiersData.popperOffsets, B = fe(z.placement), U = te(B), K = [_e, Ae].indexOf(B) >= 0 ? "height" : "width";
            if (N && j) {
                var J = (l = z,
                pt("number" != typeof (o = "function" == typeof (o = q.padding) ? o(Object.assign({}, l.rects, {
                    placement: l.placement
                })) : o) ? o : St(o, lt)))
                  , Q = Ee(N)
                  , le = "y" === U ? Se : _e
                  , se = "y" === U ? ue : Ae
                  , re = z.rects.reference[K] + z.rects.reference[U] - j[U] - z.rects.popper[K]
                  , ae = j[U] - z.rects.reference[U]
                  , y = He(N)
                  , e = y ? "y" === U ? y.clientHeight || 0 : y.clientWidth || 0 : 0
                  , a = e / 2 - Q[K] / 2 + (re / 2 - ae / 2)
                  , r = $e(J[le], a, e - Q[K] - J[se]);
                z.modifiersData[O] = ((T = {})[U] = r,
                T.centerOffset = r - a,
                T)
            }
        },
        effect: function(E) {
            var T = E.state
              , z = E.options.element
              , O = void 0 === z ? "[data-popper-arrow]" : z;
            null != O && ("string" != typeof O || (O = T.elements.popper.querySelector(O))) && It(T.elements.popper, O) && (T.elements.arrow = O)
        },
        requires: ["popperOffsets"],
        requiresIfExists: ["preventOverflow"]
    };
    function Qt(E, T, z) {
        return void 0 === z && (z = {
            x: 0,
            y: 0
        }),
        {
            top: E.top - T.height - z.y,
            right: E.right - T.width + z.x,
            bottom: E.bottom - T.height + z.y,
            left: E.left - T.width - z.x
        }
    }
    function Kt(E) {
        return [Se, Ae, ue, _e].some(function(T) {
            return E[T] >= 0
        })
    }
    var Ft = {
        name: "hide",
        enabled: !0,
        phase: "main",
        requiresIfExists: ["preventOverflow"],
        fn: function(E) {
            var T = E.state
              , z = E.name
              , O = T.rects.reference
              , q = T.rects.popper
              , N = T.modifiersData.preventOverflow
              , j = dt(T, {
                elementContext: "reference"
            })
              , B = dt(T, {
                altBoundary: !0
            })
              , U = Qt(j, O)
              , K = Qt(B, q, N)
              , J = Kt(U)
              , Q = Kt(K);
            T.modifiersData[z] = {
                referenceClippingOffsets: U,
                popperEscapeOffsets: K,
                isReferenceHidden: J,
                hasPopperEscaped: Q
            },
            T.attributes.popper = Object.assign({}, T.attributes.popper, {
                "data-popper-reference-hidden": J,
                "data-popper-escaped": Q
            })
        }
    }
      , Nt = je({
        defaultModifiers: [zt, Xt, Ot, Dt]
    })
      , Ht = [zt, Xt, Ot, Dt, xt, at, Zt, _t, Ft]
      , ii = je({
        defaultModifiers: Ht
    });
    ce.applyStyles = Dt,
    ce.arrow = _t,
    ce.computeStyles = Ot,
    ce.createPopper = ii,
    ce.createPopperLite = Nt,
    ce.defaultModifiers = Ht,
    ce.detectOverflow = dt,
    ce.eventListeners = zt,
    ce.flip = at,
    ce.hide = Ft,
    ce.offset = xt,
    ce.popperGenerator = je,
    ce.popperOffsets = Xt,
    ce.preventOverflow = Zt,
    Object.defineProperty(ce, "__esModule", {
        value: !0
    })
}),
function(ce, Z) {
    "object" == typeof exports && typeof module < "u" ? module.exports = Z(require("@popperjs/core")) : "function" == typeof define && define.amd ? define(["@popperjs/core"], Z) : (ce = typeof globalThis < "u" ? globalThis : ce || self).bootstrap = Z(ce.Popper)
}(this, function(ce) {
    "use strict";
    const de = function Z(P) {
        const f = Object.create(null, {
            [Symbol.toStringTag]: {
                value: "Module"
            }
        });
        if (P)
            for (const A in P)
                if ("default" !== A) {
                    const L = Object.getOwnPropertyDescriptor(P, A);
                    Object.defineProperty(f, A, L.get ? L : {
                        enumerable: !0,
                        get: ()=>P[A]
                    })
                }
        return f.default = P,
        Object.freeze(f)
    }(ce)
      , W = new Map
      , ot = {
        set(P, f, A) {
            W.has(P) || W.set(P, new Map);
            const L = W.get(P);
            L.has(f) || 0 === L.size ? L.set(f, A) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(L.keys())[0]}.`)
        },
        get: (P,f)=>W.has(P) && W.get(P).get(f) || null,
        remove(P, f) {
            if (!W.has(P))
                return;
            const A = W.get(P);
            A.delete(f),
            0 === A.size && W.delete(P)
        }
    }
      , V = "transitionend"
      , Ke = P=>(P && window.CSS && window.CSS.escape && (P = P.replace(/#([^\s"#']+)/g, (f,A)=>`#${CSS.escape(A)}`)),
    P)
      , Fe = P=>{
        P.dispatchEvent(new Event(V))
    }
      , Ie = P=>!(!P || "object" != typeof P) && (void 0 !== P.jquery && (P = P[0]),
    void 0 !== P.nodeType)
      , We = P=>Ie(P) ? P.jquery ? P[0] : P : "string" == typeof P && P.length > 0 ? document.querySelector(Ke(P)) : null
      , Ne = P=>{
        if (!Ie(P) || 0 === P.getClientRects().length)
            return !1;
        const f = "visible" === getComputedStyle(P).getPropertyValue("visibility")
          , A = P.closest("details:not([open])");
        if (!A)
            return f;
        if (A !== P) {
            const L = P.closest("summary");
            if (L && L.parentNode !== A || null === L)
                return !1
        }
        return f
    }
      , Te = P=>!P || P.nodeType !== Node.ELEMENT_NODE || !!P.classList.contains("disabled") || (void 0 !== P.disabled ? P.disabled : P.hasAttribute("disabled") && "false" !== P.getAttribute("disabled"))
      , pe = P=>{
        if (!document.documentElement.attachShadow)
            return null;
        if ("function" == typeof P.getRootNode) {
            const f = P.getRootNode();
            return f instanceof ShadowRoot ? f : null
        }
        return P instanceof ShadowRoot ? P : P.parentNode ? pe(P.parentNode) : null
    }
      , Me = ()=>{}
      , Ce = ()=>window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null
      , me = []
      , D = ()=>"rtl" === document.documentElement.dir
      , Ee = P=>{
        var f;
        f = ()=>{
            const A = Ce();
            if (A) {
                const L = P.NAME
                  , Y = A.fn[L];
                A.fn[L] = P.jQueryInterface,
                A.fn[L].Constructor = P,
                A.fn[L].noConflict = ()=>(A.fn[L] = Y,
                P.jQueryInterface)
            }
        }
        ,
        "loading" === document.readyState ? (me.length || document.addEventListener("DOMContentLoaded", ()=>{
            for (const A of me)
                A()
        }
        ),
        me.push(f)) : f()
    }
      , ke = (P,f=[],A=P)=>"function" == typeof P ? P(...f) : A
      , xe = (P,f,A=!0)=>{
        if (!A)
            return void ke(P);
        const L = (ee=>{
            if (!ee)
                return 0;
            let {transitionDuration: he, transitionDelay: be} = window.getComputedStyle(ee);
            const Ve = Number.parseFloat(he)
              , Qe = Number.parseFloat(be);
            return Ve || Qe ? (he = he.split(",")[0],
            be = be.split(",")[0],
            1e3 * (Number.parseFloat(he) + Number.parseFloat(be))) : 0
        }
        )(f) + 5;
        let Y = !1;
        const $ = ({target: ee})=>{
            ee === f && (Y = !0,
            f.removeEventListener(V, $),
            ke(P))
        }
        ;
        f.addEventListener(V, $),
        setTimeout(()=>{
            Y || Fe(f)
        }
        , L)
    }
      , tt = (P,f,A,L)=>{
        const Y = P.length;
        let $ = P.indexOf(f);
        return -1 === $ ? !A && L ? P[Y - 1] : P[0] : ($ += A ? 1 : -1,
        L && ($ = ($ + Y) % Y),
        P[Math.max(0, Math.min($, Y - 1))])
    }
      , ei = /[^.]*(?=\..*)\.|.*/
      , Et = /\..*/
      , He = /::\d+$/
      , Se = {};
    let ue = 1;
    const Ae = {
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    }
      , _e = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
    function Ge(P, f) {
        return f && `${f}::${ue++}` || P.uidEvent || ue++
    }
    function lt(P) {
        const f = Ge(P);
        return P.uidEvent = f,
        Se[f] = Se[f] || {},
        Se[f]
    }
    function ve(P, f, A=null) {
        return Object.values(P).find(L=>L.callable === f && L.delegationSelector === A)
    }
    function ht(P, f, A) {
        const L = "string" == typeof f
          , Y = L ? A : f || A;
        let $ = it(P);
        return _e.has($) || ($ = P),
        [L, Y, $]
    }
    function Je(P, f, A, L, Y) {
        if ("string" != typeof f || !P)
            return;
        let[$,ee,he] = ht(f, A, L);
        var Ut;
        f in Ae && (Ut = ee,
        ee = function(rt) {
            if (!rt.relatedTarget || rt.relatedTarget !== rt.delegateTarget && !rt.delegateTarget.contains(rt.relatedTarget))
                return Ut.call(this, rt)
        }
        );
        const be = lt(P)
          , Ve = be[he] || (be[he] = {})
          , Qe = ve(Ve, ee, $ ? A : null);
        if (Qe)
            return void (Qe.oneOff = Qe.oneOff && Y);
        const nt = Ge(ee, f.replace(ei, ""))
          , yt = $ ? function(wt, Ut, rt) {
            return function hi(xi) {
                const Qs = wt.querySelectorAll(Ut);
                for (let {target: $t} = xi; $t && $t !== this; $t = $t.parentNode)
                    for (const Ks of Qs)
                        if (Ks === $t)
                            return At(xi, {
                                delegateTarget: $t
                            }),
                            hi.oneOff && F.off(wt, xi.type, Ut, rt),
                            rt.apply($t, [xi])
            }
        }(P, A, ee) : function(wt, Ut) {
            return function rt(hi) {
                return At(hi, {
                    delegateTarget: wt
                }),
                rt.oneOff && F.off(wt, hi.type, Ut),
                Ut.apply(wt, [hi])
            }
        }(P, ee);
        yt.delegationSelector = $ ? A : null,
        yt.callable = ee,
        yt.oneOff = Y,
        yt.uidEvent = nt,
        Ve[nt] = yt,
        P.addEventListener(he, yt, $)
    }
    function ge(P, f, A, L, Y) {
        const $ = ve(f[A], L, Y);
        $ && (P.removeEventListener(A, $, Boolean(Y)),
        delete f[A][$.uidEvent])
    }
    function kt(P, f, A, L) {
        const Y = f[A] || {};
        for (const [$,ee] of Object.entries(Y))
            $.includes(L) && ge(P, f, A, ee.callable, ee.delegationSelector)
    }
    function it(P) {
        return P = P.replace(Et, ""),
        Ae[P] || P
    }
    const F = {
        on(P, f, A, L) {
            Je(P, f, A, L, !1)
        },
        one(P, f, A, L) {
            Je(P, f, A, L, !0)
        },
        off(P, f, A, L) {
            if ("string" != typeof f || !P)
                return;
            const [Y,$,ee] = ht(f, A, L)
              , he = ee !== f
              , be = lt(P)
              , Ve = be[ee] || {}
              , Qe = f.startsWith(".");
            if (void 0 === $) {
                if (Qe)
                    for (const nt of Object.keys(be))
                        kt(P, be, nt, f.slice(1));
                for (const [nt,yt] of Object.entries(Ve)) {
                    const wt = nt.replace(He, "");
                    he && !f.includes(wt) || ge(P, be, ee, yt.callable, yt.delegationSelector)
                }
            } else {
                if (!Object.keys(Ve).length)
                    return;
                ge(P, be, ee, $, Y ? A : null)
            }
        },
        trigger(P, f, A) {
            if ("string" != typeof f || !P)
                return null;
            const L = Ce();
            let Y = null
              , $ = !0
              , ee = !0
              , he = !1;
            f !== it(f) && L && (Y = L.Event(f, A),
            L(P).trigger(Y),
            $ = !Y.isPropagationStopped(),
            ee = !Y.isImmediatePropagationStopped(),
            he = Y.isDefaultPrevented());
            const be = At(new Event(f,{
                bubbles: $,
                cancelable: !0
            }), A);
            return he && be.preventDefault(),
            ee && P.dispatchEvent(be),
            be.defaultPrevented && Y && Y.preventDefault(),
            be
        }
    };
    function At(P, f={}) {
        for (const [A,L] of Object.entries(f))
            try {
                P[A] = L
            } catch {
                Object.defineProperty(P, A, {
                    configurable: !0,
                    get: ()=>L
                })
            }
        return P
    }
    function It(P) {
        if ("true" === P)
            return !0;
        if ("false" === P)
            return !1;
        if (P === Number(P).toString())
            return Number(P);
        if ("" === P || "null" === P)
            return null;
        if ("string" != typeof P)
            return P;
        try {
            return JSON.parse(decodeURIComponent(P))
        } catch {
            return P
        }
    }
    function ct(P) {
        return P.replace(/[A-Z]/g, f=>`-${f.toLowerCase()}`)
    }
    const ze = {
        setDataAttribute(P, f, A) {
            P.setAttribute(`data-bs-${ct(f)}`, A)
        },
        removeDataAttribute(P, f) {
            P.removeAttribute(`data-bs-${ct(f)}`)
        },
        getDataAttributes(P) {
            if (!P)
                return {};
            const f = {}
              , A = Object.keys(P.dataset).filter(L=>L.startsWith("bs") && !L.startsWith("bsConfig"));
            for (const L of A) {
                let Y = L.replace(/^bs/, "");
                Y = Y.charAt(0).toLowerCase() + Y.slice(1, Y.length),
                f[Y] = It(P.dataset[L])
            }
            return f
        },
        getDataAttribute: (P,f)=>It(P.getAttribute(`data-bs-${ct(f)}`))
    };
    class Re {
        static get Default() {
            return {}
        }
        static get DefaultType() {
            return {}
        }
        static get NAME() {
            throw new Error('You have to implement the static method "NAME", for each component!')
        }
        _getConfig(f) {
            return f = this._mergeConfigObj(f),
            f = this._configAfterMerge(f),
            this._typeCheckConfig(f),
            f
        }
        _configAfterMerge(f) {
            return f
        }
        _mergeConfigObj(f, A) {
            const L = Ie(A) ? ze.getDataAttribute(A, "config") : {};
            return {
                ...this.constructor.Default,
                ..."object" == typeof L ? L : {},
                ...Ie(A) ? ze.getDataAttributes(A) : {},
                ..."object" == typeof f ? f : {}
            }
        }
        _typeCheckConfig(f, A=this.constructor.DefaultType) {
            for (const [Y,$] of Object.entries(A)) {
                const ee = f[Y]
                  , he = Ie(ee) ? "element" : null == (L = ee) ? `${L}` : Object.prototype.toString.call(L).match(/\s([a-z]+)/i)[1].toLowerCase();
                if (!new RegExp($).test(he))
                    throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${Y}" provided type "${he}" but expected type "${$}".`)
            }
            var L
        }
    }
    class fe extends Re {
        constructor(f, A) {
            super(),
            (f = We(f)) && (this._element = f,
            this._config = this._getConfig(A),
            ot.set(this._element, this.constructor.DATA_KEY, this))
        }
        dispose() {
            ot.remove(this._element, this.constructor.DATA_KEY),
            F.off(this._element, this.constructor.EVENT_KEY);
            for (const f of Object.getOwnPropertyNames(this))
                this[f] = null
        }
        _queueCallback(f, A, L=!0) {
            xe(f, A, L)
        }
        _getConfig(f) {
            return f = this._mergeConfigObj(f, this._element),
            f = this._configAfterMerge(f),
            this._typeCheckConfig(f),
            f
        }
        static getInstance(f) {
            return ot.get(We(f), this.DATA_KEY)
        }
        static getOrCreateInstance(f, A={}) {
            return this.getInstance(f) || new this(f,"object" == typeof A ? A : null)
        }
        static get VERSION() {
            return "5.3.3"
        }
        static get DATA_KEY() {
            return `bs.${this.NAME}`
        }
        static get EVENT_KEY() {
            return `.${this.DATA_KEY}`
        }
        static eventName(f) {
            return `${f}${this.EVENT_KEY}`
        }
    }
    const Xe = P=>{
        let f = P.getAttribute("data-bs-target");
        if (!f || "#" === f) {
            let A = P.getAttribute("href");
            if (!A || !A.includes("#") && !A.startsWith("."))
                return null;
            A.includes("#") && !A.startsWith("#") && (A = `#${A.split("#")[1]}`),
            f = A && "#" !== A ? A.trim() : null
        }
        return f ? f.split(",").map(A=>Ke(A)).join(",") : null
    }
      , te = {
        find: (P,f=document.documentElement)=>[].concat(...Element.prototype.querySelectorAll.call(f, P)),
        findOne: (P,f=document.documentElement)=>Element.prototype.querySelector.call(f, P),
        children: (P,f)=>[].concat(...P.children).filter(A=>A.matches(f)),
        parents(P, f) {
            const A = [];
            let L = P.parentNode.closest(f);
            for (; L; )
                A.push(L),
                L = L.parentNode.closest(f);
            return A
        },
        prev(P, f) {
            let A = P.previousElementSibling;
            for (; A; ) {
                if (A.matches(f))
                    return [A];
                A = A.previousElementSibling
            }
            return []
        },
        next(P, f) {
            let A = P.nextElementSibling;
            for (; A; ) {
                if (A.matches(f))
                    return [A];
                A = A.nextElementSibling
            }
            return []
        },
        focusableChildren(P) {
            const f = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map(A=>`${A}:not([tabindex^="-"])`).join(",");
            return this.find(f, P).filter(A=>!Te(A) && Ne(A))
        },
        getSelectorFromElement(P) {
            const f = Xe(P);
            return f && te.findOne(f) ? f : null
        },
        getElementFromSelector(P) {
            const f = Xe(P);
            return f ? te.findOne(f) : null
        },
        getMultipleElementsFromSelector(P) {
            const f = Xe(P);
            return f ? te.find(f) : []
        }
    }
      , Be = (P,f="hide")=>{
        const L = P.NAME;
        F.on(document, `click.dismiss${P.EVENT_KEY}`, `[data-bs-dismiss="${L}"]`, function(Y) {
            if (["A", "AREA"].includes(this.tagName) && Y.preventDefault(),
            Te(this))
                return;
            const $ = te.getElementFromSelector(this) || this.closest(`.${L}`);
            P.getOrCreateInstance($)[f]()
        })
    }
      , pt = ".bs.alert"
      , St = `close${pt}`
      , dt = `closed${pt}`;
    class ut extends fe {
        static get NAME() {
            return "alert"
        }
        close() {
            if (F.trigger(this._element, St).defaultPrevented)
                return;
            this._element.classList.remove("show");
            const f = this._element.classList.contains("fade");
            this._queueCallback(()=>this._destroyElement(), this._element, f)
        }
        _destroyElement() {
            this._element.remove(),
            F.trigger(this._element, dt),
            this.dispose()
        }
        static jQueryInterface(f) {
            return this.each(function() {
                const A = ut.getOrCreateInstance(this);
                if ("string" == typeof f) {
                    if (void 0 === A[f] || f.startsWith("_") || "constructor" === f)
                        throw new TypeError(`No method named "${f}"`);
                    A[f](this)
                }
            })
        }
    }
    Be(ut, "close"),
    Ee(ut);
    const Mt = '[data-bs-toggle="button"]';
    class je extends fe {
        static get NAME() {
            return "button"
        }
        toggle() {
            this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"))
        }
        static jQueryInterface(f) {
            return this.each(function() {
                const A = je.getOrCreateInstance(this);
                "toggle" === f && A[f]()
            })
        }
    }
    F.on(document, "click.bs.button.data-api", Mt, P=>{
        P.preventDefault();
        const f = P.target.closest(Mt);
        je.getOrCreateInstance(f).toggle()
    }
    ),
    Ee(je);
    const Ue = ".bs.swipe"
      , zt = `touchstart${Ue}`
      , Xt = `touchmove${Ue}`
      , ti = `touchend${Ue}`
      , qt = `pointerdown${Ue}`
      , Ot = `pointerup${Ue}`
      , Dt = {
        endCallback: null,
        leftCallback: null,
        rightCallback: null
    }
      , xt = {
        endCallback: "(function|null)",
        leftCallback: "(function|null)",
        rightCallback: "(function|null)"
    };
    class Ct extends Re {
        constructor(f, A) {
            super(),
            this._element = f,
            f && Ct.isSupported() && (this._config = this._getConfig(A),
            this._deltaX = 0,
            this._supportPointerEvents = Boolean(window.PointerEvent),
            this._initEvents())
        }
        static get Default() {
            return Dt
        }
        static get DefaultType() {
            return xt
        }
        static get NAME() {
            return "swipe"
        }
        dispose() {
            F.off(this._element, Ue)
        }
        _start(f) {
            this._supportPointerEvents ? this._eventIsPointerPenTouch(f) && (this._deltaX = f.clientX) : this._deltaX = f.touches[0].clientX
        }
        _end(f) {
            this._eventIsPointerPenTouch(f) && (this._deltaX = f.clientX - this._deltaX),
            this._handleSwipe(),
            ke(this._config.endCallback)
        }
        _move(f) {
            this._deltaX = f.touches && f.touches.length > 1 ? 0 : f.touches[0].clientX - this._deltaX
        }
        _handleSwipe() {
            const f = Math.abs(this._deltaX);
            if (f <= 40)
                return;
            const A = f / this._deltaX;
            this._deltaX = 0,
            A && ke(A > 0 ? this._config.rightCallback : this._config.leftCallback)
        }
        _initEvents() {
            this._supportPointerEvents ? (F.on(this._element, qt, f=>this._start(f)),
            F.on(this._element, Ot, f=>this._end(f)),
            this._element.classList.add("pointer-event")) : (F.on(this._element, zt, f=>this._start(f)),
            F.on(this._element, Xt, f=>this._move(f)),
            F.on(this._element, ti, f=>this._end(f)))
        }
        _eventIsPointerPenTouch(f) {
            return this._supportPointerEvents && ("pen" === f.pointerType || "touch" === f.pointerType)
        }
        static isSupported() {
            return "ontouchstart"in document.documentElement || navigator.maxTouchPoints > 0
        }
    }
    const Oe = ".bs.carousel"
      , Yt = ".data-api"
      , gt = "next"
      , st = "prev"
      , at = "left"
      , $e = "right"
      , Zt = `slide${Oe}`
      , _t = `slid${Oe}`
      , Qt = `keydown${Oe}`
      , Kt = `mouseenter${Oe}`
      , Ft = `mouseleave${Oe}`
      , Nt = `dragstart${Oe}`
      , Ht = `load${Oe}${Yt}`
      , ii = `click${Oe}${Yt}`
      , E = "carousel"
      , T = "active"
      , N = {
        ArrowLeft: $e,
        ArrowRight: at
    }
      , j = {
        interval: 5e3,
        keyboard: !0,
        pause: "hover",
        ride: !1,
        touch: !0,
        wrap: !0
    }
      , B = {
        interval: "(number|boolean)",
        keyboard: "boolean",
        pause: "(string|boolean)",
        ride: "(boolean|string)",
        touch: "boolean",
        wrap: "boolean"
    };
    class U extends fe {
        constructor(f, A) {
            super(f, A),
            this._interval = null,
            this._activeElement = null,
            this._isSliding = !1,
            this.touchTimeout = null,
            this._swipeHelper = null,
            this._indicatorsElement = te.findOne(".carousel-indicators", this._element),
            this._addEventListeners(),
            this._config.ride === E && this.cycle()
        }
        static get Default() {
            return j
        }
        static get DefaultType() {
            return B
        }
        static get NAME() {
            return "carousel"
        }
        next() {
            this._slide(gt)
        }
        nextWhenVisible() {
            !document.hidden && Ne(this._element) && this.next()
        }
        prev() {
            this._slide(st)
        }
        pause() {
            this._isSliding && Fe(this._element),
            this._clearInterval()
        }
        cycle() {
            this._clearInterval(),
            this._updateInterval(),
            this._interval = setInterval(()=>this.nextWhenVisible(), this._config.interval)
        }
        _maybeEnableCycle() {
            this._config.ride && (this._isSliding ? F.one(this._element, _t, ()=>this.cycle()) : this.cycle())
        }
        to(f) {
            const A = this._getItems();
            if (f > A.length - 1 || f < 0)
                return;
            if (this._isSliding)
                return void F.one(this._element, _t, ()=>this.to(f));
            const L = this._getItemIndex(this._getActive());
            L !== f && this._slide(f > L ? gt : st, A[f])
        }
        dispose() {
            this._swipeHelper && this._swipeHelper.dispose(),
            super.dispose()
        }
        _configAfterMerge(f) {
            return f.defaultInterval = f.interval,
            f
        }
        _addEventListeners() {
            this._config.keyboard && F.on(this._element, Qt, f=>this._keydown(f)),
            "hover" === this._config.pause && (F.on(this._element, Kt, ()=>this.pause()),
            F.on(this._element, Ft, ()=>this._maybeEnableCycle())),
            this._config.touch && Ct.isSupported() && this._addTouchEventListeners()
        }
        _addTouchEventListeners() {
            for (const A of te.find(".carousel-item img", this._element))
                F.on(A, Nt, L=>L.preventDefault());
            this._swipeHelper = new Ct(this._element,{
                leftCallback: ()=>this._slide(this._directionToOrder(at)),
                rightCallback: ()=>this._slide(this._directionToOrder($e)),
                endCallback: ()=>{
                    "hover" === this._config.pause && (this.pause(),
                    this.touchTimeout && clearTimeout(this.touchTimeout),
                    this.touchTimeout = setTimeout(()=>this._maybeEnableCycle(), 500 + this._config.interval))
                }
            })
        }
        _keydown(f) {
            if (/input|textarea/i.test(f.target.tagName))
                return;
            const A = N[f.key];
            A && (f.preventDefault(),
            this._slide(this._directionToOrder(A)))
        }
        _getItemIndex(f) {
            return this._getItems().indexOf(f)
        }
        _setActiveIndicatorElement(f) {
            if (!this._indicatorsElement)
                return;
            const A = te.findOne(".active", this._indicatorsElement);
            A.classList.remove(T),
            A.removeAttribute("aria-current");
            const L = te.findOne(`[data-bs-slide-to="${f}"]`, this._indicatorsElement);
            L && (L.classList.add(T),
            L.setAttribute("aria-current", "true"))
        }
        _updateInterval() {
            const f = this._activeElement || this._getActive();
            if (!f)
                return;
            const A = Number.parseInt(f.getAttribute("data-bs-interval"), 10);
            this._config.interval = A || this._config.defaultInterval
        }
        _slide(f, A=null) {
            if (this._isSliding)
                return;
            const L = this._getActive()
              , Y = f === gt
              , $ = A || tt(this._getItems(), L, Y, this._config.wrap);
            if ($ === L)
                return;
            const ee = this._getItemIndex($)
              , he = nt=>F.trigger(this._element, nt, {
                relatedTarget: $,
                direction: this._orderToDirection(f),
                from: this._getItemIndex(L),
                to: ee
            });
            if (he(Zt).defaultPrevented || !L || !$)
                return;
            const be = Boolean(this._interval);
            this.pause(),
            this._isSliding = !0,
            this._setActiveIndicatorElement(ee),
            this._activeElement = $;
            const Ve = Y ? "carousel-item-start" : "carousel-item-end"
              , Qe = Y ? "carousel-item-next" : "carousel-item-prev";
            $.classList.add(Qe),
            L.classList.add(Ve),
            $.classList.add(Ve),
            this._queueCallback(()=>{
                $.classList.remove(Ve, Qe),
                $.classList.add(T),
                L.classList.remove(T, Qe, Ve),
                this._isSliding = !1,
                he(_t)
            }
            , L, this._isAnimated()),
            be && this.cycle()
        }
        _isAnimated() {
            return this._element.classList.contains("slide")
        }
        _getActive() {
            return te.findOne(".active.carousel-item", this._element)
        }
        _getItems() {
            return te.find(".carousel-item", this._element)
        }
        _clearInterval() {
            this._interval && (clearInterval(this._interval),
            this._interval = null)
        }
        _directionToOrder(f) {
            return D() ? f === at ? st : gt : f === at ? gt : st
        }
        _orderToDirection(f) {
            return D() ? f === st ? at : $e : f === st ? $e : at
        }
        static jQueryInterface(f) {
            return this.each(function() {
                const A = U.getOrCreateInstance(this, f);
                if ("number" != typeof f) {
                    if ("string" == typeof f) {
                        if (void 0 === A[f] || f.startsWith("_") || "constructor" === f)
                            throw new TypeError(`No method named "${f}"`);
                        A[f]()
                    }
                } else
                    A.to(f)
            })
        }
    }
    F.on(document, ii, "[data-bs-slide], [data-bs-slide-to]", function(P) {
        const f = te.getElementFromSelector(this);
        if (!f || !f.classList.contains(E))
            return;
        P.preventDefault();
        const A = U.getOrCreateInstance(f)
          , L = this.getAttribute("data-bs-slide-to");
        return L ? (A.to(L),
        void A._maybeEnableCycle()) : "next" === ze.getDataAttribute(this, "slide") ? (A.next(),
        void A._maybeEnableCycle()) : (A.prev(),
        void A._maybeEnableCycle())
    }),
    F.on(window, Ht, ()=>{
        const P = te.find('[data-bs-ride="carousel"]');
        for (const f of P)
            U.getOrCreateInstance(f)
    }
    ),
    Ee(U);
    const K = ".bs.collapse"
      , J = `show${K}`
      , Q = `shown${K}`
      , le = `hide${K}`
      , se = `hidden${K}`
      , re = `click${K}.data-api`
      , ae = "show"
      , y = "collapse"
      , e = "collapsing"
      , t = `:scope .${y} .${y}`
      , i = '[data-bs-toggle="collapse"]'
      , s = {
        parent: null,
        toggle: !0
    }
      , a = {
        parent: "(null|element)",
        toggle: "boolean"
    };
    class r extends fe {
        constructor(f, A) {
            super(f, A),
            this._isTransitioning = !1,
            this._triggerArray = [];
            const L = te.find(i);
            for (const Y of L) {
                const $ = te.getSelectorFromElement(Y)
                  , ee = te.find($).filter(he=>he === this._element);
                null !== $ && ee.length && this._triggerArray.push(Y)
            }
            this._initializeChildren(),
            this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()),
            this._config.toggle && this.toggle()
        }
        static get Default() {
            return s
        }
        static get DefaultType() {
            return a
        }
        static get NAME() {
            return "collapse"
        }
        toggle() {
            this._isShown() ? this.hide() : this.show()
        }
        show() {
            if (this._isTransitioning || this._isShown())
                return;
            let f = [];
            if (this._config.parent && (f = this._getFirstLevelChildren(".collapse.show, .collapse.collapsing").filter(Y=>Y !== this._element).map(Y=>r.getOrCreateInstance(Y, {
                toggle: !1
            }))),
            f.length && f[0]._isTransitioning || F.trigger(this._element, J).defaultPrevented)
                return;
            for (const Y of f)
                Y.hide();
            const A = this._getDimension();
            this._element.classList.remove(y),
            this._element.classList.add(e),
            this._element.style[A] = 0,
            this._addAriaAndCollapsedClass(this._triggerArray, !0),
            this._isTransitioning = !0;
            const L = `scroll${A[0].toUpperCase() + A.slice(1)}`;
            this._queueCallback(()=>{
                this._isTransitioning = !1,
                this._element.classList.remove(e),
                this._element.classList.add(y, ae),
                this._element.style[A] = "",
                F.trigger(this._element, Q)
            }
            , this._element, !0),
            this._element.style[A] = `${this._element[L]}px`
        }
        hide() {
            if (this._isTransitioning || !this._isShown() || F.trigger(this._element, le).defaultPrevented)
                return;
            const f = this._getDimension();
            this._element.style[f] = `${this._element.getBoundingClientRect()[f]}px`,
            this._element.classList.add(e),
            this._element.classList.remove(y, ae);
            for (const A of this._triggerArray) {
                const L = te.getElementFromSelector(A);
                L && !this._isShown(L) && this._addAriaAndCollapsedClass([A], !1)
            }
            this._isTransitioning = !0,
            this._element.style[f] = "",
            this._queueCallback(()=>{
                this._isTransitioning = !1,
                this._element.classList.remove(e),
                this._element.classList.add(y),
                F.trigger(this._element, se)
            }
            , this._element, !0)
        }
        _isShown(f=this._element) {
            return f.classList.contains(ae)
        }
        _configAfterMerge(f) {
            return f.toggle = Boolean(f.toggle),
            f.parent = We(f.parent),
            f
        }
        _getDimension() {
            return this._element.classList.contains("collapse-horizontal") ? "width" : "height"
        }
        _initializeChildren() {
            if (!this._config.parent)
                return;
            const f = this._getFirstLevelChildren(i);
            for (const A of f) {
                const L = te.getElementFromSelector(A);
                L && this._addAriaAndCollapsedClass([A], this._isShown(L))
            }
        }
        _getFirstLevelChildren(f) {
            const A = te.find(t, this._config.parent);
            return te.find(f, this._config.parent).filter(L=>!A.includes(L))
        }
        _addAriaAndCollapsedClass(f, A) {
            if (f.length)
                for (const L of f)
                    L.classList.toggle("collapsed", !A),
                    L.setAttribute("aria-expanded", A)
        }
        static jQueryInterface(f) {
            const A = {};
            return "string" == typeof f && /show|hide/.test(f) && (A.toggle = !1),
            this.each(function() {
                const L = r.getOrCreateInstance(this, A);
                if ("string" == typeof f) {
                    if (void 0 === L[f])
                        throw new TypeError(`No method named "${f}"`);
                    L[f]()
                }
            })
        }
    }
    F.on(document, re, i, function(P) {
        ("A" === P.target.tagName || P.delegateTarget && "A" === P.delegateTarget.tagName) && P.preventDefault();
        for (const f of te.getMultipleElementsFromSelector(this))
            r.getOrCreateInstance(f, {
                toggle: !1
            }).toggle()
    }),
    Ee(r);
    const n = "dropdown"
      , o = ".bs.dropdown"
      , l = ".data-api"
      , c = "ArrowUp"
      , d = "ArrowDown"
      , g = `hide${o}`
      , p = `hidden${o}`
      , m = `show${o}`
      , x = `shown${o}`
      , v = `click${o}${l}`
      , k = `keydown${o}${l}`
      , S = `keyup${o}${l}`
      , C = "show"
      , h = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)'
      , u = `${h}.show`
      , b = ".dropdown-menu"
      , w = D() ? "top-end" : "top-start"
      , _ = D() ? "top-start" : "top-end"
      , X = D() ? "bottom-end" : "bottom-start"
      , I = D() ? "bottom-start" : "bottom-end"
      , R = D() ? "left-start" : "right-start"
      , H = D() ? "right-start" : "left-start"
      , G = {
        autoClose: !0,
        boundary: "clippingParents",
        display: "dynamic",
        offset: [0, 2],
        popperConfig: null,
        reference: "toggle"
    }
      , ie = {
        autoClose: "(boolean|string)",
        boundary: "(string|element)",
        display: "string",
        offset: "(array|string|function)",
        popperConfig: "(null|object|function)",
        reference: "(string|element|object)"
    };
    class ne extends fe {
        constructor(f, A) {
            super(f, A),
            this._popper = null,
            this._parent = this._element.parentNode,
            this._menu = te.next(this._element, b)[0] || te.prev(this._element, b)[0] || te.findOne(b, this._parent),
            this._inNavbar = this._detectNavbar()
        }
        static get Default() {
            return G
        }
        static get DefaultType() {
            return ie
        }
        static get NAME() {
            return n
        }
        toggle() {
            return this._isShown() ? this.hide() : this.show()
        }
        show() {
            if (Te(this._element) || this._isShown())
                return;
            const f = {
                relatedTarget: this._element
            };
            if (!F.trigger(this._element, m, f).defaultPrevented) {
                if (this._createPopper(),
                "ontouchstart"in document.documentElement && !this._parent.closest(".navbar-nav"))
                    for (const A of [].concat(...document.body.children))
                        F.on(A, "mouseover", Me);
                this._element.focus(),
                this._element.setAttribute("aria-expanded", !0),
                this._menu.classList.add(C),
                this._element.classList.add(C),
                F.trigger(this._element, x, f)
            }
        }
        hide() {
            !Te(this._element) && this._isShown() && this._completeHide({
                relatedTarget: this._element
            })
        }
        dispose() {
            this._popper && this._popper.destroy(),
            super.dispose()
        }
        update() {
            this._inNavbar = this._detectNavbar(),
            this._popper && this._popper.update()
        }
        _completeHide(f) {
            if (!F.trigger(this._element, g, f).defaultPrevented) {
                if ("ontouchstart"in document.documentElement)
                    for (const A of [].concat(...document.body.children))
                        F.off(A, "mouseover", Me);
                this._popper && this._popper.destroy(),
                this._menu.classList.remove(C),
                this._element.classList.remove(C),
                this._element.setAttribute("aria-expanded", "false"),
                ze.removeDataAttribute(this._menu, "popper"),
                F.trigger(this._element, p, f)
            }
        }
        _getConfig(f) {
            if ("object" == typeof (f = super._getConfig(f)).reference && !Ie(f.reference) && "function" != typeof f.reference.getBoundingClientRect)
                throw new TypeError(`${n.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
            return f
        }
        _createPopper() {
            if (void 0 === de)
                throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
            let f = this._element;
            "parent" === this._config.reference ? f = this._parent : Ie(this._config.reference) ? f = We(this._config.reference) : "object" == typeof this._config.reference && (f = this._config.reference);
            const A = this._getPopperConfig();
            this._popper = de.createPopper(f, this._menu, A)
        }
        _isShown() {
            return this._menu.classList.contains(C)
        }
        _getPlacement() {
            const f = this._parent;
            if (f.classList.contains("dropend"))
                return R;
            if (f.classList.contains("dropstart"))
                return H;
            if (f.classList.contains("dropup-center"))
                return "top";
            if (f.classList.contains("dropdown-center"))
                return "bottom";
            const A = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();
            return f.classList.contains("dropup") ? A ? _ : w : A ? I : X
        }
        _detectNavbar() {
            return null !== this._element.closest(".navbar")
        }
        _getOffset() {
            const {offset: f} = this._config;
            return "string" == typeof f ? f.split(",").map(A=>Number.parseInt(A, 10)) : "function" == typeof f ? A=>f(A, this._element) : f
        }
        _getPopperConfig() {
            const f = {
                placement: this._getPlacement(),
                modifiers: [{
                    name: "preventOverflow",
                    options: {
                        boundary: this._config.boundary
                    }
                }, {
                    name: "offset",
                    options: {
                        offset: this._getOffset()
                    }
                }]
            };
            return (this._inNavbar || "static" === this._config.display) && (ze.setDataAttribute(this._menu, "popper", "static"),
            f.modifiers = [{
                name: "applyStyles",
                enabled: !1
            }]),
            {
                ...f,
                ...ke(this._config.popperConfig, [f])
            }
        }
        _selectMenuItem({key: f, target: A}) {
            const L = te.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter(Y=>Ne(Y));
            L.length && tt(L, A, f === d, !L.includes(A)).focus()
        }
        static jQueryInterface(f) {
            return this.each(function() {
                const A = ne.getOrCreateInstance(this, f);
                if ("string" == typeof f) {
                    if (void 0 === A[f])
                        throw new TypeError(`No method named "${f}"`);
                    A[f]()
                }
            })
        }
        static clearMenus(f) {
            if (2 === f.button || "keyup" === f.type && "Tab" !== f.key)
                return;
            const A = te.find(u);
            for (const L of A) {
                const Y = ne.getInstance(L);
                if (!Y || !1 === Y._config.autoClose)
                    continue;
                const $ = f.composedPath()
                  , ee = $.includes(Y._menu);
                if ($.includes(Y._element) || "inside" === Y._config.autoClose && !ee || "outside" === Y._config.autoClose && ee || Y._menu.contains(f.target) && ("keyup" === f.type && "Tab" === f.key || /input|select|option|textarea|form/i.test(f.target.tagName)))
                    continue;
                const he = {
                    relatedTarget: Y._element
                };
                "click" === f.type && (he.clickEvent = f),
                Y._completeHide(he)
            }
        }
        static dataApiKeydownHandler(f) {
            const A = /input|textarea/i.test(f.target.tagName)
              , L = "Escape" === f.key
              , Y = [c, d].includes(f.key);
            if (!Y && !L || A && !L)
                return;
            f.preventDefault();
            const $ = this.matches(h) ? this : te.prev(this, h)[0] || te.next(this, h)[0] || te.findOne(h, f.delegateTarget.parentNode)
              , ee = ne.getOrCreateInstance($);
            if (Y)
                return f.stopPropagation(),
                ee.show(),
                void ee._selectMenuItem(f);
            ee._isShown() && (f.stopPropagation(),
            ee.hide(),
            $.focus())
        }
    }
    F.on(document, k, h, ne.dataApiKeydownHandler),
    F.on(document, k, b, ne.dataApiKeydownHandler),
    F.on(document, v, ne.clearMenus),
    F.on(document, S, ne.clearMenus),
    F.on(document, v, h, function(P) {
        P.preventDefault(),
        ne.getOrCreateInstance(this).toggle()
    }),
    Ee(ne);
    const oe = "backdrop"
      , Le = `mousedown.bs.${oe}`
      , De = {
        className: "modal-backdrop",
        clickCallback: null,
        isAnimated: !1,
        isVisible: !0,
        rootElement: "body"
    }
      , qe = {
        className: "string",
        clickCallback: "(function|null)",
        isAnimated: "boolean",
        isVisible: "boolean",
        rootElement: "(element|string)"
    };
    class et extends Re {
        constructor(f) {
            super(),
            this._config = this._getConfig(f),
            this._isAppended = !1,
            this._element = null
        }
        static get Default() {
            return De
        }
        static get DefaultType() {
            return qe
        }
        static get NAME() {
            return oe
        }
        show(f) {
            if (!this._config.isVisible)
                return void ke(f);
            this._append();
            this._getElement().classList.add("show"),
            this._emulateAnimation(()=>{
                ke(f)
            }
            )
        }
        hide(f) {
            this._config.isVisible ? (this._getElement().classList.remove("show"),
            this._emulateAnimation(()=>{
                this.dispose(),
                ke(f)
            }
            )) : ke(f)
        }
        dispose() {
            this._isAppended && (F.off(this._element, Le),
            this._element.remove(),
            this._isAppended = !1)
        }
        _getElement() {
            if (!this._element) {
                const f = document.createElement("div");
                f.className = this._config.className,
                this._config.isAnimated && f.classList.add("fade"),
                this._element = f
            }
            return this._element
        }
        _configAfterMerge(f) {
            return f.rootElement = We(f.rootElement),
            f
        }
        _append() {
            if (this._isAppended)
                return;
            const f = this._getElement();
            this._config.rootElement.append(f),
            F.on(f, Le, ()=>{
                ke(this._config.clickCallback)
            }
            ),
            this._isAppended = !0
        }
        _emulateAnimation(f) {
            xe(f, this._getElement(), this._config.isAnimated)
        }
    }
    const Lt = ".bs.focustrap"
      , Ze = `focusin${Lt}`
      , ft = `keydown.tab${Lt}`
      , mt = "backward"
      , Pe = {
        autofocus: !0,
        trapElement: null
    }
      , we = {
        autofocus: "boolean",
        trapElement: "element"
    };
    class Pt extends Re {
        constructor(f) {
            super(),
            this._config = this._getConfig(f),
            this._isActive = !1,
            this._lastTabNavDirection = null
        }
        static get Default() {
            return Pe
        }
        static get DefaultType() {
            return we
        }
        static get NAME() {
            return "focustrap"
        }
        activate() {
            this._isActive || (this._config.autofocus && this._config.trapElement.focus(),
            F.off(document, Lt),
            F.on(document, Ze, f=>this._handleFocusin(f)),
            F.on(document, ft, f=>this._handleKeydown(f)),
            this._isActive = !0)
        }
        deactivate() {
            this._isActive && (this._isActive = !1,
            F.off(document, Lt))
        }
        _handleFocusin(f) {
            const {trapElement: A} = this._config;
            if (f.target === document || f.target === A || A.contains(f.target))
                return;
            const L = te.focusableChildren(A);
            0 === L.length ? A.focus() : this._lastTabNavDirection === mt ? L[L.length - 1].focus() : L[0].focus()
        }
        _handleKeydown(f) {
            "Tab" === f.key && (this._lastTabNavDirection = f.shiftKey ? mt : "forward")
        }
    }
    const si = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top"
      , ai = ".sticky-top"
      , Rt = "padding-right"
      , ci = "margin-right";
    class ni {
        constructor() {
            this._element = document.body
        }
        getWidth() {
            const f = document.documentElement.clientWidth;
            return Math.abs(window.innerWidth - f)
        }
        hide() {
            const f = this.getWidth();
            this._disableOverFlow(),
            this._setElementAttributes(this._element, Rt, A=>A + f),
            this._setElementAttributes(si, Rt, A=>A + f),
            this._setElementAttributes(ai, ci, A=>A - f)
        }
        reset() {
            this._resetElementAttributes(this._element, "overflow"),
            this._resetElementAttributes(this._element, Rt),
            this._resetElementAttributes(si, Rt),
            this._resetElementAttributes(ai, ci)
        }
        isOverflowing() {
            return this.getWidth() > 0
        }
        _disableOverFlow() {
            this._saveInitialAttribute(this._element, "overflow"),
            this._element.style.overflow = "hidden"
        }
        _setElementAttributes(f, A, L) {
            const Y = this.getWidth();
            this._applyManipulationCallback(f, $=>{
                if ($ !== this._element && window.innerWidth > $.clientWidth + Y)
                    return;
                this._saveInitialAttribute($, A);
                const ee = window.getComputedStyle($).getPropertyValue(A);
                $.style.setProperty(A, `${L(Number.parseFloat(ee))}px`)
            }
            )
        }
        _saveInitialAttribute(f, A) {
            const L = f.style.getPropertyValue(A);
            L && ze.setDataAttribute(f, A, L)
        }
        _resetElementAttributes(f, A) {
            this._applyManipulationCallback(f, L=>{
                const Y = ze.getDataAttribute(L, A);
                null !== Y ? (ze.removeDataAttribute(L, A),
                L.style.setProperty(A, Y)) : L.style.removeProperty(A)
            }
            )
        }
        _applyManipulationCallback(f, A) {
            if (Ie(f))
                A(f);
            else
                for (const L of te.find(f, this._element))
                    A(L)
        }
    }
    const Ye = ".bs.modal"
      , di = `hide${Ye}`
      , qi = `hidePrevented${Ye}`
      , _i = `hidden${Ye}`
      , Li = `show${Ye}`
      , Zi = `shown${Ye}`
      , Qi = `resize${Ye}`
      , Ki = `click.dismiss${Ye}`
      , Ji = `mousedown.dismiss${Ye}`
      , es = `keydown.dismiss${Ye}`
      , ts = `click${Ye}.data-api`
      , Pi = "modal-open"
      , mi = "modal-static"
      , is = {
        backdrop: !0,
        focus: !0,
        keyboard: !0
    }
      , ss = {
        backdrop: "(boolean|string)",
        focus: "boolean",
        keyboard: "boolean"
    };
    class Wt extends fe {
        constructor(f, A) {
            super(f, A),
            this._dialog = te.findOne(".modal-dialog", this._element),
            this._backdrop = this._initializeBackDrop(),
            this._focustrap = this._initializeFocusTrap(),
            this._isShown = !1,
            this._isTransitioning = !1,
            this._scrollBar = new ni,
            this._addEventListeners()
        }
        static get Default() {
            return is
        }
        static get DefaultType() {
            return ss
        }
        static get NAME() {
            return "modal"
        }
        toggle(f) {
            return this._isShown ? this.hide() : this.show(f)
        }
        show(f) {
            this._isShown || this._isTransitioning || F.trigger(this._element, Li, {
                relatedTarget: f
            }).defaultPrevented || (this._isShown = !0,
            this._isTransitioning = !0,
            this._scrollBar.hide(),
            document.body.classList.add(Pi),
            this._adjustDialog(),
            this._backdrop.show(()=>this._showElement(f)))
        }
        hide() {
            this._isShown && !this._isTransitioning && (F.trigger(this._element, di).defaultPrevented || (this._isShown = !1,
            this._isTransitioning = !0,
            this._focustrap.deactivate(),
            this._element.classList.remove("show"),
            this._queueCallback(()=>this._hideModal(), this._element, this._isAnimated())))
        }
        dispose() {
            F.off(window, Ye),
            F.off(this._dialog, Ye),
            this._backdrop.dispose(),
            this._focustrap.deactivate(),
            super.dispose()
        }
        handleUpdate() {
            this._adjustDialog()
        }
        _initializeBackDrop() {
            return new et({
                isVisible: Boolean(this._config.backdrop),
                isAnimated: this._isAnimated()
            })
        }
        _initializeFocusTrap() {
            return new Pt({
                trapElement: this._element
            })
        }
        _showElement(f) {
            document.body.contains(this._element) || document.body.append(this._element),
            this._element.style.display = "block",
            this._element.removeAttribute("aria-hidden"),
            this._element.setAttribute("aria-modal", !0),
            this._element.setAttribute("role", "dialog"),
            this._element.scrollTop = 0;
            const A = te.findOne(".modal-body", this._dialog);
            A && (A.scrollTop = 0),
            this._element.classList.add("show"),
            this._queueCallback(()=>{
                this._config.focus && this._focustrap.activate(),
                this._isTransitioning = !1,
                F.trigger(this._element, Zi, {
                    relatedTarget: f
                })
            }
            , this._dialog, this._isAnimated())
        }
        _addEventListeners() {
            F.on(this._element, es, f=>{
                "Escape" === f.key && (this._config.keyboard ? this.hide() : this._triggerBackdropTransition())
            }
            ),
            F.on(window, Qi, ()=>{
                this._isShown && !this._isTransitioning && this._adjustDialog()
            }
            ),
            F.on(this._element, Ji, f=>{
                F.one(this._element, Ki, A=>{
                    this._element === f.target && this._element === A.target && ("static" !== this._config.backdrop ? this._config.backdrop && this.hide() : this._triggerBackdropTransition())
                }
                )
            }
            )
        }
        _hideModal() {
            this._element.style.display = "none",
            this._element.setAttribute("aria-hidden", !0),
            this._element.removeAttribute("aria-modal"),
            this._element.removeAttribute("role"),
            this._isTransitioning = !1,
            this._backdrop.hide(()=>{
                document.body.classList.remove(Pi),
                this._resetAdjustments(),
                this._scrollBar.reset(),
                F.trigger(this._element, _i)
            }
            )
        }
        _isAnimated() {
            return this._element.classList.contains("fade")
        }
        _triggerBackdropTransition() {
            if (F.trigger(this._element, qi).defaultPrevented)
                return;
            const f = this._element.scrollHeight > document.documentElement.clientHeight
              , A = this._element.style.overflowY;
            "hidden" === A || this._element.classList.contains(mi) || (f || (this._element.style.overflowY = "hidden"),
            this._element.classList.add(mi),
            this._queueCallback(()=>{
                this._element.classList.remove(mi),
                this._queueCallback(()=>{
                    this._element.style.overflowY = A
                }
                , this._dialog)
            }
            , this._dialog),
            this._element.focus())
        }
        _adjustDialog() {
            const f = this._element.scrollHeight > document.documentElement.clientHeight
              , A = this._scrollBar.getWidth()
              , L = A > 0;
            if (L && !f) {
                const Y = D() ? "paddingLeft" : "paddingRight";
                this._element.style[Y] = `${A}px`
            }
            if (!L && f) {
                const Y = D() ? "paddingRight" : "paddingLeft";
                this._element.style[Y] = `${A}px`
            }
        }
        _resetAdjustments() {
            this._element.style.paddingLeft = "",
            this._element.style.paddingRight = ""
        }
        static jQueryInterface(f, A) {
            return this.each(function() {
                const L = Wt.getOrCreateInstance(this, f);
                if ("string" == typeof f) {
                    if (void 0 === L[f])
                        throw new TypeError(`No method named "${f}"`);
                    L[f](A)
                }
            })
        }
    }
    F.on(document, ts, '[data-bs-toggle="modal"]', function(P) {
        const f = te.getElementFromSelector(this);
        ["A", "AREA"].includes(this.tagName) && P.preventDefault(),
        F.one(f, Li, L=>{
            L.defaultPrevented || F.one(f, _i, ()=>{
                Ne(this) && this.focus()
            }
            )
        }
        );
        const A = te.findOne(".modal.show");
        A && Wt.getInstance(A).hide(),
        Wt.getOrCreateInstance(f).toggle(this)
    }),
    Be(Wt),
    Ee(Wt);
    const bt = ".bs.offcanvas"
      , Ei = ".data-api"
      , as = `load${bt}${Ei}`
      , Mi = "showing"
      , Xi = ".offcanvas.show"
      , ns = `show${bt}`
      , rs = `shown${bt}`
      , os = `hide${bt}`
      , Oi = `hidePrevented${bt}`
      , Di = `hidden${bt}`
      , ls = `resize${bt}`
      , hs = `click${bt}${Ei}`
      , cs = `keydown.dismiss${bt}`
      , ds = {
        backdrop: !0,
        keyboard: !0,
        scroll: !1
    }
      , us = {
        backdrop: "(boolean|string)",
        keyboard: "boolean",
        scroll: "boolean"
    };
    class vt extends fe {
        constructor(f, A) {
            super(f, A),
            this._isShown = !1,
            this._backdrop = this._initializeBackDrop(),
            this._focustrap = this._initializeFocusTrap(),
            this._addEventListeners()
        }
        static get Default() {
            return ds
        }
        static get DefaultType() {
            return us
        }
        static get NAME() {
            return "offcanvas"
        }
        toggle(f) {
            return this._isShown ? this.hide() : this.show(f)
        }
        show(f) {
            this._isShown || F.trigger(this._element, ns, {
                relatedTarget: f
            }).defaultPrevented || (this._isShown = !0,
            this._backdrop.show(),
            this._config.scroll || (new ni).hide(),
            this._element.setAttribute("aria-modal", !0),
            this._element.setAttribute("role", "dialog"),
            this._element.classList.add(Mi),
            this._queueCallback(()=>{
                this._config.scroll && !this._config.backdrop || this._focustrap.activate(),
                this._element.classList.add("show"),
                this._element.classList.remove(Mi),
                F.trigger(this._element, rs, {
                    relatedTarget: f
                })
            }
            , this._element, !0))
        }
        hide() {
            this._isShown && (F.trigger(this._element, os).defaultPrevented || (this._focustrap.deactivate(),
            this._element.blur(),
            this._isShown = !1,
            this._element.classList.add("hiding"),
            this._backdrop.hide(),
            this._queueCallback(()=>{
                this._element.classList.remove("show", "hiding"),
                this._element.removeAttribute("aria-modal"),
                this._element.removeAttribute("role"),
                this._config.scroll || (new ni).reset(),
                F.trigger(this._element, Di)
            }
            , this._element, !0)))
        }
        dispose() {
            this._backdrop.dispose(),
            this._focustrap.deactivate(),
            super.dispose()
        }
        _initializeBackDrop() {
            const f = Boolean(this._config.backdrop);
            return new et({
                className: "offcanvas-backdrop",
                isVisible: f,
                isAnimated: !0,
                rootElement: this._element.parentNode,
                clickCallback: f ? ()=>{
                    "static" !== this._config.backdrop ? this.hide() : F.trigger(this._element, Oi)
                }
                : null
            })
        }
        _initializeFocusTrap() {
            return new Pt({
                trapElement: this._element
            })
        }
        _addEventListeners() {
            F.on(this._element, cs, f=>{
                "Escape" === f.key && (this._config.keyboard ? this.hide() : F.trigger(this._element, Oi))
            }
            )
        }
        static jQueryInterface(f) {
            return this.each(function() {
                const A = vt.getOrCreateInstance(this, f);
                if ("string" == typeof f) {
                    if (void 0 === A[f] || f.startsWith("_") || "constructor" === f)
                        throw new TypeError(`No method named "${f}"`);
                    A[f](this)
                }
            })
        }
    }
    F.on(document, hs, '[data-bs-toggle="offcanvas"]', function(P) {
        const f = te.getElementFromSelector(this);
        if (["A", "AREA"].includes(this.tagName) && P.preventDefault(),
        Te(this))
            return;
        F.one(f, Di, ()=>{
            Ne(this) && this.focus()
        }
        );
        const A = te.findOne(Xi);
        A && A !== f && vt.getInstance(A).hide(),
        vt.getOrCreateInstance(f).toggle(this)
    }),
    F.on(window, as, ()=>{
        for (const P of te.find(Xi))
            vt.getOrCreateInstance(P).show()
    }
    ),
    F.on(window, ls, ()=>{
        for (const P of te.find("[aria-modal][class*=show][class*=offcanvas-]"))
            "fixed" !== getComputedStyle(P).position && vt.getOrCreateInstance(P).hide()
    }
    ),
    Be(vt),
    Ee(vt);
    const Yi = {
        "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
        a: ["target", "href", "title", "rel"],
        area: [],
        b: [],
        br: [],
        col: [],
        code: [],
        dd: [],
        div: [],
        dl: [],
        dt: [],
        em: [],
        hr: [],
        h1: [],
        h2: [],
        h3: [],
        h4: [],
        h5: [],
        h6: [],
        i: [],
        img: ["src", "srcset", "alt", "title", "width", "height"],
        li: [],
        ol: [],
        p: [],
        pre: [],
        s: [],
        small: [],
        span: [],
        sub: [],
        sup: [],
        strong: [],
        u: [],
        ul: []
    }
      , gs = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"])
      , fs = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i
      , ps = (P,f)=>{
        const A = P.nodeName.toLowerCase();
        return f.includes(A) ? !gs.has(A) || Boolean(fs.test(P.nodeValue)) : f.filter(L=>L instanceof RegExp).some(L=>L.test(A))
    }
      , xs = {
        allowList: Yi,
        content: {},
        extraClass: "",
        html: !1,
        sanitize: !0,
        sanitizeFn: null,
        template: "<div></div>"
    }
      , ms = {
        allowList: "object",
        content: "object",
        extraClass: "(string|function)",
        html: "boolean",
        sanitize: "boolean",
        sanitizeFn: "(null|function)",
        template: "string"
    }
      , bs = {
        entry: "(string|element|function|null)",
        selector: "(string|element)"
    };
    class vs extends Re {
        constructor(f) {
            super(),
            this._config = this._getConfig(f)
        }
        static get Default() {
            return xs
        }
        static get DefaultType() {
            return ms
        }
        static get NAME() {
            return "TemplateFactory"
        }
        getContent() {
            return Object.values(this._config.content).map(f=>this._resolvePossibleFunction(f)).filter(Boolean)
        }
        hasContent() {
            return this.getContent().length > 0
        }
        changeContent(f) {
            return this._checkContent(f),
            this._config.content = {
                ...this._config.content,
                ...f
            },
            this
        }
        toHtml() {
            const f = document.createElement("div");
            f.innerHTML = this._maybeSanitize(this._config.template);
            for (const [Y,$] of Object.entries(this._config.content))
                this._setContent(f, $, Y);
            const A = f.children[0]
              , L = this._resolvePossibleFunction(this._config.extraClass);
            return L && A.classList.add(...L.split(" ")),
            A
        }
        _typeCheckConfig(f) {
            super._typeCheckConfig(f),
            this._checkContent(f.content)
        }
        _checkContent(f) {
            for (const [A,L] of Object.entries(f))
                super._typeCheckConfig({
                    selector: A,
                    entry: L
                }, bs)
        }
        _setContent(f, A, L) {
            const Y = te.findOne(L, f);
            Y && ((A = this._resolvePossibleFunction(A)) ? Ie(A) ? this._putElementInTemplate(We(A), Y) : this._config.html ? Y.innerHTML = this._maybeSanitize(A) : Y.textContent = A : Y.remove())
        }
        _maybeSanitize(f) {
            return this._config.sanitize ? function(A, L, Y) {
                if (!A.length)
                    return A;
                if (Y && "function" == typeof Y)
                    return Y(A);
                const $ = (new window.DOMParser).parseFromString(A, "text/html")
                  , ee = [].concat(...$.body.querySelectorAll("*"));
                for (const he of ee) {
                    const be = he.nodeName.toLowerCase();
                    if (!Object.keys(L).includes(be)) {
                        he.remove();
                        continue
                    }
                    const Ve = [].concat(...he.attributes)
                      , Qe = [].concat(L["*"] || [], L[be] || []);
                    for (const nt of Ve)
                        ps(nt, Qe) || he.removeAttribute(nt.nodeName)
                }
                return $.body.innerHTML
            }(f, this._config.allowList, this._config.sanitizeFn) : f
        }
        _resolvePossibleFunction(f) {
            return ke(f, [this])
        }
        _putElementInTemplate(f, A) {
            if (this._config.html)
                return A.innerHTML = "",
                void A.append(f);
            A.textContent = f.textContent
        }
    }
    const ys = new Set(["sanitize", "allowList", "sanitizeFn"])
      , bi = "fade"
      , ui = "show"
      , Ni = "hide.bs.modal"
      , ri = "hover"
      , vi = "focus"
      , ws = {
        AUTO: "auto",
        TOP: "top",
        RIGHT: D() ? "left" : "right",
        BOTTOM: "bottom",
        LEFT: D() ? "right" : "left"
    }
      , ks = {
        allowList: Yi,
        animation: !0,
        boundary: "clippingParents",
        container: !1,
        customClass: "",
        delay: 0,
        fallbackPlacements: ["top", "right", "bottom", "left"],
        html: !1,
        offset: [0, 6],
        placement: "top",
        popperConfig: null,
        sanitize: !0,
        sanitizeFn: null,
        selector: !1,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        title: "",
        trigger: "hover focus"
    }
      , As = {
        allowList: "object",
        animation: "boolean",
        boundary: "(string|element)",
        container: "(string|element|boolean)",
        customClass: "(string|function)",
        delay: "(number|object)",
        fallbackPlacements: "array",
        html: "boolean",
        offset: "(array|string|function)",
        placement: "(string|function)",
        popperConfig: "(null|object|function)",
        sanitize: "boolean",
        sanitizeFn: "(null|function)",
        selector: "(string|boolean)",
        template: "string",
        title: "(string|element|function)",
        trigger: "string"
    };
    class Bt extends fe {
        constructor(f, A) {
            if (void 0 === de)
                throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
            super(f, A),
            this._isEnabled = !0,
            this._timeout = 0,
            this._isHovered = null,
            this._activeTrigger = {},
            this._popper = null,
            this._templateFactory = null,
            this._newContent = null,
            this.tip = null,
            this._setListeners(),
            this._config.selector || this._fixTitle()
        }
        static get Default() {
            return ks
        }
        static get DefaultType() {
            return As
        }
        static get NAME() {
            return "tooltip"
        }
        enable() {
            this._isEnabled = !0
        }
        disable() {
            this._isEnabled = !1
        }
        toggleEnabled() {
            this._isEnabled = !this._isEnabled
        }
        toggle() {
            this._isEnabled && (this._activeTrigger.click = !this._activeTrigger.click,
            this._isShown() ? this._leave() : this._enter())
        }
        dispose() {
            clearTimeout(this._timeout),
            F.off(this._element.closest(".modal"), Ni, this._hideModalHandler),
            this._element.getAttribute("data-bs-original-title") && this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title")),
            this._disposePopper(),
            super.dispose()
        }
        show() {
            if ("none" === this._element.style.display)
                throw new Error("Please use show on visible elements");
            if (!this._isWithContent() || !this._isEnabled)
                return;
            const f = F.trigger(this._element, this.constructor.eventName("show"))
              , A = (pe(this._element) || this._element.ownerDocument.documentElement).contains(this._element);
            if (f.defaultPrevented || !A)
                return;
            this._disposePopper();
            const L = this._getTipElement();
            this._element.setAttribute("aria-describedby", L.getAttribute("id"));
            const {container: Y} = this._config;
            if (this._element.ownerDocument.documentElement.contains(this.tip) || (Y.append(L),
            F.trigger(this._element, this.constructor.eventName("inserted"))),
            this._popper = this._createPopper(L),
            L.classList.add(ui),
            "ontouchstart"in document.documentElement)
                for (const $ of [].concat(...document.body.children))
                    F.on($, "mouseover", Me);
            this._queueCallback(()=>{
                F.trigger(this._element, this.constructor.eventName("shown")),
                !1 === this._isHovered && this._leave(),
                this._isHovered = !1
            }
            , this.tip, this._isAnimated())
        }
        hide() {
            if (this._isShown() && !F.trigger(this._element, this.constructor.eventName("hide")).defaultPrevented) {
                if (this._getTipElement().classList.remove(ui),
                "ontouchstart"in document.documentElement)
                    for (const f of [].concat(...document.body.children))
                        F.off(f, "mouseover", Me);
                this._activeTrigger.click = !1,
                this._activeTrigger[vi] = !1,
                this._activeTrigger[ri] = !1,
                this._isHovered = null,
                this._queueCallback(()=>{
                    this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(),
                    this._element.removeAttribute("aria-describedby"),
                    F.trigger(this._element, this.constructor.eventName("hidden")))
                }
                , this.tip, this._isAnimated())
            }
        }
        update() {
            this._popper && this._popper.update()
        }
        _isWithContent() {
            return Boolean(this._getTitle())
        }
        _getTipElement() {
            return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())),
            this.tip
        }
        _createTipElement(f) {
            const A = this._getTemplateFactory(f).toHtml();
            if (!A)
                return null;
            A.classList.remove(bi, ui),
            A.classList.add(`bs-${this.constructor.NAME}-auto`);
            const L = (Y=>{
                do {
                    Y += Math.floor(1e6 * Math.random())
                } while (document.getElementById(Y));
                return Y
            }
            )(this.constructor.NAME).toString();
            return A.setAttribute("id", L),
            this._isAnimated() && A.classList.add(bi),
            A
        }
        setContent(f) {
            this._newContent = f,
            this._isShown() && (this._disposePopper(),
            this.show())
        }
        _getTemplateFactory(f) {
            return this._templateFactory ? this._templateFactory.changeContent(f) : this._templateFactory = new vs({
                ...this._config,
                content: f,
                extraClass: this._resolvePossibleFunction(this._config.customClass)
            }),
            this._templateFactory
        }
        _getContentForTemplate() {
            return {
                ".tooltip-inner": this._getTitle()
            }
        }
        _getTitle() {
            return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title")
        }
        _initializeOnDelegatedTarget(f) {
            return this.constructor.getOrCreateInstance(f.delegateTarget, this._getDelegateConfig())
        }
        _isAnimated() {
            return this._config.animation || this.tip && this.tip.classList.contains(bi)
        }
        _isShown() {
            return this.tip && this.tip.classList.contains(ui)
        }
        _createPopper(f) {
            const A = ke(this._config.placement, [this, f, this._element])
              , L = ws[A.toUpperCase()];
            return de.createPopper(this._element, f, this._getPopperConfig(L))
        }
        _getOffset() {
            const {offset: f} = this._config;
            return "string" == typeof f ? f.split(",").map(A=>Number.parseInt(A, 10)) : "function" == typeof f ? A=>f(A, this._element) : f
        }
        _resolvePossibleFunction(f) {
            return ke(f, [this._element])
        }
        _getPopperConfig(f) {
            const A = {
                placement: f,
                modifiers: [{
                    name: "flip",
                    options: {
                        fallbackPlacements: this._config.fallbackPlacements
                    }
                }, {
                    name: "offset",
                    options: {
                        offset: this._getOffset()
                    }
                }, {
                    name: "preventOverflow",
                    options: {
                        boundary: this._config.boundary
                    }
                }, {
                    name: "arrow",
                    options: {
                        element: `.${this.constructor.NAME}-arrow`
                    }
                }, {
                    name: "preSetPlacement",
                    enabled: !0,
                    phase: "beforeMain",
                    fn: L=>{
                        this._getTipElement().setAttribute("data-popper-placement", L.state.placement)
                    }
                }]
            };
            return {
                ...A,
                ...ke(this._config.popperConfig, [A])
            }
        }
        _setListeners() {
            const f = this._config.trigger.split(" ");
            for (const A of f)
                if ("click" === A)
                    F.on(this._element, this.constructor.eventName("click"), this._config.selector, L=>{
                        this._initializeOnDelegatedTarget(L).toggle()
                    }
                    );
                else if ("manual" !== A) {
                    const L = this.constructor.eventName(A === ri ? "mouseenter" : "focusin")
                      , Y = this.constructor.eventName(A === ri ? "mouseleave" : "focusout");
                    F.on(this._element, L, this._config.selector, $=>{
                        const ee = this._initializeOnDelegatedTarget($);
                        ee._activeTrigger["focusin" === $.type ? vi : ri] = !0,
                        ee._enter()
                    }
                    ),
                    F.on(this._element, Y, this._config.selector, $=>{
                        const ee = this._initializeOnDelegatedTarget($);
                        ee._activeTrigger["focusout" === $.type ? vi : ri] = ee._element.contains($.relatedTarget),
                        ee._leave()
                    }
                    )
                }
            this._hideModalHandler = ()=>{
                this._element && this.hide()
            }
            ,
            F.on(this._element.closest(".modal"), Ni, this._hideModalHandler)
        }
        _fixTitle() {
            const f = this._element.getAttribute("title");
            f && (this._element.getAttribute("aria-label") || this._element.textContent.trim() || this._element.setAttribute("aria-label", f),
            this._element.setAttribute("data-bs-original-title", f),
            this._element.removeAttribute("title"))
        }
        _enter() {
            this._isShown() || this._isHovered ? this._isHovered = !0 : (this._isHovered = !0,
            this._setTimeout(()=>{
                this._isHovered && this.show()
            }
            , this._config.delay.show))
        }
        _leave() {
            this._isWithActiveTrigger() || (this._isHovered = !1,
            this._setTimeout(()=>{
                this._isHovered || this.hide()
            }
            , this._config.delay.hide))
        }
        _setTimeout(f, A) {
            clearTimeout(this._timeout),
            this._timeout = setTimeout(f, A)
        }
        _isWithActiveTrigger() {
            return Object.values(this._activeTrigger).includes(!0)
        }
        _getConfig(f) {
            const A = ze.getDataAttributes(this._element);
            for (const L of Object.keys(A))
                ys.has(L) && delete A[L];
            return f = {
                ...A,
                ..."object" == typeof f && f ? f : {}
            },
            f = this._mergeConfigObj(f),
            f = this._configAfterMerge(f),
            this._typeCheckConfig(f),
            f
        }
        _configAfterMerge(f) {
            return f.container = !1 === f.container ? document.body : We(f.container),
            "number" == typeof f.delay && (f.delay = {
                show: f.delay,
                hide: f.delay
            }),
            "number" == typeof f.title && (f.title = f.title.toString()),
            "number" == typeof f.content && (f.content = f.content.toString()),
            f
        }
        _getDelegateConfig() {
            const f = {};
            for (const [A,L] of Object.entries(this._config))
                this.constructor.Default[A] !== L && (f[A] = L);
            return f.selector = !1,
            f.trigger = "manual",
            f
        }
        _disposePopper() {
            this._popper && (this._popper.destroy(),
            this._popper = null),
            this.tip && (this.tip.remove(),
            this.tip = null)
        }
        static jQueryInterface(f) {
            return this.each(function() {
                const A = Bt.getOrCreateInstance(this, f);
                if ("string" == typeof f) {
                    if (void 0 === A[f])
                        throw new TypeError(`No method named "${f}"`);
                    A[f]()
                }
            })
        }
    }
    Ee(Bt);
    const Ss = {
        ...Bt.Default,
        content: "",
        offset: [0, 8],
        placement: "right",
        template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
        trigger: "click"
    }
      , Cs = {
        ...Bt.DefaultType,
        content: "(null|string|element|function)"
    };
    class gi extends Bt {
        static get Default() {
            return Ss
        }
        static get DefaultType() {
            return Cs
        }
        static get NAME() {
            return "popover"
        }
        _isWithContent() {
            return this._getTitle() || this._getContent()
        }
        _getContentForTemplate() {
            return {
                ".popover-header": this._getTitle(),
                ".popover-body": this._getContent()
            }
        }
        _getContent() {
            return this._resolvePossibleFunction(this._config.content)
        }
        static jQueryInterface(f) {
            return this.each(function() {
                const A = gi.getOrCreateInstance(this, f);
                if ("string" == typeof f) {
                    if (void 0 === A[f])
                        throw new TypeError(`No method named "${f}"`);
                    A[f]()
                }
            })
        }
    }
    Ee(gi);
    const yi = ".bs.scrollspy"
      , _s = `activate${yi}`
      , Hi = `click${yi}`
      , Ls = `load${yi}.data-api`
      , Jt = "active"
      , wi = "[href]"
      , Ri = ".nav-link"
      , Ps = `${Ri}, .nav-item > ${Ri}, .list-group-item`
      , Ts = {
        offset: null,
        rootMargin: "0px 0px -25%",
        smoothScroll: !1,
        target: null,
        threshold: [.1, .5, 1]
    }
      , Es = {
        offset: "(number|null)",
        rootMargin: "string",
        smoothScroll: "boolean",
        target: "element",
        threshold: "array"
    };
    class oi extends fe {
        constructor(f, A) {
            super(f, A),
            this._targetLinks = new Map,
            this._observableSections = new Map,
            this._rootElement = "visible" === getComputedStyle(this._element).overflowY ? null : this._element,
            this._activeTarget = null,
            this._observer = null,
            this._previousScrollData = {
                visibleEntryTop: 0,
                parentScrollTop: 0
            },
            this.refresh()
        }
        static get Default() {
            return Ts
        }
        static get DefaultType() {
            return Es
        }
        static get NAME() {
            return "scrollspy"
        }
        refresh() {
            this._initializeTargetsAndObservables(),
            this._maybeEnableSmoothScroll(),
            this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver();
            for (const f of this._observableSections.values())
                this._observer.observe(f)
        }
        dispose() {
            this._observer.disconnect(),
            super.dispose()
        }
        _configAfterMerge(f) {
            return f.target = We(f.target) || document.body,
            f.rootMargin = f.offset ? `${f.offset}px 0px -30%` : f.rootMargin,
            "string" == typeof f.threshold && (f.threshold = f.threshold.split(",").map(A=>Number.parseFloat(A))),
            f
        }
        _maybeEnableSmoothScroll() {
            this._config.smoothScroll && (F.off(this._config.target, Hi),
            F.on(this._config.target, Hi, wi, f=>{
                const A = this._observableSections.get(f.target.hash);
                if (A) {
                    f.preventDefault();
                    const L = this._rootElement || window
                      , Y = A.offsetTop - this._element.offsetTop;
                    if (L.scrollTo)
                        return void L.scrollTo({
                            top: Y,
                            behavior: "smooth"
                        });
                    L.scrollTop = Y
                }
            }
            ))
        }
        _getNewObserver() {
            return new IntersectionObserver(A=>this._observerCallback(A),{
                root: this._rootElement,
                threshold: this._config.threshold,
                rootMargin: this._config.rootMargin
            })
        }
        _observerCallback(f) {
            const A = ee=>this._targetLinks.get(`#${ee.target.id}`)
              , L = ee=>{
                this._previousScrollData.visibleEntryTop = ee.target.offsetTop,
                this._process(A(ee))
            }
              , Y = (this._rootElement || document.documentElement).scrollTop
              , $ = Y >= this._previousScrollData.parentScrollTop;
            this._previousScrollData.parentScrollTop = Y;
            for (const ee of f) {
                if (!ee.isIntersecting) {
                    this._activeTarget = null,
                    this._clearActiveClass(A(ee));
                    continue
                }
                const he = ee.target.offsetTop >= this._previousScrollData.visibleEntryTop;
                if ($ && he) {
                    if (L(ee),
                    !Y)
                        return
                } else
                    $ || he || L(ee)
            }
        }
        _initializeTargetsAndObservables() {
            this._targetLinks = new Map,
            this._observableSections = new Map;
            const f = te.find(wi, this._config.target);
            for (const A of f) {
                if (!A.hash || Te(A))
                    continue;
                const L = te.findOne(decodeURI(A.hash), this._element);
                Ne(L) && (this._targetLinks.set(decodeURI(A.hash), A),
                this._observableSections.set(A.hash, L))
            }
        }
        _process(f) {
            this._activeTarget !== f && (this._clearActiveClass(this._config.target),
            this._activeTarget = f,
            f.classList.add(Jt),
            this._activateParents(f),
            F.trigger(this._element, _s, {
                relatedTarget: f
            }))
        }
        _activateParents(f) {
            if (f.classList.contains("dropdown-item"))
                te.findOne(".dropdown-toggle", f.closest(".dropdown")).classList.add(Jt);
            else
                for (const A of te.parents(f, ".nav, .list-group"))
                    for (const L of te.prev(A, Ps))
                        L.classList.add(Jt)
        }
        _clearActiveClass(f) {
            f.classList.remove(Jt);
            const A = te.find(`${wi}.${Jt}`, f);
            for (const L of A)
                L.classList.remove(Jt)
        }
        static jQueryInterface(f) {
            return this.each(function() {
                const A = oi.getOrCreateInstance(this, f);
                if ("string" == typeof f) {
                    if (void 0 === A[f] || f.startsWith("_") || "constructor" === f)
                        throw new TypeError(`No method named "${f}"`);
                    A[f]()
                }
            })
        }
    }
    F.on(window, Ls, ()=>{
        for (const P of te.find('[data-bs-spy="scroll"]'))
            oi.getOrCreateInstance(P)
    }
    ),
    Ee(oi);
    const Vt = ".bs.tab"
      , Is = `hide${Vt}`
      , Ms = `hidden${Vt}`
      , zs = `show${Vt}`
      , Xs = `shown${Vt}`
      , Os = `click${Vt}`
      , Ds = `keydown${Vt}`
      , Ys = `load${Vt}`
      , Fs = "ArrowLeft"
      , Wi = "ArrowRight"
      , Ns = "ArrowUp"
      , Bi = "ArrowDown"
      , ki = "Home"
      , Vi = "End"
      , Gt = "active"
      , Ai = "show"
      , ji = ".dropdown-toggle"
      , Si = `:not(${ji})`
      , Ui = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]'
      , Ci = `.nav-link${Si}, .list-group-item${Si}, [role="tab"]${Si}, ${Ui}`
      , Hs = `.${Gt}[data-bs-toggle="tab"], .${Gt}[data-bs-toggle="pill"], .${Gt}[data-bs-toggle="list"]`;
    class jt extends fe {
        constructor(f) {
            super(f),
            this._parent = this._element.closest('.list-group, .nav, [role="tablist"]'),
            this._parent && (this._setInitialAttributes(this._parent, this._getChildren()),
            F.on(this._element, Ds, A=>this._keydown(A)))
        }
        static get NAME() {
            return "tab"
        }
        show() {
            const f = this._element;
            if (this._elemIsActive(f))
                return;
            const A = this._getActiveElem()
              , L = A ? F.trigger(A, Is, {
                relatedTarget: f
            }) : null;
            F.trigger(f, zs, {
                relatedTarget: A
            }).defaultPrevented || L && L.defaultPrevented || (this._deactivate(A, f),
            this._activate(f, A))
        }
        _activate(f, A) {
            f && (f.classList.add(Gt),
            this._activate(te.getElementFromSelector(f)),
            this._queueCallback(()=>{
                "tab" === f.getAttribute("role") ? (f.removeAttribute("tabindex"),
                f.setAttribute("aria-selected", !0),
                this._toggleDropDown(f, !0),
                F.trigger(f, Xs, {
                    relatedTarget: A
                })) : f.classList.add(Ai)
            }
            , f, f.classList.contains("fade")))
        }
        _deactivate(f, A) {
            f && (f.classList.remove(Gt),
            f.blur(),
            this._deactivate(te.getElementFromSelector(f)),
            this._queueCallback(()=>{
                "tab" === f.getAttribute("role") ? (f.setAttribute("aria-selected", !1),
                f.setAttribute("tabindex", "-1"),
                this._toggleDropDown(f, !1),
                F.trigger(f, Ms, {
                    relatedTarget: A
                })) : f.classList.remove(Ai)
            }
            , f, f.classList.contains("fade")))
        }
        _keydown(f) {
            if (![Fs, Wi, Ns, Bi, ki, Vi].includes(f.key))
                return;
            f.stopPropagation(),
            f.preventDefault();
            const A = this._getChildren().filter(Y=>!Te(Y));
            let L;
            if ([ki, Vi].includes(f.key))
                L = A[f.key === ki ? 0 : A.length - 1];
            else {
                const Y = [Wi, Bi].includes(f.key);
                L = tt(A, f.target, Y, !0)
            }
            L && (L.focus({
                preventScroll: !0
            }),
            jt.getOrCreateInstance(L).show())
        }
        _getChildren() {
            return te.find(Ci, this._parent)
        }
        _getActiveElem() {
            return this._getChildren().find(f=>this._elemIsActive(f)) || null
        }
        _setInitialAttributes(f, A) {
            this._setAttributeIfNotExists(f, "role", "tablist");
            for (const L of A)
                this._setInitialAttributesOnChild(L)
        }
        _setInitialAttributesOnChild(f) {
            f = this._getInnerElement(f);
            const A = this._elemIsActive(f)
              , L = this._getOuterElement(f);
            f.setAttribute("aria-selected", A),
            L !== f && this._setAttributeIfNotExists(L, "role", "presentation"),
            A || f.setAttribute("tabindex", "-1"),
            this._setAttributeIfNotExists(f, "role", "tab"),
            this._setInitialAttributesOnTargetPanel(f)
        }
        _setInitialAttributesOnTargetPanel(f) {
            const A = te.getElementFromSelector(f);
            A && (this._setAttributeIfNotExists(A, "role", "tabpanel"),
            f.id && this._setAttributeIfNotExists(A, "aria-labelledby", `${f.id}`))
        }
        _toggleDropDown(f, A) {
            const L = this._getOuterElement(f);
            if (!L.classList.contains("dropdown"))
                return;
            const Y = ($,ee)=>{
                const he = te.findOne($, L);
                he && he.classList.toggle(ee, A)
            }
            ;
            Y(ji, Gt),
            Y(".dropdown-menu", Ai),
            L.setAttribute("aria-expanded", A)
        }
        _setAttributeIfNotExists(f, A, L) {
            f.hasAttribute(A) || f.setAttribute(A, L)
        }
        _elemIsActive(f) {
            return f.classList.contains(Gt)
        }
        _getInnerElement(f) {
            return f.matches(Ci) ? f : te.findOne(Ci, f)
        }
        _getOuterElement(f) {
            return f.closest(".nav-item, .list-group-item") || f
        }
        static jQueryInterface(f) {
            return this.each(function() {
                const A = jt.getOrCreateInstance(this);
                if ("string" == typeof f) {
                    if (void 0 === A[f] || f.startsWith("_") || "constructor" === f)
                        throw new TypeError(`No method named "${f}"`);
                    A[f]()
                }
            })
        }
    }
    F.on(document, Os, Ui, function(P) {
        ["A", "AREA"].includes(this.tagName) && P.preventDefault(),
        Te(this) || jt.getOrCreateInstance(this).show()
    }),
    F.on(window, Ys, ()=>{
        for (const P of te.find(Hs))
            jt.getOrCreateInstance(P)
    }
    ),
    Ee(jt);
    const Tt = ".bs.toast"
      , Rs = `mouseover${Tt}`
      , Ws = `mouseout${Tt}`
      , Bs = `focusin${Tt}`
      , Vs = `focusout${Tt}`
      , Gs = `hide${Tt}`
      , js = `hidden${Tt}`
      , Us = `show${Tt}`
      , $s = `shown${Tt}`
      , fi = "show"
      , pi = "showing"
      , qs = {
        animation: "boolean",
        autohide: "boolean",
        delay: "number"
    }
      , Zs = {
        animation: !0,
        autohide: !0,
        delay: 5e3
    };
    class li extends fe {
        constructor(f, A) {
            super(f, A),
            this._timeout = null,
            this._hasMouseInteraction = !1,
            this._hasKeyboardInteraction = !1,
            this._setListeners()
        }
        static get Default() {
            return Zs
        }
        static get DefaultType() {
            return qs
        }
        static get NAME() {
            return "toast"
        }
        show() {
            F.trigger(this._element, Us).defaultPrevented || (this._clearTimeout(),
            this._config.animation && this._element.classList.add("fade"),
            this._element.classList.remove("hide"),
            this._element.classList.add(fi, pi),
            this._queueCallback(()=>{
                this._element.classList.remove(pi),
                F.trigger(this._element, $s),
                this._maybeScheduleHide()
            }
            , this._element, this._config.animation))
        }
        hide() {
            this.isShown() && (F.trigger(this._element, Gs).defaultPrevented || (this._element.classList.add(pi),
            this._queueCallback(()=>{
                this._element.classList.add("hide"),
                this._element.classList.remove(pi, fi),
                F.trigger(this._element, js)
            }
            , this._element, this._config.animation)))
        }
        dispose() {
            this._clearTimeout(),
            this.isShown() && this._element.classList.remove(fi),
            super.dispose()
        }
        isShown() {
            return this._element.classList.contains(fi)
        }
        _maybeScheduleHide() {
            this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(()=>{
                this.hide()
            }
            , this._config.delay)))
        }
        _onInteraction(f, A) {
            switch (f.type) {
            case "mouseover":
            case "mouseout":
                this._hasMouseInteraction = A;
                break;
            case "focusin":
            case "focusout":
                this._hasKeyboardInteraction = A
            }
            if (A)
                return void this._clearTimeout();
            const L = f.relatedTarget;
            this._element === L || this._element.contains(L) || this._maybeScheduleHide()
        }
        _setListeners() {
            F.on(this._element, Rs, f=>this._onInteraction(f, !0)),
            F.on(this._element, Ws, f=>this._onInteraction(f, !1)),
            F.on(this._element, Bs, f=>this._onInteraction(f, !0)),
            F.on(this._element, Vs, f=>this._onInteraction(f, !1))
        }
        _clearTimeout() {
            clearTimeout(this._timeout),
            this._timeout = null
        }
        static jQueryInterface(f) {
            return this.each(function() {
                const A = li.getOrCreateInstance(this, f);
                if ("string" == typeof f) {
                    if (void 0 === A[f])
                        throw new TypeError(`No method named "${f}"`);
                    A[f](this)
                }
            })
        }
    }
    return Be(li),
    Ee(li),
    {
        Alert: ut,
        Button: je,
        Carousel: U,
        Collapse: r,
        Dropdown: ne,
        Modal: Wt,
        Offcanvas: vt,
        Popover: gi,
        ScrollSpy: oi,
        Tab: jt,
        Toast: li,
        Tooltip: Bt
    }
}),
function(ce, Z) {
    "object" == typeof exports && typeof module < "u" ? module.exports = Z() : "function" == typeof define && define.amd ? define(Z) : (ce = typeof globalThis < "u" ? globalThis : ce || self).ApexCharts = Z()
}(this, function() {
    "use strict";
    function ce(y, e) {
        var t = Object.keys(y);
        if (Object.getOwnPropertySymbols) {
            var i = Object.getOwnPropertySymbols(y);
            e && (i = i.filter(function(s) {
                return Object.getOwnPropertyDescriptor(y, s).enumerable
            })),
            t.push.apply(t, i)
        }
        return t
    }
    function Z(y) {
        for (var e = 1; e < arguments.length; e++) {
            var t = null != arguments[e] ? arguments[e] : {};
            e % 2 ? ce(Object(t), !0).forEach(function(i) {
                Ke(y, i, t[i])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(y, Object.getOwnPropertyDescriptors(t)) : ce(Object(t)).forEach(function(i) {
                Object.defineProperty(y, i, Object.getOwnPropertyDescriptor(t, i))
            })
        }
        return y
    }
    function de(y) {
        return (de = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        }
        : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }
        )(y)
    }
    function W(y, e) {
        if (!(y instanceof e))
            throw new TypeError("Cannot call a class as a function")
    }
    function ot(y, e) {
        for (var t = 0; t < e.length; t++) {
            var i = e[t];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(y, i.key, i)
        }
    }
    function V(y, e, t) {
        return e && ot(y.prototype, e),
        t && ot(y, t),
        y
    }
    function Ke(y, e, t) {
        return e in y ? Object.defineProperty(y, e, {
            value: t,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : y[e] = t,
        y
    }
    function Fe(y, e) {
        if ("function" != typeof e && null !== e)
            throw new TypeError("Super expression must either be null or a function");
        y.prototype = Object.create(e && e.prototype, {
            constructor: {
                value: y,
                writable: !0,
                configurable: !0
            }
        }),
        e && We(y, e)
    }
    function Ie(y) {
        return (Ie = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        }
        )(y)
    }
    function We(y, e) {
        return (We = Object.setPrototypeOf || function(t, i) {
            return t.__proto__ = i,
            t
        }
        )(y, e)
    }
    function Ne(y, e) {
        if (e && ("object" == typeof e || "function" == typeof e))
            return e;
        if (void 0 !== e)
            throw new TypeError("Derived constructors may only return object or undefined");
        return function(t) {
            if (void 0 === t)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }(y)
    }
    function Te(y) {
        var e = function() {
            if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
                return !1;
            if ("function" == typeof Proxy)
                return !0;
            try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})),
                !0
            } catch {
                return !1
            }
        }();
        return function() {
            var t, i = Ie(y);
            if (e) {
                var s = Ie(this).constructor;
                t = Reflect.construct(i, arguments, s)
            } else
                t = i.apply(this, arguments);
            return Ne(this, t)
        }
    }
    function pe(y) {
        return function(e) {
            if (Array.isArray(e))
                return Me(e)
        }(y) || function(e) {
            if (typeof Symbol < "u" && null != e[Symbol.iterator] || null != e["@@iterator"])
                return Array.from(e)
        }(y) || function(e, t) {
            if (e) {
                if ("string" == typeof e)
                    return Me(e, t);
                var i = Object.prototype.toString.call(e).slice(8, -1);
                if ("Object" === i && e.constructor && (i = e.constructor.name),
                "Map" === i || "Set" === i)
                    return Array.from(e);
                if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                    return Me(e, t)
            }
        }(y) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }
    function Me(y, e) {
        (null == e || e > y.length) && (e = y.length);
        for (var t = 0, i = new Array(e); t < e; t++)
            i[t] = y[t];
        return i
    }
    var M = function() {
        function y() {
            W(this, y)
        }
        return V(y, [{
            key: "shadeRGBColor",
            value: function(e, t) {
                var i = t.split(",")
                  , s = e < 0 ? 0 : 255
                  , a = e < 0 ? -1 * e : e
                  , r = parseInt(i[0].slice(4), 10)
                  , n = parseInt(i[1], 10)
                  , o = parseInt(i[2], 10);
                return "rgb(" + (Math.round((s - r) * a) + r) + "," + (Math.round((s - n) * a) + n) + "," + (Math.round((s - o) * a) + o) + ")"
            }
        }, {
            key: "shadeHexColor",
            value: function(e, t) {
                var i = parseInt(t.slice(1), 16)
                  , s = e < 0 ? 0 : 255
                  , a = e < 0 ? -1 * e : e
                  , r = i >> 16
                  , n = i >> 8 & 255
                  , o = 255 & i;
                return "#" + (16777216 + 65536 * (Math.round((s - r) * a) + r) + 256 * (Math.round((s - n) * a) + n) + (Math.round((s - o) * a) + o)).toString(16).slice(1)
            }
        }, {
            key: "shadeColor",
            value: function(e, t) {
                return y.isColorHex(t) ? this.shadeHexColor(e, t) : this.shadeRGBColor(e, t)
            }
        }], [{
            key: "bind",
            value: function(e, t) {
                return function() {
                    return e.apply(t, arguments)
                }
            }
        }, {
            key: "isObject",
            value: function(e) {
                return e && "object" === de(e) && !Array.isArray(e) && null != e
            }
        }, {
            key: "is",
            value: function(e, t) {
                return Object.prototype.toString.call(t) === "[object " + e + "]"
            }
        }, {
            key: "listToArray",
            value: function(e) {
                var t, i = [];
                for (t = 0; t < e.length; t++)
                    i[t] = e[t];
                return i
            }
        }, {
            key: "extend",
            value: function(e, t) {
                var i = this;
                "function" != typeof Object.assign && (Object.assign = function(a) {
                    if (null == a)
                        throw new TypeError("Cannot convert undefined or null to object");
                    for (var r = Object(a), n = 1; n < arguments.length; n++) {
                        var o = arguments[n];
                        if (null != o)
                            for (var l in o)
                                o.hasOwnProperty(l) && (r[l] = o[l])
                    }
                    return r
                }
                );
                var s = Object.assign({}, e);
                return this.isObject(e) && this.isObject(t) && Object.keys(t).forEach(function(a) {
                    i.isObject(t[a]) && a in e ? s[a] = i.extend(e[a], t[a]) : Object.assign(s, Ke({}, a, t[a]))
                }),
                s
            }
        }, {
            key: "extendArray",
            value: function(e, t) {
                var i = [];
                return e.map(function(s) {
                    i.push(y.extend(t, s))
                }),
                i
            }
        }, {
            key: "monthMod",
            value: function(e) {
                return e % 12
            }
        }, {
            key: "clone",
            value: function(e) {
                if (y.is("Array", e)) {
                    for (var t = [], i = 0; i < e.length; i++)
                        t[i] = this.clone(e[i]);
                    return t
                }
                if (y.is("Null", e))
                    return null;
                if (y.is("Date", e))
                    return e;
                if ("object" === de(e)) {
                    var s = {};
                    for (var a in e)
                        e.hasOwnProperty(a) && (s[a] = this.clone(e[a]));
                    return s
                }
                return e
            }
        }, {
            key: "log10",
            value: function(e) {
                return Math.log(e) / Math.LN10
            }
        }, {
            key: "roundToBase10",
            value: function(e) {
                return Math.pow(10, Math.floor(Math.log10(e)))
            }
        }, {
            key: "roundToBase",
            value: function(e, t) {
                return Math.pow(t, Math.floor(Math.log(e) / Math.log(t)))
            }
        }, {
            key: "parseNumber",
            value: function(e) {
                return null === e ? e : parseFloat(e)
            }
        }, {
            key: "randomId",
            value: function() {
                return (Math.random() + 1).toString(36).substring(4)
            }
        }, {
            key: "noExponents",
            value: function(e) {
                var t = String(e).split(/[eE]/);
                if (1 === t.length)
                    return t[0];
                var i = ""
                  , s = e < 0 ? "-" : ""
                  , a = t[0].replace(".", "")
                  , r = Number(t[1]) + 1;
                if (r < 0) {
                    for (i = s + "0."; r++; )
                        i += "0";
                    return i + a.replace(/^-/, "")
                }
                for (r -= a.length; r--; )
                    i += "0";
                return a + i
            }
        }, {
            key: "getDimensions",
            value: function(e) {
                var t = getComputedStyle(e, null)
                  , i = e.clientHeight
                  , s = e.clientWidth;
                return i -= parseFloat(t.paddingTop) + parseFloat(t.paddingBottom),
                [s -= parseFloat(t.paddingLeft) + parseFloat(t.paddingRight), i]
            }
        }, {
            key: "getBoundingClientRect",
            value: function(e) {
                var t = e.getBoundingClientRect();
                return {
                    top: t.top,
                    right: t.right,
                    bottom: t.bottom,
                    left: t.left,
                    width: e.clientWidth,
                    height: e.clientHeight,
                    x: t.left,
                    y: t.top
                }
            }
        }, {
            key: "getLargestStringFromArr",
            value: function(e) {
                return e.reduce(function(t, i) {
                    return Array.isArray(i) && (i = i.reduce(function(s, a) {
                        return s.length > a.length ? s : a
                    })),
                    t.length > i.length ? t : i
                }, 0)
            }
        }, {
            key: "hexToRgba",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "#999999"
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .6;
                "#" !== e.substring(0, 1) && (e = "#999999");
                var i = e.replace("#", "");
                i = i.match(new RegExp("(.{" + i.length / 3 + "})","g"));
                for (var s = 0; s < i.length; s++)
                    i[s] = parseInt(1 === i[s].length ? i[s] + i[s] : i[s], 16);
                return void 0 !== t && i.push(t),
                "rgba(" + i.join(",") + ")"
            }
        }, {
            key: "getOpacityFromRGBA",
            value: function(e) {
                return parseFloat(e.replace(/^.*,(.+)\)/, "$1"))
            }
        }, {
            key: "rgb2hex",
            value: function(e) {
                return (e = e.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && 4 === e.length ? "#" + ("0" + parseInt(e[1], 10).toString(16)).slice(-2) + ("0" + parseInt(e[2], 10).toString(16)).slice(-2) + ("0" + parseInt(e[3], 10).toString(16)).slice(-2) : ""
            }
        }, {
            key: "isColorHex",
            value: function(e) {
                return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(e)
            }
        }, {
            key: "getPolygonPos",
            value: function(e, t) {
                for (var i = [], s = 2 * Math.PI / t, a = 0; a < t; a++) {
                    var r = {};
                    r.x = e * Math.sin(a * s),
                    r.y = -e * Math.cos(a * s),
                    i.push(r)
                }
                return i
            }
        }, {
            key: "polarToCartesian",
            value: function(e, t, i, s) {
                var a = (s - 90) * Math.PI / 180;
                return {
                    x: e + i * Math.cos(a),
                    y: t + i * Math.sin(a)
                }
            }
        }, {
            key: "escapeString",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "x"
                  , i = e.toString().slice();
                return i.replace(/[` ~!@#$%^&*()_|+\-=?;:'",.<>{}[\]\\/]/gi, t)
            }
        }, {
            key: "negToZero",
            value: function(e) {
                return e < 0 ? 0 : e
            }
        }, {
            key: "moveIndexInArray",
            value: function(e, t, i) {
                if (i >= e.length)
                    for (var s = i - e.length + 1; s--; )
                        e.push(void 0);
                return e.splice(i, 0, e.splice(t, 1)[0]),
                e
            }
        }, {
            key: "extractNumber",
            value: function(e) {
                return parseFloat(e.replace(/[^\d.]*/g, ""))
            }
        }, {
            key: "findAncestor",
            value: function(e, t) {
                for (; (e = e.parentElement) && !e.classList.contains(t); )
                    ;
                return e
            }
        }, {
            key: "setELstyles",
            value: function(e, t) {
                for (var i in t)
                    t.hasOwnProperty(i) && (e.style.key = t[i])
            }
        }, {
            key: "isNumber",
            value: function(e) {
                return !isNaN(e) && parseFloat(Number(e)) === e && !isNaN(parseInt(e, 10))
            }
        }, {
            key: "isFloat",
            value: function(e) {
                return Number(e) === e && e % 1 != 0
            }
        }, {
            key: "isSafari",
            value: function() {
                return /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
            }
        }, {
            key: "isFirefox",
            value: function() {
                return navigator.userAgent.toLowerCase().indexOf("firefox") > -1
            }
        }, {
            key: "isIE11",
            value: function() {
                if (-1 !== window.navigator.userAgent.indexOf("MSIE") || window.navigator.appVersion.indexOf("Trident/") > -1)
                    return !0
            }
        }, {
            key: "isIE",
            value: function() {
                var e = window.navigator.userAgent
                  , t = e.indexOf("MSIE ");
                if (t > 0)
                    return parseInt(e.substring(t + 5, e.indexOf(".", t)), 10);
                if (e.indexOf("Trident/") > 0) {
                    var i = e.indexOf("rv:");
                    return parseInt(e.substring(i + 3, e.indexOf(".", i)), 10)
                }
                var s = e.indexOf("Edge/");
                return s > 0 && parseInt(e.substring(s + 5, e.indexOf(".", s)), 10)
            }
        }]),
        y
    }()
      , Ce = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w,
            this.setEasingFunctions()
        }
        return V(y, [{
            key: "setEasingFunctions",
            value: function() {
                var e;
                if (!this.w.globals.easing) {
                    switch (this.w.config.chart.animations.easing) {
                    case "linear":
                        e = "-";
                        break;
                    case "easein":
                        e = "<";
                        break;
                    case "easeout":
                        e = ">";
                        break;
                    case "easeinout":
                    default:
                        e = "<>";
                        break;
                    case "swing":
                        e = function(t) {
                            var i = 1.70158;
                            return (t -= 1) * t * ((i + 1) * t + i) + 1
                        }
                        ;
                        break;
                    case "bounce":
                        e = function(t) {
                            return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                        }
                        ;
                        break;
                    case "elastic":
                        e = function(t) {
                            return t === !!t ? t : Math.pow(2, -10 * t) * Math.sin((t - .075) * (2 * Math.PI) / .3) + 1
                        }
                    }
                    this.w.globals.easing = e
                }
            }
        }, {
            key: "animateLine",
            value: function(e, t, i, s) {
                e.attr(t).animate(s).attr(i)
            }
        }, {
            key: "animateMarker",
            value: function(e, t, i, s, a, r) {
                t || (t = 0),
                e.attr({
                    r: t,
                    width: t,
                    height: t
                }).animate(s, a).attr({
                    r: i,
                    width: i.width,
                    height: i.height
                }).afterAll(function() {
                    r()
                })
            }
        }, {
            key: "animateCircle",
            value: function(e, t, i, s, a) {
                e.attr({
                    r: t.r,
                    cx: t.cx,
                    cy: t.cy
                }).animate(s, a).attr({
                    r: i.r,
                    cx: i.cx,
                    cy: i.cy
                })
            }
        }, {
            key: "animateRect",
            value: function(e, t, i, s, a) {
                e.attr(t).animate(s).attr(i).afterAll(function() {
                    return a()
                })
            }
        }, {
            key: "animatePathsGradually",
            value: function(e) {
                var c = this.w
                  , d = 0;
                c.config.chart.animations.animateGradually.enabled && (d = c.config.chart.animations.animateGradually.delay),
                c.config.chart.animations.dynamicAnimation.enabled && c.globals.dataChanged && "bar" !== c.config.chart.type && (d = 0),
                this.morphSVG(e.el, e.realIndex, e.j, "line" !== c.config.chart.type || c.globals.comboCharts ? e.fill : "stroke", e.pathFrom, e.pathTo, e.speed, e.delay * d)
            }
        }, {
            key: "showDelayedElements",
            value: function() {
                this.w.globals.delayedElements.forEach(function(e) {
                    e.el.classList.remove("apexcharts-element-hidden")
                })
            }
        }, {
            key: "animationCompleted",
            value: function(e) {
                var t = this.w;
                t.globals.animationEnded || (t.globals.animationEnded = !0,
                this.showDelayedElements(),
                "function" == typeof t.config.chart.events.animationEnd && t.config.chart.events.animationEnd(this.ctx, {
                    el: e,
                    w: t
                }))
            }
        }, {
            key: "morphSVG",
            value: function(e, t, i, s, a, r, n, o) {
                var l = this
                  , c = this.w;
                a || (a = e.attr("pathFrom")),
                r || (r = e.attr("pathTo"));
                var d = function(g) {
                    return "radar" === c.config.chart.type && (n = 1),
                    "M 0 ".concat(c.globals.gridHeight)
                };
                (!a || a.indexOf("undefined") > -1 || a.indexOf("NaN") > -1) && (a = d()),
                (!r || r.indexOf("undefined") > -1 || r.indexOf("NaN") > -1) && (r = d()),
                c.globals.shouldAnimate || (n = 1),
                e.plot(a).animate(1, c.globals.easing, o).plot(a).animate(n, c.globals.easing, o).plot(r).afterAll(function() {
                    M.isNumber(i) ? i === c.globals.series[c.globals.maxValsInArrayIndex].length - 2 && c.globals.shouldAnimate && l.animationCompleted(e) : "none" !== s && c.globals.shouldAnimate && (!c.globals.comboCharts && t === c.globals.series.length - 1 || c.globals.comboCharts) && l.animationCompleted(e),
                    l.showDelayedElements()
                })
            }
        }]),
        y
    }()
      , me = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w
        }
        return V(y, [{
            key: "getDefaultFilter",
            value: function(e, t) {
                var i = this.w;
                e.unfilter(!0),
                (new window.SVG.Filter).size("120%", "180%", "-5%", "-40%"),
                "none" !== i.config.states.normal.filter ? this.applyFilter(e, t, i.config.states.normal.filter.type, i.config.states.normal.filter.value) : i.config.chart.dropShadow.enabled && this.dropShadow(e, i.config.chart.dropShadow, t)
            }
        }, {
            key: "addNormalFilter",
            value: function(e, t) {
                var i = this.w;
                i.config.chart.dropShadow.enabled && !e.node.classList.contains("apexcharts-marker") && this.dropShadow(e, i.config.chart.dropShadow, t)
            }
        }, {
            key: "addLightenFilter",
            value: function(e, t, i) {
                var s = this
                  , a = this.w
                  , r = i.intensity;
                e.unfilter(!0),
                new window.SVG.Filter,
                e.filter(function(n) {
                    var o = a.config.chart.dropShadow;
                    (o.enabled ? s.addShadow(n, t, o) : n).componentTransfer({
                        rgb: {
                            type: "linear",
                            slope: 1.5,
                            intercept: r
                        }
                    })
                }),
                e.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"),
                this._scaleFilterSize(e.filterer.node)
            }
        }, {
            key: "addDarkenFilter",
            value: function(e, t, i) {
                var s = this
                  , a = this.w
                  , r = i.intensity;
                e.unfilter(!0),
                new window.SVG.Filter,
                e.filter(function(n) {
                    var o = a.config.chart.dropShadow;
                    (o.enabled ? s.addShadow(n, t, o) : n).componentTransfer({
                        rgb: {
                            type: "linear",
                            slope: r
                        }
                    })
                }),
                e.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"),
                this._scaleFilterSize(e.filterer.node)
            }
        }, {
            key: "applyFilter",
            value: function(e, t, i) {
                var s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .5;
                switch (i) {
                case "none":
                    this.addNormalFilter(e, t);
                    break;
                case "lighten":
                    this.addLightenFilter(e, t, {
                        intensity: s
                    });
                    break;
                case "darken":
                    this.addDarkenFilter(e, t, {
                        intensity: s
                    })
                }
            }
        }, {
            key: "addShadow",
            value: function(e, t, i) {
                var s = i.blur
                  , a = i.top
                  , r = i.left
                  , n = i.color
                  , o = i.opacity
                  , l = e.flood(Array.isArray(n) ? n[t] : n, o).composite(e.sourceAlpha, "in").offset(r, a).gaussianBlur(s).merge(e.source);
                return e.blend(e.source, l)
            }
        }, {
            key: "dropShadow",
            value: function(e, t) {
                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                  , s = t.top
                  , a = t.left
                  , r = t.blur
                  , n = t.color
                  , o = t.opacity
                  , l = t.noUserSpaceOnUse
                  , c = this.w;
                return e.unfilter(!0),
                M.isIE() && "radialBar" === c.config.chart.type || (n = Array.isArray(n) ? n[i] : n,
                e.filter(function(d) {
                    var g;
                    g = M.isSafari() || M.isFirefox() || M.isIE() ? d.flood(n, o).composite(d.sourceAlpha, "in").offset(a, s).gaussianBlur(r) : d.flood(n, o).composite(d.sourceAlpha, "in").offset(a, s).gaussianBlur(r).merge(d.source),
                    d.blend(d.source, g)
                }),
                l || e.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"),
                this._scaleFilterSize(e.filterer.node)),
                e
            }
        }, {
            key: "setSelectionFilter",
            value: function(e, t, i) {
                var s = this.w;
                if (void 0 !== s.globals.selectedDataPoints[t] && s.globals.selectedDataPoints[t].indexOf(i) > -1) {
                    e.node.setAttribute("selected", !0);
                    var a = s.config.states.active.filter;
                    "none" !== a && this.applyFilter(e, t, a.type, a.value)
                }
            }
        }, {
            key: "_scaleFilterSize",
            value: function(e) {
                !function(t) {
                    for (var i in t)
                        t.hasOwnProperty(i) && e.setAttribute(i, t[i])
                }({
                    width: "200%",
                    height: "200%",
                    x: "-50%",
                    y: "-50%"
                })
            }
        }]),
        y
    }()
      , D = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w
        }
        return V(y, [{
            key: "drawLine",
            value: function(e, t, i, s) {
                var a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "#a8a8a8"
                  , r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0
                  , n = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null
                  , o = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : "butt"
                  , l = this.w
                  , c = l.globals.dom.Paper.line().attr({
                    x1: e,
                    y1: t,
                    x2: i,
                    y2: s,
                    stroke: a,
                    "stroke-dasharray": r,
                    "stroke-width": n,
                    "stroke-linecap": o
                });
                return c
            }
        }, {
            key: "drawRect",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                  , s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0
                  , a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0
                  , r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "#fefefe"
                  , n = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1
                  , o = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null
                  , l = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : null
                  , c = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0
                  , d = this.w
                  , g = d.globals.dom.Paper.rect();
                return g.attr({
                    x: e,
                    y: t,
                    width: i > 0 ? i : 0,
                    height: s > 0 ? s : 0,
                    rx: a,
                    ry: a,
                    opacity: n,
                    "stroke-width": null !== o ? o : 0,
                    stroke: null !== l ? l : "none",
                    "stroke-dasharray": c
                }),
                g.node.setAttribute("fill", r),
                g
            }
        }, {
            key: "drawPolygon",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "#e1e1e1"
                  , i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1
                  , s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "none"
                  , a = this.w
                  , r = a.globals.dom.Paper.polygon(e).attr({
                    fill: s,
                    stroke: t,
                    "stroke-width": i
                });
                return r
            }
        }, {
            key: "drawCircle",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
                  , i = this.w;
                e < 0 && (e = 0);
                var s = i.globals.dom.Paper.circle(2 * e);
                return null !== t && s.attr(t),
                s
            }
        }, {
            key: "drawPath",
            value: function(e) {
                var t = e.d
                  , i = void 0 === t ? "" : t
                  , s = e.stroke
                  , a = void 0 === s ? "#a8a8a8" : s
                  , r = e.strokeWidth
                  , n = void 0 === r ? 1 : r
                  , o = e.fill
                  , l = e.fillOpacity
                  , c = void 0 === l ? 1 : l
                  , d = e.strokeOpacity
                  , g = void 0 === d ? 1 : d
                  , p = e.classes
                  , m = e.strokeLinecap
                  , x = void 0 === m ? null : m
                  , v = e.strokeDashArray
                  , k = void 0 === v ? 0 : v
                  , S = this.w;
                return null === x && (x = S.config.stroke.lineCap),
                (i.indexOf("undefined") > -1 || i.indexOf("NaN") > -1) && (i = "M 0 ".concat(S.globals.gridHeight)),
                S.globals.dom.Paper.path(i).attr({
                    fill: o,
                    "fill-opacity": c,
                    stroke: a,
                    "stroke-opacity": g,
                    "stroke-linecap": x,
                    "stroke-width": n,
                    "stroke-dasharray": k,
                    class: p
                })
            }
        }, {
            key: "group",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
                  , t = this.w
                  , i = t.globals.dom.Paper.group();
                return null !== e && i.attr(e),
                i
            }
        }, {
            key: "move",
            value: function(e, t) {
                return ["M", e, t].join(" ")
            }
        }, {
            key: "line",
            value: function(e, t) {
                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
                  , s = null;
                return null === i ? s = ["L", e, t].join(" ") : "H" === i ? s = ["H", e].join(" ") : "V" === i && (s = ["V", t].join(" ")),
                s
            }
        }, {
            key: "curve",
            value: function(e, t, i, s, a, r) {
                return ["C", e, t, i, s, a, r].join(" ")
            }
        }, {
            key: "quadraticCurve",
            value: function(e, t, i, s) {
                return ["Q", e, t, i, s].join(" ")
            }
        }, {
            key: "arc",
            value: function(e, t, i, s, a, r, n) {
                var o = arguments.length > 7 && void 0 !== arguments[7] && arguments[7]
                  , l = "A";
                o && (l = "a");
                var c = [l, e, t, i, s, a, r, n].join(" ");
                return c
            }
        }, {
            key: "renderPaths",
            value: function(e) {
                var t, i = e.j, s = e.realIndex, a = e.pathFrom, r = e.pathTo, n = e.stroke, o = e.strokeWidth, l = e.strokeLinecap, c = e.fill, d = e.animationDelay, g = e.initialSpeed, p = e.dataChangeSpeed, m = e.className, x = e.shouldClipToGrid, v = void 0 === x || x, k = e.bindEventsOnPaths, S = void 0 === k || k, C = e.drawShadow, h = void 0 === C || C, u = this.w, b = new me(this.ctx), w = new Ce(this.ctx), _ = this.w.config.chart.animations.enabled, X = _ && this.w.config.chart.animations.dynamicAnimation.enabled, I = !!(_ && !u.globals.resized || X && u.globals.dataChanged && u.globals.shouldAnimate);
                I ? t = a : (t = r,
                u.globals.animationEnded = !0);
                var H, R = u.config.stroke.dashArray;
                H = Array.isArray(R) ? R[s] : u.config.stroke.dashArray;
                var G = this.drawPath({
                    d: t,
                    stroke: n,
                    strokeWidth: o,
                    fill: c,
                    fillOpacity: 1,
                    classes: m,
                    strokeLinecap: l,
                    strokeDashArray: H
                });
                G.attr("index", s),
                v && G.attr({
                    "clip-path": "url(#gridRectMask".concat(u.globals.cuid, ")")
                }),
                "none" !== u.config.states.normal.filter.type ? b.getDefaultFilter(G, s) : u.config.chart.dropShadow.enabled && h && (!u.config.chart.dropShadow.enabledOnSeries || u.config.chart.dropShadow.enabledOnSeries && -1 !== u.config.chart.dropShadow.enabledOnSeries.indexOf(s)) && b.dropShadow(G, u.config.chart.dropShadow, s),
                S && (G.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, G)),
                G.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, G)),
                G.node.addEventListener("mousedown", this.pathMouseDown.bind(this, G))),
                G.attr({
                    pathTo: r,
                    pathFrom: a
                });
                var ne = {
                    el: G,
                    j: i,
                    realIndex: s,
                    pathFrom: a,
                    pathTo: r,
                    fill: c,
                    strokeWidth: o,
                    delay: d
                };
                return !_ || u.globals.resized || u.globals.dataChanged ? !u.globals.resized && u.globals.dataChanged || w.showDelayedElements() : w.animatePathsGradually(Z(Z({}, ne), {}, {
                    speed: g
                })),
                u.globals.dataChanged && X && I && w.animatePathsGradually(Z(Z({}, ne), {}, {
                    speed: p
                })),
                G
            }
        }, {
            key: "drawPattern",
            value: function(e, t, i) {
                var s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "#a8a8a8"
                  , a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0
                  , r = this.w
                  , n = r.globals.dom.Paper.pattern(t, i, function(o) {
                    "horizontalLines" === e ? o.line(0, 0, i, 0).stroke({
                        color: s,
                        width: a + 1
                    }) : "verticalLines" === e ? o.line(0, 0, 0, t).stroke({
                        color: s,
                        width: a + 1
                    }) : "slantedLines" === e ? o.line(0, 0, t, i).stroke({
                        color: s,
                        width: a
                    }) : "squares" === e ? o.rect(t, i).fill("none").stroke({
                        color: s,
                        width: a
                    }) : "circles" === e && o.circle(t).fill("none").stroke({
                        color: s,
                        width: a
                    })
                });
                return n
            }
        }, {
            key: "drawGradient",
            value: function(e, t, i, s, a) {
                var r, n = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, l = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null, c = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0, d = this.w;
                t.length < 9 && 0 === t.indexOf("#") && (t = M.hexToRgba(t, s)),
                i.length < 9 && 0 === i.indexOf("#") && (i = M.hexToRgba(i, a));
                var g = 0
                  , p = 1
                  , m = 1
                  , x = null;
                null !== o && (g = void 0 !== o[0] ? o[0] / 100 : 0,
                p = void 0 !== o[1] ? o[1] / 100 : 1,
                m = void 0 !== o[2] ? o[2] / 100 : 1,
                x = void 0 !== o[3] ? o[3] / 100 : null);
                var v = !("donut" !== d.config.chart.type && "pie" !== d.config.chart.type && "polarArea" !== d.config.chart.type && "bubble" !== d.config.chart.type);
                if (r = d.globals.dom.Paper.gradient(v ? "radial" : "linear", null === l || 0 === l.length ? function(C) {
                    C.at(g, t, s),
                    C.at(p, i, a),
                    C.at(m, i, a),
                    null !== x && C.at(x, t, s)
                }
                : function(C) {
                    (Array.isArray(l[c]) ? l[c] : l).forEach(function(h) {
                        C.at(h.offset / 100, h.color, h.opacity)
                    })
                }
                ),
                v) {
                    var k = d.globals.gridWidth / 2
                      , S = d.globals.gridHeight / 2;
                    r.attr("bubble" !== d.config.chart.type ? {
                        gradientUnits: "userSpaceOnUse",
                        cx: k,
                        cy: S,
                        r: n
                    } : {
                        cx: .5,
                        cy: .5,
                        r: .8,
                        fx: .2,
                        fy: .2
                    })
                } else
                    "vertical" === e ? r.from(0, 0).to(0, 1) : "diagonal" === e ? r.from(0, 0).to(1, 1) : "horizontal" === e ? r.from(0, 1).to(1, 1) : "diagonal2" === e && r.from(1, 0).to(0, 1);
                return r
            }
        }, {
            key: "drawText",
            value: function(e) {
                var t, i = e.x, s = e.y, a = e.text, r = e.textAnchor, n = e.fontSize, o = e.fontFamily, l = e.fontWeight, c = e.foreColor, d = e.opacity, g = e.cssClass, p = void 0 === g ? "" : g, m = e.isPlainText, x = void 0 === m || m, v = this.w;
                return void 0 === a && (a = ""),
                r || (r = "start"),
                c && c.length || (c = v.config.chart.foreColor),
                o = o || v.config.chart.fontFamily,
                l = l || "regular",
                (t = Array.isArray(a) ? v.globals.dom.Paper.text(function(k) {
                    for (var S = 0; S < a.length; S++)
                        0 === S ? k.tspan(a[S]) : k.tspan(a[S]).newLine()
                }) : x ? v.globals.dom.Paper.plain(a) : v.globals.dom.Paper.text(function(k) {
                    return k.tspan(a)
                })).attr({
                    x: i,
                    y: s,
                    "text-anchor": r,
                    "dominant-baseline": "auto",
                    "font-size": n,
                    "font-family": o,
                    "font-weight": l,
                    fill: c,
                    class: "apexcharts-text " + p
                }),
                t.node.style.fontFamily = o,
                t.node.style.opacity = d,
                t
            }
        }, {
            key: "drawMarker",
            value: function(e, t, i) {
                e = e || 0;
                var s = i.pSize || 0
                  , a = null;
                if ("square" === i.shape || "rect" === i.shape) {
                    var r = void 0 === i.pRadius ? s / 2 : i.pRadius;
                    null !== t && s || (s = 0,
                    r = 0);
                    var n = 1.2 * s + r
                      , o = this.drawRect(n, n, n, n, r);
                    o.attr({
                        x: e - n / 2,
                        y: t - n / 2,
                        cx: e,
                        cy: t,
                        class: i.class ? i.class : "",
                        fill: i.pointFillColor,
                        "fill-opacity": i.pointFillOpacity ? i.pointFillOpacity : 1,
                        stroke: i.pointStrokeColor,
                        "stroke-width": i.pointStrokeWidth ? i.pointStrokeWidth : 0,
                        "stroke-opacity": i.pointStrokeOpacity ? i.pointStrokeOpacity : 1
                    }),
                    a = o
                } else
                    "circle" !== i.shape && i.shape || (M.isNumber(t) || (s = 0,
                    t = 0),
                    a = this.drawCircle(s, {
                        cx: e,
                        cy: t,
                        class: i.class ? i.class : "",
                        stroke: i.pointStrokeColor,
                        fill: i.pointFillColor,
                        "fill-opacity": i.pointFillOpacity ? i.pointFillOpacity : 1,
                        "stroke-width": i.pointStrokeWidth ? i.pointStrokeWidth : 0,
                        "stroke-opacity": i.pointStrokeOpacity ? i.pointStrokeOpacity : 1
                    }));
                return a
            }
        }, {
            key: "pathMouseEnter",
            value: function(e, t) {
                var i = this.w
                  , s = new me(this.ctx)
                  , a = parseInt(e.node.getAttribute("index"), 10)
                  , r = parseInt(e.node.getAttribute("j"), 10);
                if ("function" == typeof i.config.chart.events.dataPointMouseEnter && i.config.chart.events.dataPointMouseEnter(t, this.ctx, {
                    seriesIndex: a,
                    dataPointIndex: r,
                    w: i
                }),
                this.ctx.events.fireEvent("dataPointMouseEnter", [t, this.ctx, {
                    seriesIndex: a,
                    dataPointIndex: r,
                    w: i
                }]),
                ("none" === i.config.states.active.filter.type || "true" !== e.node.getAttribute("selected")) && "none" !== i.config.states.hover.filter.type && !i.globals.isTouchDevice) {
                    var n = i.config.states.hover.filter;
                    s.applyFilter(e, a, n.type, n.value)
                }
            }
        }, {
            key: "pathMouseLeave",
            value: function(e, t) {
                var i = this.w
                  , s = new me(this.ctx)
                  , a = parseInt(e.node.getAttribute("index"), 10)
                  , r = parseInt(e.node.getAttribute("j"), 10);
                "function" == typeof i.config.chart.events.dataPointMouseLeave && i.config.chart.events.dataPointMouseLeave(t, this.ctx, {
                    seriesIndex: a,
                    dataPointIndex: r,
                    w: i
                }),
                this.ctx.events.fireEvent("dataPointMouseLeave", [t, this.ctx, {
                    seriesIndex: a,
                    dataPointIndex: r,
                    w: i
                }]),
                "none" !== i.config.states.active.filter.type && "true" === e.node.getAttribute("selected") || "none" !== i.config.states.hover.filter.type && s.getDefaultFilter(e, a)
            }
        }, {
            key: "pathMouseDown",
            value: function(e, t) {
                var i = this.w
                  , s = new me(this.ctx)
                  , a = parseInt(e.node.getAttribute("index"), 10)
                  , r = parseInt(e.node.getAttribute("j"), 10)
                  , n = "false";
                if ("true" === e.node.getAttribute("selected")) {
                    if (e.node.setAttribute("selected", "false"),
                    i.globals.selectedDataPoints[a].indexOf(r) > -1) {
                        var o = i.globals.selectedDataPoints[a].indexOf(r);
                        i.globals.selectedDataPoints[a].splice(o, 1)
                    }
                } else {
                    if (!i.config.states.active.allowMultipleDataPointsSelection && i.globals.selectedDataPoints.length > 0) {
                        i.globals.selectedDataPoints = [];
                        var l = i.globals.dom.Paper.select(".apexcharts-series path").members
                          , c = i.globals.dom.Paper.select(".apexcharts-series circle, .apexcharts-series rect").members
                          , d = function(p) {
                            Array.prototype.forEach.call(p, function(m) {
                                m.node.setAttribute("selected", "false"),
                                s.getDefaultFilter(m, a)
                            })
                        };
                        d(l),
                        d(c)
                    }
                    e.node.setAttribute("selected", "true"),
                    n = "true",
                    void 0 === i.globals.selectedDataPoints[a] && (i.globals.selectedDataPoints[a] = []),
                    i.globals.selectedDataPoints[a].push(r)
                }
                if ("true" === n) {
                    var g = i.config.states.active.filter;
                    "none" !== g && s.applyFilter(e, a, g.type, g.value)
                } else
                    "none" !== i.config.states.active.filter.type && s.getDefaultFilter(e, a);
                "function" == typeof i.config.chart.events.dataPointSelection && i.config.chart.events.dataPointSelection(t, this.ctx, {
                    selectedDataPoints: i.globals.selectedDataPoints,
                    seriesIndex: a,
                    dataPointIndex: r,
                    w: i
                }),
                t && this.ctx.events.fireEvent("dataPointSelection", [t, this.ctx, {
                    selectedDataPoints: i.globals.selectedDataPoints,
                    seriesIndex: a,
                    dataPointIndex: r,
                    w: i
                }])
            }
        }, {
            key: "rotateAroundCenter",
            value: function(e) {
                var t = {};
                return e && "function" == typeof e.getBBox && (t = e.getBBox()),
                {
                    x: t.x + t.width / 2,
                    y: t.y + t.height / 2
                }
            }
        }, {
            key: "getTextRects",
            value: function(e, t, i, s) {
                var a = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4]
                  , r = this.w
                  , n = this.drawText({
                    x: -200,
                    y: -200,
                    text: e,
                    textAnchor: "start",
                    fontSize: t,
                    fontFamily: i,
                    foreColor: "#fff",
                    opacity: 0
                });
                s && n.attr("transform", s),
                r.globals.dom.Paper.add(n);
                var o = n.bbox();
                return a || (o = n.node.getBoundingClientRect()),
                n.remove(),
                {
                    width: o.width,
                    height: o.height
                }
            }
        }, {
            key: "placeTextWithEllipsis",
            value: function(e, t, i) {
                if ("function" == typeof e.getComputedTextLength && (e.textContent = t,
                t.length > 0 && e.getComputedTextLength() >= i / 1.1)) {
                    for (var s = t.length - 3; s > 0; s -= 3)
                        if (e.getSubStringLength(0, s) <= i / 1.1)
                            return void (e.textContent = t.substring(0, s) + "...");
                    e.textContent = "."
                }
            }
        }], [{
            key: "setAttrs",
            value: function(e, t) {
                for (var i in t)
                    t.hasOwnProperty(i) && e.setAttribute(i, t[i])
            }
        }]),
        y
    }()
      , Ee = function() {
        function y(e) {
            W(this, y),
            this.w = e.w,
            this.annoCtx = e
        }
        return V(y, [{
            key: "setOrientations",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
                  , i = this.w;
                if ("vertical" === e.label.orientation) {
                    var s = null !== t ? t : 0
                      , a = i.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(s, "']"));
                    if (null !== a) {
                        var r = a.getBoundingClientRect();
                        a.setAttribute("x", parseFloat(a.getAttribute("x")) - r.height + 4),
                        a.setAttribute("y", "top" === e.label.position ? parseFloat(a.getAttribute("y")) + r.width : parseFloat(a.getAttribute("y")) - r.width);
                        var n = this.annoCtx.graphics.rotateAroundCenter(a)
                          , o = n.x
                          , l = n.y;
                        a.setAttribute("transform", "rotate(-90 ".concat(o, " ").concat(l, ")"))
                    }
                }
            }
        }, {
            key: "addBackgroundToAnno",
            value: function(e, t) {
                var i = this.w;
                if (!e || void 0 === t.label.text || void 0 !== t.label.text && !String(t.label.text).trim())
                    return null;
                var s = i.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect()
                  , a = e.getBoundingClientRect()
                  , r = t.label.style.padding.left
                  , n = t.label.style.padding.right
                  , o = t.label.style.padding.top
                  , l = t.label.style.padding.bottom;
                "vertical" === t.label.orientation && (o = t.label.style.padding.left,
                l = t.label.style.padding.right,
                r = t.label.style.padding.top,
                n = t.label.style.padding.bottom);
                var g = this.annoCtx.graphics.drawRect(a.left - s.left - r - i.globals.barPadForNumericAxis, a.top - s.top - o, a.width + r + n, a.height + o + l, t.label.borderRadius, t.label.style.background, 1, t.label.borderWidth, t.label.borderColor, 0);
                return t.id && g.node.classList.add(M.escapeString(t.id)),
                g
            }
        }, {
            key: "annotationsBackground",
            value: function() {
                var e = this
                  , t = this.w
                  , i = function(s, a, r) {
                    var n = t.globals.dom.baseEl.querySelector(".apexcharts-".concat(r, "-annotations .apexcharts-").concat(r, "-annotation-label[rel='").concat(a, "']"));
                    if (n) {
                        var o = n.parentNode
                          , l = e.addBackgroundToAnno(n, s);
                        l && (o.insertBefore(l.node, n),
                        s.label.mouseEnter && l.node.addEventListener("mouseenter", s.label.mouseEnter.bind(e, s)),
                        s.label.mouseLeave && l.node.addEventListener("mouseleave", s.label.mouseLeave.bind(e, s)))
                    }
                };
                t.config.annotations.xaxis.map(function(s, a) {
                    i(s, a, "xaxis")
                }),
                t.config.annotations.yaxis.map(function(s, a) {
                    i(s, a, "yaxis")
                }),
                t.config.annotations.points.map(function(s, a) {
                    i(s, a, "point")
                })
            }
        }, {
            key: "getStringX",
            value: function(e) {
                var t = this.w
                  , i = e;
                t.config.xaxis.convertedCatToNumeric && t.globals.categoryLabels.length && (e = t.globals.categoryLabels.indexOf(e) + 1);
                var s = t.globals.labels.indexOf(e)
                  , a = t.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(" + (s + 1) + ")");
                return a && (i = parseFloat(a.getAttribute("x"))),
                i
            }
        }]),
        y
    }()
      , ke = function() {
        function y(e) {
            W(this, y),
            this.w = e.w,
            this.annoCtx = e,
            this.invertAxis = this.annoCtx.invertAxis
        }
        return V(y, [{
            key: "addXaxisAnnotation",
            value: function(e, t, i) {
                var s = this.w
                  , a = this.invertAxis ? s.globals.minY : s.globals.minX
                  , r = this.invertAxis ? s.globals.maxY : s.globals.maxX
                  , n = this.invertAxis ? s.globals.yRange[0] : s.globals.xRange
                  , o = (e.x - a) / (n / s.globals.gridWidth);
                this.annoCtx.inversedReversedAxis && (o = (r - e.x) / (n / s.globals.gridWidth));
                var l = e.label.text;
                "category" !== s.config.xaxis.type && !s.config.xaxis.convertedCatToNumeric || this.invertAxis || s.globals.dataFormatXNumeric || (o = this.annoCtx.helpers.getStringX(e.x));
                var c = e.strokeDashArray;
                if (M.isNumber(o)) {
                    if (null == e.x2) {
                        var d = this.annoCtx.graphics.drawLine(o + e.offsetX, 0 + e.offsetY, o + e.offsetX, s.globals.gridHeight + e.offsetY, e.borderColor, c, e.borderWidth);
                        t.appendChild(d.node),
                        e.id && d.node.classList.add(e.id)
                    } else {
                        var g = (e.x2 - a) / (n / s.globals.gridWidth);
                        if (this.annoCtx.inversedReversedAxis && (g = (r - e.x2) / (n / s.globals.gridWidth)),
                        "category" !== s.config.xaxis.type && !s.config.xaxis.convertedCatToNumeric || this.invertAxis || s.globals.dataFormatXNumeric || (g = this.annoCtx.helpers.getStringX(e.x2)),
                        g < o) {
                            var p = o;
                            o = g,
                            g = p
                        }
                        var m = this.annoCtx.graphics.drawRect(o + e.offsetX, 0 + e.offsetY, g - o, s.globals.gridHeight + e.offsetY, 0, e.fillColor, e.opacity, 1, e.borderColor, c);
                        m.node.classList.add("apexcharts-annotation-rect"),
                        m.attr("clip-path", "url(#gridRectMask".concat(s.globals.cuid, ")")),
                        t.appendChild(m.node),
                        e.id && m.node.classList.add(e.id)
                    }
                    var x = "top" === e.label.position ? 4 : s.globals.gridHeight
                      , v = this.annoCtx.graphics.getTextRects(l, parseFloat(e.label.style.fontSize))
                      , k = this.annoCtx.graphics.drawText({
                        x: o + e.label.offsetX,
                        y: x + e.label.offsetY - ("vertical" === e.label.orientation ? "top" === e.label.position ? v.width / 2 - 12 : -v.width / 2 : 0),
                        text: l,
                        textAnchor: e.label.textAnchor,
                        fontSize: e.label.style.fontSize,
                        fontFamily: e.label.style.fontFamily,
                        fontWeight: e.label.style.fontWeight,
                        foreColor: e.label.style.color,
                        cssClass: "apexcharts-xaxis-annotation-label ".concat(e.label.style.cssClass, " ").concat(e.id ? e.id : "")
                    });
                    k.attr({
                        rel: i
                    }),
                    t.appendChild(k.node),
                    this.annoCtx.helpers.setOrientations(e, i)
                }
            }
        }, {
            key: "drawXAxisAnnotations",
            value: function() {
                var e = this
                  , t = this.w
                  , i = this.annoCtx.graphics.group({
                    class: "apexcharts-xaxis-annotations"
                });
                return t.config.annotations.xaxis.map(function(s, a) {
                    e.addXaxisAnnotation(s, i.node, a)
                }),
                i
            }
        }]),
        y
    }()
      , xe = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w
        }
        return V(y, [{
            key: "getStackedSeriesTotals",
            value: function() {
                var e = this.w
                  , t = [];
                if (0 === e.globals.series.length)
                    return t;
                for (var i = 0; i < e.globals.series[e.globals.maxValsInArrayIndex].length; i++) {
                    for (var s = 0, a = 0; a < e.globals.series.length; a++)
                        void 0 !== e.globals.series[a][i] && (s += e.globals.series[a][i]);
                    t.push(s)
                }
                return e.globals.stackedSeriesTotals = t,
                t
            }
        }, {
            key: "getSeriesTotalByIndex",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                return null === e ? this.w.config.series.reduce(function(t, i) {
                    return t + i
                }, 0) : this.w.globals.series[e].reduce(function(t, i) {
                    return t + i
                }, 0)
            }
        }, {
            key: "isSeriesNull",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                return 0 === (null === e ? this.w.config.series.filter(function(t) {
                    return null !== t
                }) : this.w.config.series[e].data.filter(function(t) {
                    return null !== t
                })).length
            }
        }, {
            key: "seriesHaveSameValues",
            value: function(e) {
                return this.w.globals.series[e].every(function(t, i, s) {
                    return t === s[0]
                })
            }
        }, {
            key: "getCategoryLabels",
            value: function(e) {
                var t = this.w
                  , i = e.slice();
                return t.config.xaxis.convertedCatToNumeric && (i = e.map(function(s, a) {
                    return t.config.xaxis.labels.formatter(s - t.globals.minX + 1)
                })),
                i
            }
        }, {
            key: "getLargestSeries",
            value: function() {
                var e = this.w;
                e.globals.maxValsInArrayIndex = e.globals.series.map(function(t) {
                    return t.length
                }).indexOf(Math.max.apply(Math, e.globals.series.map(function(t) {
                    return t.length
                })))
            }
        }, {
            key: "getLargestMarkerSize",
            value: function() {
                var e = this.w
                  , t = 0;
                return e.globals.markers.size.forEach(function(i) {
                    t = Math.max(t, i)
                }),
                e.globals.markers.largestSize = t,
                t
            }
        }, {
            key: "getSeriesTotals",
            value: function() {
                var e = this.w;
                e.globals.seriesTotals = e.globals.series.map(function(t, i) {
                    var s = 0;
                    if (Array.isArray(t))
                        for (var a = 0; a < t.length; a++)
                            s += t[a];
                    else
                        s += t;
                    return s
                })
            }
        }, {
            key: "getSeriesTotalsXRange",
            value: function(e, t) {
                var i = this.w;
                return i.globals.series.map(function(s, a) {
                    for (var r = 0, n = 0; n < s.length; n++)
                        i.globals.seriesX[a][n] > e && i.globals.seriesX[a][n] < t && (r += s[n]);
                    return r
                })
            }
        }, {
            key: "getPercentSeries",
            value: function() {
                var e = this.w;
                e.globals.seriesPercent = e.globals.series.map(function(t, i) {
                    var s = [];
                    if (Array.isArray(t))
                        for (var a = 0; a < t.length; a++) {
                            var r = e.globals.stackedSeriesTotals[a]
                              , n = 0;
                            r && (n = 100 * t[a] / r),
                            s.push(n)
                        }
                    else {
                        var o = 100 * t / e.globals.seriesTotals.reduce(function(l, c) {
                            return l + c
                        }, 0);
                        s.push(o)
                    }
                    return s
                })
            }
        }, {
            key: "getCalculatedRatios",
            value: function() {
                var e, t, i, s, a = this.w.globals, r = [], n = 0, o = [], l = .1, c = 0;
                if (a.yRange = [],
                a.isMultipleYAxis)
                    for (var d = 0; d < a.minYArr.length; d++)
                        a.yRange.push(Math.abs(a.minYArr[d] - a.maxYArr[d])),
                        o.push(0);
                else
                    a.yRange.push(Math.abs(a.minY - a.maxY));
                a.xRange = Math.abs(a.maxX - a.minX),
                a.zRange = Math.abs(a.maxZ - a.minZ);
                for (var g = 0; g < a.yRange.length; g++)
                    r.push(a.yRange[g] / a.gridHeight);
                if (t = a.xRange / a.gridWidth,
                i = Math.abs(a.initialMaxX - a.initialMinX) / a.gridWidth,
                e = a.yRange / a.gridWidth,
                s = a.xRange / a.gridHeight,
                (n = a.zRange / a.gridHeight * 16) || (n = 1),
                a.minY !== Number.MIN_VALUE && 0 !== Math.abs(a.minY) && (a.hasNegs = !0),
                a.isMultipleYAxis) {
                    o = [];
                    for (var p = 0; p < r.length; p++)
                        o.push(-a.minYArr[p] / r[p])
                } else
                    o.push(-a.minY / r[0]),
                    a.minY !== Number.MIN_VALUE && 0 !== Math.abs(a.minY) && (l = -a.minY / e,
                    c = a.minX / t);
                return {
                    yRatio: r,
                    invertedYRatio: e,
                    zRatio: n,
                    xRatio: t,
                    initialXRatio: i,
                    invertedXRatio: s,
                    baseLineInvertedY: l,
                    baseLineY: o,
                    baseLineX: c
                }
            }
        }, {
            key: "getLogSeries",
            value: function(e) {
                var t = this
                  , i = this.w;
                return i.globals.seriesLog = e.map(function(s, a) {
                    return i.config.yaxis[a] && i.config.yaxis[a].logarithmic ? s.map(function(r) {
                        return null === r ? null : t.getLogVal(r, a)
                    }) : s
                }),
                i.globals.invalidLogScale ? e : i.globals.seriesLog
            }
        }, {
            key: "getLogVal",
            value: function(e, t) {
                var i = this.w
                  , s = (Math.log(e) - Math.log(i.globals.minYArr[t])) / (Math.log(i.globals.maxYArr[t]) - Math.log(i.globals.minYArr[t]));
                return isNaN(s) ? e : s
            }
        }, {
            key: "getLogYRatios",
            value: function(e) {
                var t = this
                  , i = this.w
                  , s = this.w.globals;
                return s.yLogRatio = e.slice(),
                s.logYRange = s.yRange.map(function(a, r) {
                    if (i.config.yaxis[r] && t.w.config.yaxis[r].logarithmic) {
                        var n, o = -Number.MAX_VALUE, l = Number.MIN_VALUE;
                        return s.seriesLog.forEach(function(c, d) {
                            c.forEach(function(g) {
                                i.config.yaxis[d] && i.config.yaxis[d].logarithmic && (o = Math.max(g, o),
                                l = Math.min(g, l))
                            })
                        }),
                        n = Math.pow(s.yRange[r], Math.abs(l - o) / s.yRange[r]),
                        s.yLogRatio[r] = n / s.gridHeight,
                        n
                    }
                }),
                s.invalidLogScale ? e.slice() : s.yLogRatio
            }
        }], [{
            key: "checkComboSeries",
            value: function(e) {
                var t = !1
                  , i = 0
                  , s = 0;
                return e.length && void 0 !== e[0].type && e.forEach(function(a) {
                    "bar" !== a.type && "column" !== a.type && "candlestick" !== a.type && "boxPlot" !== a.type || i++,
                    void 0 !== a.type && s++
                }),
                s > 0 && (t = !0),
                {
                    comboBarCount: i,
                    comboCharts: t
                }
            }
        }, {
            key: "extendArrayProps",
            value: function(e, t, i) {
                return t.yaxis && (t = e.extendYAxis(t, i)),
                t.annotations && (t.annotations.yaxis && (t = e.extendYAxisAnnotations(t)),
                t.annotations.xaxis && (t = e.extendXAxisAnnotations(t)),
                t.annotations.points && (t = e.extendPointAnnotations(t))),
                t
            }
        }]),
        y
    }()
      , tt = function() {
        function y(e) {
            W(this, y),
            this.w = e.w,
            this.annoCtx = e
        }
        return V(y, [{
            key: "addYaxisAnnotation",
            value: function(e, t, i) {
                var s, a = this.w, r = e.strokeDashArray, n = this._getY1Y2("y1", e), o = e.label.text;
                if (null == e.y2) {
                    var l = this.annoCtx.graphics.drawLine(0 + e.offsetX, n + e.offsetY, this._getYAxisAnnotationWidth(e), n + e.offsetY, e.borderColor, r, e.borderWidth);
                    t.appendChild(l.node),
                    e.id && l.node.classList.add(e.id)
                } else {
                    if ((s = this._getY1Y2("y2", e)) > n) {
                        var c = n;
                        n = s,
                        s = c
                    }
                    var d = this.annoCtx.graphics.drawRect(0 + e.offsetX, s + e.offsetY, this._getYAxisAnnotationWidth(e), n - s, 0, e.fillColor, e.opacity, 1, e.borderColor, r);
                    d.node.classList.add("apexcharts-annotation-rect"),
                    d.attr("clip-path", "url(#gridRectMask".concat(a.globals.cuid, ")")),
                    t.appendChild(d.node),
                    e.id && d.node.classList.add(e.id)
                }
                var p = this.annoCtx.graphics.drawText({
                    x: ("right" === e.label.position ? a.globals.gridWidth : 0) + e.label.offsetX,
                    y: (s ?? n) + e.label.offsetY - 3,
                    text: o,
                    textAnchor: e.label.textAnchor,
                    fontSize: e.label.style.fontSize,
                    fontFamily: e.label.style.fontFamily,
                    fontWeight: e.label.style.fontWeight,
                    foreColor: e.label.style.color,
                    cssClass: "apexcharts-yaxis-annotation-label ".concat(e.label.style.cssClass, " ").concat(e.id ? e.id : "")
                });
                p.attr({
                    rel: i
                }),
                t.appendChild(p.node)
            }
        }, {
            key: "_getY1Y2",
            value: function(e, t) {
                var i, s = "y1" === e ? t.y : t.y2, a = this.w;
                if (this.annoCtx.invertAxis) {
                    var r = a.globals.labels.indexOf(s);
                    a.config.xaxis.convertedCatToNumeric && (r = a.globals.categoryLabels.indexOf(s));
                    var n = a.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(" + (r + 1) + ")");
                    n && (i = parseFloat(n.getAttribute("y")))
                } else {
                    var o;
                    o = a.config.yaxis[t.yAxisIndex].logarithmic ? (s = new xe(this.annoCtx.ctx).getLogVal(s, t.yAxisIndex)) / a.globals.yLogRatio[t.yAxisIndex] : (s - a.globals.minYArr[t.yAxisIndex]) / (a.globals.yRange[t.yAxisIndex] / a.globals.gridHeight),
                    i = a.globals.gridHeight - o,
                    a.config.yaxis[t.yAxisIndex] && a.config.yaxis[t.yAxisIndex].reversed && (i = o)
                }
                return i
            }
        }, {
            key: "_getYAxisAnnotationWidth",
            value: function(e) {
                var t = this.w;
                return (e.width.indexOf("%") > -1 ? t.globals.gridWidth * parseInt(e.width, 10) / 100 : parseInt(e.width, 10)) + e.offsetX
            }
        }, {
            key: "drawYAxisAnnotations",
            value: function() {
                var e = this
                  , t = this.w
                  , i = this.annoCtx.graphics.group({
                    class: "apexcharts-yaxis-annotations"
                });
                return t.config.annotations.yaxis.map(function(s, a) {
                    e.addYaxisAnnotation(s, i.node, a)
                }),
                i
            }
        }]),
        y
    }()
      , ei = function() {
        function y(e) {
            W(this, y),
            this.w = e.w,
            this.annoCtx = e
        }
        return V(y, [{
            key: "addPointAnnotation",
            value: function(e, t, i) {
                var s = this.w
                  , a = 0
                  , r = 0
                  , n = 0;
                this.annoCtx.invertAxis && console.warn("Point annotation is not supported in horizontal bar charts.");
                var o = parseFloat(e.y);
                if ("string" == typeof e.x || "category" === s.config.xaxis.type || s.config.xaxis.convertedCatToNumeric) {
                    var l = s.globals.labels.indexOf(e.x);
                    s.config.xaxis.convertedCatToNumeric && (l = s.globals.categoryLabels.indexOf(e.x)),
                    a = this.annoCtx.helpers.getStringX(e.x),
                    null === e.y && (o = s.globals.series[e.seriesIndex][l])
                } else
                    a = (e.x - s.globals.minX) / (s.globals.xRange / s.globals.gridWidth);
                for (var c, d = [], g = 0, p = 0; p <= e.seriesIndex; p++) {
                    var m = s.config.yaxis[p].seriesName;
                    if (m)
                        for (var x = p + 1; x <= e.seriesIndex; x++)
                            s.config.yaxis[x].seriesName === m && -1 === d.indexOf(m) && (g++,
                            d.push(m))
                }
                if (s.config.yaxis[e.yAxisIndex].logarithmic)
                    c = (o = new xe(this.annoCtx.ctx).getLogVal(o, e.yAxisIndex)) / s.globals.yLogRatio[e.yAxisIndex];
                else {
                    var v = e.yAxisIndex + g;
                    c = (o - s.globals.minYArr[v]) / (s.globals.yRange[v] / s.globals.gridHeight)
                }
                if (r = s.globals.gridHeight - c - parseFloat(e.label.style.fontSize) - e.marker.size,
                n = s.globals.gridHeight - c,
                s.config.yaxis[e.yAxisIndex] && s.config.yaxis[e.yAxisIndex].reversed && (r = c + parseFloat(e.label.style.fontSize) + e.marker.size,
                n = c),
                M.isNumber(a)) {
                    var k = {
                        pSize: e.marker.size,
                        pointStrokeWidth: e.marker.strokeWidth,
                        pointFillColor: e.marker.fillColor,
                        pointStrokeColor: e.marker.strokeColor,
                        shape: e.marker.shape,
                        pRadius: e.marker.radius,
                        class: "apexcharts-point-annotation-marker ".concat(e.marker.cssClass, " ").concat(e.id ? e.id : "")
                    }
                      , S = this.annoCtx.graphics.drawMarker(a + e.marker.offsetX, n + e.marker.offsetY, k);
                    t.appendChild(S.node);
                    var h = this.annoCtx.graphics.drawText({
                        x: a + e.label.offsetX,
                        y: r + e.label.offsetY,
                        text: e.label.text ? e.label.text : "",
                        textAnchor: e.label.textAnchor,
                        fontSize: e.label.style.fontSize,
                        fontFamily: e.label.style.fontFamily,
                        fontWeight: e.label.style.fontWeight,
                        foreColor: e.label.style.color,
                        cssClass: "apexcharts-point-annotation-label ".concat(e.label.style.cssClass, " ").concat(e.id ? e.id : "")
                    });
                    if (h.attr({
                        rel: i
                    }),
                    t.appendChild(h.node),
                    e.customSVG.SVG) {
                        var u = this.annoCtx.graphics.group({
                            class: "apexcharts-point-annotations-custom-svg " + e.customSVG.cssClass
                        });
                        u.attr({
                            transform: "translate(".concat(a + e.customSVG.offsetX, ", ").concat(r + e.customSVG.offsetY, ")")
                        }),
                        u.node.innerHTML = e.customSVG.SVG,
                        t.appendChild(u.node)
                    }
                    if (e.image.path) {
                        var b = e.image.width ? e.image.width : 20
                          , w = e.image.height ? e.image.height : 20;
                        S = this.annoCtx.addImage({
                            x: a + e.image.offsetX - b / 2,
                            y: r + e.image.offsetY - w / 2,
                            width: b,
                            height: w,
                            path: e.image.path,
                            appendTo: ".apexcharts-point-annotations"
                        })
                    }
                    e.mouseEnter && S.node.addEventListener("mouseenter", e.mouseEnter.bind(this, e)),
                    e.mouseLeave && S.node.addEventListener("mouseleave", e.mouseLeave.bind(this, e))
                }
            }
        }, {
            key: "drawPointAnnotations",
            value: function() {
                var e = this
                  , t = this.w
                  , i = this.annoCtx.graphics.group({
                    class: "apexcharts-point-annotations"
                });
                return t.config.annotations.points.map(function(s, a) {
                    e.addPointAnnotation(s, i.node, a)
                }),
                i
            }
        }]),
        y
    }()
      , Et = {
        name: "en",
        options: {
            months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            toolbar: {
                exportToSVG: "Download SVG",
                exportToPNG: "Download PNG",
                exportToCSV: "Download CSV",
                menu: "Menu",
                selection: "Selection",
                selectionZoom: "Selection Zoom",
                zoomIn: "Zoom In",
                zoomOut: "Zoom Out",
                pan: "Panning",
                reset: "Reset Zoom"
            }
        }
    }
      , He = function() {
        function y() {
            W(this, y),
            this.yAxis = {
                show: !0,
                showAlways: !1,
                showForNullSeries: !0,
                seriesName: void 0,
                opposite: !1,
                reversed: !1,
                logarithmic: !1,
                logBase: 10,
                tickAmount: void 0,
                forceNiceScale: !1,
                max: void 0,
                min: void 0,
                floating: !1,
                decimalsInFloat: void 0,
                labels: {
                    show: !0,
                    minWidth: 0,
                    maxWidth: 160,
                    offsetX: 0,
                    offsetY: 0,
                    align: void 0,
                    rotate: 0,
                    padding: 20,
                    style: {
                        colors: [],
                        fontSize: "11px",
                        fontWeight: 400,
                        fontFamily: void 0,
                        cssClass: ""
                    },
                    formatter: void 0
                },
                axisBorder: {
                    show: !1,
                    color: "#e0e0e0",
                    width: 1,
                    offsetX: 0,
                    offsetY: 0
                },
                axisTicks: {
                    show: !1,
                    color: "#e0e0e0",
                    width: 6,
                    offsetX: 0,
                    offsetY: 0
                },
                title: {
                    text: void 0,
                    rotate: -90,
                    offsetY: 0,
                    offsetX: 0,
                    style: {
                        color: void 0,
                        fontSize: "11px",
                        fontWeight: 900,
                        fontFamily: void 0,
                        cssClass: ""
                    }
                },
                tooltip: {
                    enabled: !1,
                    offsetX: 0
                },
                crosshairs: {
                    show: !0,
                    position: "front",
                    stroke: {
                        color: "#b6b6b6",
                        width: 1,
                        dashArray: 0
                    }
                }
            },
            this.pointAnnotation = {
                id: void 0,
                x: 0,
                y: null,
                yAxisIndex: 0,
                seriesIndex: 0,
                mouseEnter: void 0,
                mouseLeave: void 0,
                marker: {
                    size: 4,
                    fillColor: "#fff",
                    strokeWidth: 2,
                    strokeColor: "#333",
                    shape: "circle",
                    offsetX: 0,
                    offsetY: 0,
                    radius: 2,
                    cssClass: ""
                },
                label: {
                    borderColor: "#c2c2c2",
                    borderWidth: 1,
                    borderRadius: 2,
                    text: void 0,
                    textAnchor: "middle",
                    offsetX: 0,
                    offsetY: 0,
                    mouseEnter: void 0,
                    mouseLeave: void 0,
                    style: {
                        background: "#fff",
                        color: void 0,
                        fontSize: "11px",
                        fontFamily: void 0,
                        fontWeight: 400,
                        cssClass: "",
                        padding: {
                            left: 5,
                            right: 5,
                            top: 2,
                            bottom: 2
                        }
                    }
                },
                customSVG: {
                    SVG: void 0,
                    cssClass: void 0,
                    offsetX: 0,
                    offsetY: 0
                },
                image: {
                    path: void 0,
                    width: 20,
                    height: 20,
                    offsetX: 0,
                    offsetY: 0
                }
            },
            this.yAxisAnnotation = {
                id: void 0,
                y: 0,
                y2: null,
                strokeDashArray: 1,
                fillColor: "#c2c2c2",
                borderColor: "#c2c2c2",
                borderWidth: 1,
                opacity: .3,
                offsetX: 0,
                offsetY: 0,
                width: "100%",
                yAxisIndex: 0,
                label: {
                    borderColor: "#c2c2c2",
                    borderWidth: 1,
                    borderRadius: 2,
                    text: void 0,
                    textAnchor: "end",
                    position: "right",
                    offsetX: 0,
                    offsetY: -3,
                    mouseEnter: void 0,
                    mouseLeave: void 0,
                    style: {
                        background: "#fff",
                        color: void 0,
                        fontSize: "11px",
                        fontFamily: void 0,
                        fontWeight: 400,
                        cssClass: "",
                        padding: {
                            left: 5,
                            right: 5,
                            top: 2,
                            bottom: 2
                        }
                    }
                }
            },
            this.xAxisAnnotation = {
                id: void 0,
                x: 0,
                x2: null,
                strokeDashArray: 1,
                fillColor: "#c2c2c2",
                borderColor: "#c2c2c2",
                borderWidth: 1,
                opacity: .3,
                offsetX: 0,
                offsetY: 0,
                label: {
                    borderColor: "#c2c2c2",
                    borderWidth: 1,
                    borderRadius: 2,
                    text: void 0,
                    textAnchor: "middle",
                    orientation: "vertical",
                    position: "top",
                    offsetX: 0,
                    offsetY: 0,
                    mouseEnter: void 0,
                    mouseLeave: void 0,
                    style: {
                        background: "#fff",
                        color: void 0,
                        fontSize: "11px",
                        fontFamily: void 0,
                        fontWeight: 400,
                        cssClass: "",
                        padding: {
                            left: 5,
                            right: 5,
                            top: 2,
                            bottom: 2
                        }
                    }
                }
            },
            this.text = {
                x: 0,
                y: 0,
                text: "",
                textAnchor: "start",
                foreColor: void 0,
                fontSize: "13px",
                fontFamily: void 0,
                fontWeight: 400,
                appendTo: ".apexcharts-annotations",
                backgroundColor: "transparent",
                borderColor: "#c2c2c2",
                borderRadius: 0,
                borderWidth: 0,
                paddingLeft: 4,
                paddingRight: 4,
                paddingTop: 2,
                paddingBottom: 2
            }
        }
        return V(y, [{
            key: "init",
            value: function() {
                return {
                    annotations: {
                        position: "front",
                        yaxis: [this.yAxisAnnotation],
                        xaxis: [this.xAxisAnnotation],
                        points: [this.pointAnnotation],
                        texts: [],
                        images: [],
                        shapes: []
                    },
                    chart: {
                        animations: {
                            enabled: !0,
                            easing: "easeinout",
                            speed: 800,
                            animateGradually: {
                                delay: 150,
                                enabled: !0
                            },
                            dynamicAnimation: {
                                enabled: !0,
                                speed: 350
                            }
                        },
                        background: "transparent",
                        locales: [Et],
                        defaultLocale: "en",
                        dropShadow: {
                            enabled: !1,
                            enabledOnSeries: void 0,
                            top: 2,
                            left: 2,
                            blur: 4,
                            color: "#000",
                            opacity: .35
                        },
                        events: {
                            animationEnd: void 0,
                            beforeMount: void 0,
                            mounted: void 0,
                            updated: void 0,
                            click: void 0,
                            mouseMove: void 0,
                            mouseLeave: void 0,
                            legendClick: void 0,
                            markerClick: void 0,
                            selection: void 0,
                            dataPointSelection: void 0,
                            dataPointMouseEnter: void 0,
                            dataPointMouseLeave: void 0,
                            beforeZoom: void 0,
                            beforeResetZoom: void 0,
                            zoomed: void 0,
                            scrolled: void 0,
                            brushScrolled: void 0
                        },
                        foreColor: "#373d3f",
                        fontFamily: "Helvetica, Arial, sans-serif",
                        height: "auto",
                        parentHeightOffset: 15,
                        redrawOnParentResize: !0,
                        redrawOnWindowResize: !0,
                        id: void 0,
                        group: void 0,
                        offsetX: 0,
                        offsetY: 0,
                        selection: {
                            enabled: !1,
                            type: "x",
                            fill: {
                                color: "#24292e",
                                opacity: .1
                            },
                            stroke: {
                                width: 1,
                                color: "#24292e",
                                opacity: .4,
                                dashArray: 3
                            },
                            xaxis: {
                                min: void 0,
                                max: void 0
                            },
                            yaxis: {
                                min: void 0,
                                max: void 0
                            }
                        },
                        sparkline: {
                            enabled: !1
                        },
                        brush: {
                            enabled: !1,
                            autoScaleYaxis: !0,
                            target: void 0
                        },
                        stacked: !1,
                        stackType: "normal",
                        toolbar: {
                            show: !0,
                            offsetX: 0,
                            offsetY: 0,
                            tools: {
                                download: !0,
                                selection: !0,
                                zoom: !0,
                                zoomin: !0,
                                zoomout: !0,
                                pan: !0,
                                reset: !0,
                                customIcons: []
                            },
                            export: {
                                csv: {
                                    filename: void 0,
                                    columnDelimiter: ",",
                                    headerCategory: "category",
                                    headerValue: "value",
                                    dateFormatter: function(e) {
                                        return new Date(e).toDateString()
                                    }
                                },
                                png: {
                                    filename: void 0
                                },
                                svg: {
                                    filename: void 0
                                }
                            },
                            autoSelected: "zoom"
                        },
                        type: "line",
                        width: "100%",
                        zoom: {
                            enabled: !0,
                            type: "x",
                            autoScaleYaxis: !1,
                            zoomedArea: {
                                fill: {
                                    color: "#90CAF9",
                                    opacity: .4
                                },
                                stroke: {
                                    color: "#0D47A1",
                                    opacity: .4,
                                    width: 1
                                }
                            }
                        }
                    },
                    plotOptions: {
                        area: {
                            fillTo: "origin"
                        },
                        bar: {
                            horizontal: !1,
                            columnWidth: "70%",
                            barHeight: "70%",
                            distributed: !1,
                            borderRadius: 0,
                            rangeBarOverlap: !0,
                            rangeBarGroupRows: !1,
                            colors: {
                                ranges: [],
                                backgroundBarColors: [],
                                backgroundBarOpacity: 1,
                                backgroundBarRadius: 0
                            },
                            dataLabels: {
                                position: "top",
                                maxItems: 100,
                                hideOverflowingLabels: !0,
                                orientation: "horizontal"
                            }
                        },
                        bubble: {
                            minBubbleRadius: void 0,
                            maxBubbleRadius: void 0
                        },
                        candlestick: {
                            colors: {
                                upward: "#00B746",
                                downward: "#EF403C"
                            },
                            wick: {
                                useFillColor: !0
                            }
                        },
                        boxPlot: {
                            colors: {
                                upper: "#00E396",
                                lower: "#008FFB"
                            }
                        },
                        heatmap: {
                            radius: 2,
                            enableShades: !0,
                            shadeIntensity: .5,
                            reverseNegativeShade: !1,
                            distributed: !1,
                            useFillColorAsStroke: !1,
                            colorScale: {
                                inverse: !1,
                                ranges: [],
                                min: void 0,
                                max: void 0
                            }
                        },
                        treemap: {
                            enableShades: !0,
                            shadeIntensity: .5,
                            distributed: !1,
                            reverseNegativeShade: !1,
                            useFillColorAsStroke: !1,
                            colorScale: {
                                inverse: !1,
                                ranges: [],
                                min: void 0,
                                max: void 0
                            }
                        },
                        radialBar: {
                            inverseOrder: !1,
                            startAngle: 0,
                            endAngle: 360,
                            offsetX: 0,
                            offsetY: 0,
                            hollow: {
                                margin: 5,
                                size: "50%",
                                background: "transparent",
                                image: void 0,
                                imageWidth: 150,
                                imageHeight: 150,
                                imageOffsetX: 0,
                                imageOffsetY: 0,
                                imageClipped: !0,
                                position: "front",
                                dropShadow: {
                                    enabled: !1,
                                    top: 0,
                                    left: 0,
                                    blur: 3,
                                    color: "#000",
                                    opacity: .5
                                }
                            },
                            track: {
                                show: !0,
                                startAngle: void 0,
                                endAngle: void 0,
                                background: "#f2f2f2",
                                strokeWidth: "97%",
                                opacity: 1,
                                margin: 5,
                                dropShadow: {
                                    enabled: !1,
                                    top: 0,
                                    left: 0,
                                    blur: 3,
                                    color: "#000",
                                    opacity: .5
                                }
                            },
                            dataLabels: {
                                show: !0,
                                name: {
                                    show: !0,
                                    fontSize: "16px",
                                    fontFamily: void 0,
                                    fontWeight: 600,
                                    color: void 0,
                                    offsetY: 0,
                                    formatter: function(e) {
                                        return e
                                    }
                                },
                                value: {
                                    show: !0,
                                    fontSize: "14px",
                                    fontFamily: void 0,
                                    fontWeight: 400,
                                    color: void 0,
                                    offsetY: 16,
                                    formatter: function(e) {
                                        return e + "%"
                                    }
                                },
                                total: {
                                    show: !1,
                                    label: "Total",
                                    fontSize: "16px",
                                    fontWeight: 600,
                                    fontFamily: void 0,
                                    color: void 0,
                                    formatter: function(e) {
                                        return e.globals.seriesTotals.reduce(function(t, i) {
                                            return t + i
                                        }, 0) / e.globals.series.length + "%"
                                    }
                                }
                            }
                        },
                        pie: {
                            customScale: 1,
                            offsetX: 0,
                            offsetY: 0,
                            startAngle: 0,
                            endAngle: 360,
                            expandOnClick: !0,
                            dataLabels: {
                                offset: 0,
                                minAngleToShowLabel: 10
                            },
                            donut: {
                                size: "65%",
                                background: "transparent",
                                labels: {
                                    show: !1,
                                    name: {
                                        show: !0,
                                        fontSize: "16px",
                                        fontFamily: void 0,
                                        fontWeight: 600,
                                        color: void 0,
                                        offsetY: -10,
                                        formatter: function(e) {
                                            return e
                                        }
                                    },
                                    value: {
                                        show: !0,
                                        fontSize: "20px",
                                        fontFamily: void 0,
                                        fontWeight: 400,
                                        color: void 0,
                                        offsetY: 10,
                                        formatter: function(e) {
                                            return e
                                        }
                                    },
                                    total: {
                                        show: !1,
                                        showAlways: !1,
                                        label: "Total",
                                        fontSize: "16px",
                                        fontWeight: 400,
                                        fontFamily: void 0,
                                        color: void 0,
                                        formatter: function(e) {
                                            return e.globals.seriesTotals.reduce(function(t, i) {
                                                return t + i
                                            }, 0)
                                        }
                                    }
                                }
                            }
                        },
                        polarArea: {
                            rings: {
                                strokeWidth: 1,
                                strokeColor: "#e8e8e8"
                            },
                            spokes: {
                                strokeWidth: 1,
                                connectorColors: "#e8e8e8"
                            }
                        },
                        radar: {
                            size: void 0,
                            offsetX: 0,
                            offsetY: 0,
                            polygons: {
                                strokeWidth: 1,
                                strokeColors: "#e8e8e8",
                                connectorColors: "#e8e8e8",
                                fill: {
                                    colors: void 0
                                }
                            }
                        }
                    },
                    colors: void 0,
                    dataLabels: {
                        enabled: !0,
                        enabledOnSeries: void 0,
                        formatter: function(e) {
                            return null !== e ? e : ""
                        },
                        textAnchor: "middle",
                        distributed: !1,
                        offsetX: 0,
                        offsetY: 0,
                        style: {
                            fontSize: "12px",
                            fontFamily: void 0,
                            fontWeight: 600,
                            colors: void 0
                        },
                        background: {
                            enabled: !0,
                            foreColor: "#fff",
                            borderRadius: 2,
                            padding: 4,
                            opacity: .9,
                            borderWidth: 1,
                            borderColor: "#fff",
                            dropShadow: {
                                enabled: !1,
                                top: 1,
                                left: 1,
                                blur: 1,
                                color: "#000",
                                opacity: .45
                            }
                        },
                        dropShadow: {
                            enabled: !1,
                            top: 1,
                            left: 1,
                            blur: 1,
                            color: "#000",
                            opacity: .45
                        }
                    },
                    fill: {
                        type: "solid",
                        colors: void 0,
                        opacity: .85,
                        gradient: {
                            shade: "dark",
                            type: "horizontal",
                            shadeIntensity: .5,
                            gradientToColors: void 0,
                            inverseColors: !0,
                            opacityFrom: 1,
                            opacityTo: 1,
                            stops: [0, 50, 100],
                            colorStops: []
                        },
                        image: {
                            src: [],
                            width: void 0,
                            height: void 0
                        },
                        pattern: {
                            style: "squares",
                            width: 6,
                            height: 6,
                            strokeWidth: 2
                        }
                    },
                    forecastDataPoints: {
                        count: 0,
                        fillOpacity: .5,
                        strokeWidth: void 0,
                        dashArray: 4
                    },
                    grid: {
                        show: !0,
                        borderColor: "#e0e0e0",
                        strokeDashArray: 0,
                        position: "back",
                        xaxis: {
                            lines: {
                                show: !1
                            }
                        },
                        yaxis: {
                            lines: {
                                show: !0
                            }
                        },
                        row: {
                            colors: void 0,
                            opacity: .5
                        },
                        column: {
                            colors: void 0,
                            opacity: .5
                        },
                        padding: {
                            top: 0,
                            right: 10,
                            bottom: 0,
                            left: 12
                        }
                    },
                    labels: [],
                    legend: {
                        show: !0,
                        showForSingleSeries: !1,
                        showForNullSeries: !0,
                        showForZeroSeries: !0,
                        floating: !1,
                        position: "bottom",
                        horizontalAlign: "center",
                        inverseOrder: !1,
                        fontSize: "12px",
                        fontFamily: void 0,
                        fontWeight: 400,
                        width: void 0,
                        height: void 0,
                        formatter: void 0,
                        tooltipHoverFormatter: void 0,
                        offsetX: -20,
                        offsetY: 4,
                        customLegendItems: [],
                        labels: {
                            colors: void 0,
                            useSeriesColors: !1
                        },
                        markers: {
                            width: 12,
                            height: 12,
                            strokeWidth: 0,
                            fillColors: void 0,
                            strokeColor: "#fff",
                            radius: 12,
                            customHTML: void 0,
                            offsetX: 0,
                            offsetY: 0,
                            onClick: void 0
                        },
                        itemMargin: {
                            horizontal: 5,
                            vertical: 2
                        },
                        onItemClick: {
                            toggleDataSeries: !0
                        },
                        onItemHover: {
                            highlightDataSeries: !0
                        }
                    },
                    markers: {
                        discrete: [],
                        size: 0,
                        colors: void 0,
                        strokeColors: "#fff",
                        strokeWidth: 2,
                        strokeOpacity: .9,
                        strokeDashArray: 0,
                        fillOpacity: 1,
                        shape: "circle",
                        width: 8,
                        height: 8,
                        radius: 2,
                        offsetX: 0,
                        offsetY: 0,
                        onClick: void 0,
                        onDblClick: void 0,
                        showNullDataPoints: !0,
                        hover: {
                            size: void 0,
                            sizeOffset: 3
                        }
                    },
                    noData: {
                        text: void 0,
                        align: "center",
                        verticalAlign: "middle",
                        offsetX: 0,
                        offsetY: 0,
                        style: {
                            color: void 0,
                            fontSize: "14px",
                            fontFamily: void 0
                        }
                    },
                    responsive: [],
                    series: void 0,
                    states: {
                        normal: {
                            filter: {
                                type: "none",
                                value: 0
                            }
                        },
                        hover: {
                            filter: {
                                type: "lighten",
                                value: .1
                            }
                        },
                        active: {
                            allowMultipleDataPointsSelection: !1,
                            filter: {
                                type: "darken",
                                value: .5
                            }
                        }
                    },
                    title: {
                        text: void 0,
                        align: "left",
                        margin: 5,
                        offsetX: 0,
                        offsetY: 0,
                        floating: !1,
                        style: {
                            fontSize: "14px",
                            fontWeight: 900,
                            fontFamily: void 0,
                            color: void 0
                        }
                    },
                    subtitle: {
                        text: void 0,
                        align: "left",
                        margin: 5,
                        offsetX: 0,
                        offsetY: 30,
                        floating: !1,
                        style: {
                            fontSize: "12px",
                            fontWeight: 400,
                            fontFamily: void 0,
                            color: void 0
                        }
                    },
                    stroke: {
                        show: !0,
                        curve: "smooth",
                        lineCap: "butt",
                        width: 2,
                        colors: void 0,
                        dashArray: 0
                    },
                    tooltip: {
                        enabled: !0,
                        enabledOnSeries: void 0,
                        shared: !0,
                        followCursor: !1,
                        intersect: !1,
                        inverseOrder: !1,
                        custom: void 0,
                        fillSeriesColor: !1,
                        theme: "light",
                        style: {
                            fontSize: "12px",
                            fontFamily: void 0
                        },
                        onDatasetHover: {
                            highlightDataSeries: !1
                        },
                        x: {
                            show: !0,
                            format: "dd MMM",
                            formatter: void 0
                        },
                        y: {
                            formatter: void 0,
                            title: {
                                formatter: function(e) {
                                    return e ? e + ": " : ""
                                }
                            }
                        },
                        z: {
                            formatter: void 0,
                            title: "Size: "
                        },
                        marker: {
                            show: !0,
                            fillColors: void 0
                        },
                        items: {
                            display: "flex"
                        },
                        fixed: {
                            enabled: !1,
                            position: "topRight",
                            offsetX: 0,
                            offsetY: 0
                        }
                    },
                    xaxis: {
                        type: "category",
                        categories: [],
                        convertedCatToNumeric: !1,
                        offsetX: 0,
                        offsetY: 0,
                        overwriteCategories: void 0,
                        labels: {
                            show: !0,
                            rotate: -45,
                            rotateAlways: !1,
                            hideOverlappingLabels: !0,
                            trim: !1,
                            minHeight: void 0,
                            maxHeight: 120,
                            showDuplicates: !0,
                            style: {
                                colors: [],
                                fontSize: "12px",
                                fontWeight: 400,
                                fontFamily: void 0,
                                cssClass: ""
                            },
                            offsetX: 0,
                            offsetY: 0,
                            format: void 0,
                            formatter: void 0,
                            datetimeUTC: !0,
                            datetimeFormatter: {
                                year: "yyyy",
                                month: "MMM 'yy",
                                day: "dd MMM",
                                hour: "HH:mm",
                                minute: "HH:mm:ss",
                                second: "HH:mm:ss"
                            }
                        },
                        axisBorder: {
                            show: !0,
                            color: "#e0e0e0",
                            width: "100%",
                            height: 1,
                            offsetX: 0,
                            offsetY: 0
                        },
                        axisTicks: {
                            show: !0,
                            color: "#e0e0e0",
                            height: 6,
                            offsetX: 0,
                            offsetY: 0
                        },
                        tickAmount: void 0,
                        tickPlacement: "on",
                        min: void 0,
                        max: void 0,
                        range: void 0,
                        floating: !1,
                        decimalsInFloat: void 0,
                        position: "bottom",
                        title: {
                            text: void 0,
                            offsetX: 0,
                            offsetY: 0,
                            style: {
                                color: void 0,
                                fontSize: "12px",
                                fontWeight: 900,
                                fontFamily: void 0,
                                cssClass: ""
                            }
                        },
                        crosshairs: {
                            show: !0,
                            width: 1,
                            position: "back",
                            opacity: .9,
                            stroke: {
                                color: "#b6b6b6",
                                width: 1,
                                dashArray: 3
                            },
                            fill: {
                                type: "solid",
                                color: "#B1B9C4",
                                gradient: {
                                    colorFrom: "#D8E3F0",
                                    colorTo: "#BED1E6",
                                    stops: [0, 100],
                                    opacityFrom: .4,
                                    opacityTo: .5
                                }
                            },
                            dropShadow: {
                                enabled: !1,
                                left: 0,
                                top: 0,
                                blur: 1,
                                opacity: .4
                            }
                        },
                        tooltip: {
                            enabled: !0,
                            offsetY: 0,
                            formatter: void 0,
                            style: {
                                fontSize: "12px",
                                fontFamily: void 0
                            }
                        }
                    },
                    yaxis: this.yAxis,
                    theme: {
                        mode: "light",
                        palette: "palette1",
                        monochrome: {
                            enabled: !1,
                            color: "#008FFB",
                            shadeTo: "light",
                            shadeIntensity: .65
                        }
                    }
                }
            }
        }]),
        y
    }()
      , Se = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w,
            this.graphics = new D(this.ctx),
            this.w.globals.isBarHorizontal && (this.invertAxis = !0),
            this.helpers = new Ee(this),
            this.xAxisAnnotations = new ke(this),
            this.yAxisAnnotations = new tt(this),
            this.pointsAnnotations = new ei(this),
            this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = !0),
            this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints
        }
        return V(y, [{
            key: "drawAxesAnnotations",
            value: function() {
                var e = this.w;
                if (e.globals.axisCharts) {
                    for (var t = this.yAxisAnnotations.drawYAxisAnnotations(), i = this.xAxisAnnotations.drawXAxisAnnotations(), s = this.pointsAnnotations.drawPointAnnotations(), a = e.config.chart.animations.enabled, r = [t, i, s], n = [i.node, t.node, s.node], o = 0; o < 3; o++)
                        e.globals.dom.elGraphical.add(r[o]),
                        !a || e.globals.resized || e.globals.dataChanged || "scatter" !== e.config.chart.type && "bubble" !== e.config.chart.type && e.globals.dataPoints > 1 && n[o].classList.add("apexcharts-element-hidden"),
                        e.globals.delayedElements.push({
                            el: n[o],
                            index: 0
                        });
                    this.helpers.annotationsBackground()
                }
            }
        }, {
            key: "drawImageAnnos",
            value: function() {
                var e = this;
                this.w.config.annotations.images.map(function(t, i) {
                    e.addImage(t, i)
                })
            }
        }, {
            key: "drawTextAnnos",
            value: function() {
                var e = this;
                this.w.config.annotations.texts.map(function(t, i) {
                    e.addText(t, i)
                })
            }
        }, {
            key: "addXaxisAnnotation",
            value: function(e, t, i) {
                this.xAxisAnnotations.addXaxisAnnotation(e, t, i)
            }
        }, {
            key: "addYaxisAnnotation",
            value: function(e, t, i) {
                this.yAxisAnnotations.addYaxisAnnotation(e, t, i)
            }
        }, {
            key: "addPointAnnotation",
            value: function(e, t, i) {
                this.pointsAnnotations.addPointAnnotation(e, t, i)
            }
        }, {
            key: "addText",
            value: function(e, t) {
                var a = e.text
                  , g = e.backgroundColor
                  , p = e.borderWidth
                  , m = e.strokeDashArray
                  , x = e.borderRadius
                  , v = e.borderColor
                  , k = e.appendTo
                  , S = void 0 === k ? ".apexcharts-annotations" : k
                  , C = e.paddingLeft
                  , h = void 0 === C ? 4 : C
                  , u = e.paddingRight
                  , b = void 0 === u ? 4 : u
                  , w = e.paddingBottom
                  , _ = void 0 === w ? 2 : w
                  , X = e.paddingTop
                  , I = void 0 === X ? 2 : X
                  , R = this.w
                  , H = this.graphics.drawText({
                    x: e.x,
                    y: e.y,
                    text: a,
                    textAnchor: e.textAnchor || "start",
                    fontSize: e.fontSize || "12px",
                    fontWeight: e.fontWeight || "regular",
                    fontFamily: e.fontFamily || R.config.chart.fontFamily,
                    foreColor: e.foreColor || R.config.chart.foreColor,
                    cssClass: e.cssClass
                })
                  , G = R.globals.dom.baseEl.querySelector(S);
                G && G.appendChild(H.node);
                var ie = H.bbox();
                if (a) {
                    var ne = this.graphics.drawRect(ie.x - h, ie.y - I, ie.width + h + b, ie.height + _ + I, x, g || "transparent", 1, p, v, m);
                    G.insertBefore(ne.node, H.node)
                }
            }
        }, {
            key: "addImage",
            value: function(e, t) {
                var i = this.w
                  , a = e.x
                  , r = void 0 === a ? 0 : a
                  , n = e.y
                  , o = void 0 === n ? 0 : n
                  , l = e.width
                  , c = void 0 === l ? 20 : l
                  , d = e.height
                  , g = void 0 === d ? 20 : d
                  , p = e.appendTo
                  , m = void 0 === p ? ".apexcharts-annotations" : p
                  , x = i.globals.dom.Paper.image(e.path);
                x.size(c, g).move(r, o);
                var v = i.globals.dom.baseEl.querySelector(m);
                return v && v.appendChild(x.node),
                x
            }
        }, {
            key: "addXaxisAnnotationExternal",
            value: function(e, t, i) {
                return this.addAnnotationExternal({
                    params: e,
                    pushToMemory: t,
                    context: i,
                    type: "xaxis",
                    contextMethod: i.addXaxisAnnotation
                }),
                i
            }
        }, {
            key: "addYaxisAnnotationExternal",
            value: function(e, t, i) {
                return this.addAnnotationExternal({
                    params: e,
                    pushToMemory: t,
                    context: i,
                    type: "yaxis",
                    contextMethod: i.addYaxisAnnotation
                }),
                i
            }
        }, {
            key: "addPointAnnotationExternal",
            value: function(e, t, i) {
                return void 0 === this.invertAxis && (this.invertAxis = i.w.globals.isBarHorizontal),
                this.addAnnotationExternal({
                    params: e,
                    pushToMemory: t,
                    context: i,
                    type: "point",
                    contextMethod: i.addPointAnnotation
                }),
                i
            }
        }, {
            key: "addAnnotationExternal",
            value: function(e) {
                var t = e.params
                  , i = e.pushToMemory
                  , s = e.context
                  , a = e.type
                  , r = e.contextMethod
                  , n = s
                  , o = n.w
                  , l = o.globals.dom.baseEl.querySelector(".apexcharts-".concat(a, "-annotations"))
                  , c = l.childNodes.length + 1
                  , d = new He
                  , g = Object.assign({}, "xaxis" === a ? d.xAxisAnnotation : "yaxis" === a ? d.yAxisAnnotation : d.pointAnnotation)
                  , p = M.extend(g, t);
                switch (a) {
                case "xaxis":
                    this.addXaxisAnnotation(p, l, c);
                    break;
                case "yaxis":
                    this.addYaxisAnnotation(p, l, c);
                    break;
                case "point":
                    this.addPointAnnotation(p, l, c)
                }
                var m = o.globals.dom.baseEl.querySelector(".apexcharts-".concat(a, "-annotations .apexcharts-").concat(a, "-annotation-label[rel='").concat(c, "']"))
                  , x = this.helpers.addBackgroundToAnno(m, p);
                return x && l.insertBefore(x.node, m),
                i && o.globals.memory.methodsToExec.push({
                    context: n,
                    id: p.id ? p.id : M.randomId(),
                    method: r,
                    label: "addAnnotation",
                    params: t
                }),
                s
            }
        }, {
            key: "clearAnnotations",
            value: function(e) {
                var t = e.w
                  , i = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations");
                t.globals.memory.methodsToExec.map(function(s, a) {
                    "addText" !== s.label && "addAnnotation" !== s.label || t.globals.memory.methodsToExec.splice(a, 1)
                }),
                i = M.listToArray(i),
                Array.prototype.forEach.call(i, function(s) {
                    for (; s.firstChild; )
                        s.removeChild(s.firstChild)
                })
            }
        }, {
            key: "removeAnnotation",
            value: function(e, t) {
                var i = e.w
                  , s = i.globals.dom.baseEl.querySelectorAll(".".concat(t));
                s && (i.globals.memory.methodsToExec.map(function(a, r) {
                    a.id === t && i.globals.memory.methodsToExec.splice(r, 1)
                }),
                Array.prototype.forEach.call(s, function(a) {
                    a.parentElement.removeChild(a)
                }))
            }
        }]),
        y
    }()
      , ue = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w,
            this.opts = null,
            this.seriesIndex = 0
        }
        return V(y, [{
            key: "clippedImgArea",
            value: function(e) {
                var t = this.w
                  , i = t.config
                  , s = parseInt(t.globals.gridWidth, 10)
                  , a = parseInt(t.globals.gridHeight, 10)
                  , r = s > a ? s : a
                  , n = e.image
                  , o = 0
                  , l = 0;
                void 0 === e.width && void 0 === e.height ? void 0 !== i.fill.image.width && void 0 !== i.fill.image.height ? (o = i.fill.image.width + 1,
                l = i.fill.image.height) : (o = r + 1,
                l = r) : (o = e.width,
                l = e.height);
                var c = document.createElementNS(t.globals.SVGNS, "pattern");
                D.setAttrs(c, {
                    id: e.patternID,
                    patternUnits: e.patternUnits ? e.patternUnits : "userSpaceOnUse",
                    width: o + "px",
                    height: l + "px"
                });
                var d = document.createElementNS(t.globals.SVGNS, "image");
                c.appendChild(d),
                d.setAttributeNS(window.SVG.xlink, "href", n),
                D.setAttrs(d, {
                    x: 0,
                    y: 0,
                    preserveAspectRatio: "none",
                    width: o + "px",
                    height: l + "px"
                }),
                d.style.opacity = e.opacity,
                t.globals.dom.elDefs.node.appendChild(c)
            }
        }, {
            key: "getSeriesIndex",
            value: function(e) {
                var t = this.w;
                return this.seriesIndex = ("bar" === t.config.chart.type || "rangeBar" === t.config.chart.type) && t.config.plotOptions.bar.distributed || "heatmap" === t.config.chart.type || "treemap" === t.config.chart.type ? e.seriesNumber : e.seriesNumber % t.globals.series.length,
                this.seriesIndex
            }
        }, {
            key: "fillPath",
            value: function(e) {
                var t = this.w;
                this.opts = e;
                var i, s, a, r = this.w.config;
                this.seriesIndex = this.getSeriesIndex(e);
                var n = this.getFillColors()[this.seriesIndex];
                void 0 !== t.globals.seriesColors[this.seriesIndex] && (n = t.globals.seriesColors[this.seriesIndex]),
                "function" == typeof n && (n = n({
                    seriesIndex: this.seriesIndex,
                    dataPointIndex: e.dataPointIndex,
                    value: e.value,
                    w: t
                }));
                var o = this.getFillType(this.seriesIndex)
                  , l = Array.isArray(r.fill.opacity) ? r.fill.opacity[this.seriesIndex] : r.fill.opacity;
                e.color && (n = e.color);
                var c = n;
                if (-1 === n.indexOf("rgb") ? n.length < 9 && (c = M.hexToRgba(n, l)) : n.indexOf("rgba") > -1 && (l = M.getOpacityFromRGBA(n)),
                e.opacity && (l = e.opacity),
                "pattern" === o && (s = this.handlePatternFill(s, n, l, c)),
                "gradient" === o && (a = this.handleGradientFill(n, l, this.seriesIndex)),
                "image" === o) {
                    var d = r.fill.image.src
                      , g = e.patternID ? e.patternID : "";
                    this.clippedImgArea({
                        opacity: l,
                        image: Array.isArray(d) ? e.seriesNumber < d.length ? d[e.seriesNumber] : d[0] : d,
                        width: e.width ? e.width : void 0,
                        height: e.height ? e.height : void 0,
                        patternUnits: e.patternUnits,
                        patternID: "pattern".concat(t.globals.cuid).concat(e.seriesNumber + 1).concat(g)
                    }),
                    i = "url(#pattern".concat(t.globals.cuid).concat(e.seriesNumber + 1).concat(g, ")")
                } else
                    i = "gradient" === o ? a : "pattern" === o ? s : c;
                return e.solid && (i = c),
                i
            }
        }, {
            key: "getFillType",
            value: function(e) {
                var t = this.w;
                return Array.isArray(t.config.fill.type) ? t.config.fill.type[e] : t.config.fill.type
            }
        }, {
            key: "getFillColors",
            value: function() {
                var e = this.w
                  , t = e.config
                  , i = this.opts
                  , s = [];
                return e.globals.comboCharts ? "line" === e.config.series[this.seriesIndex].type ? Array.isArray(e.globals.stroke.colors) ? s = e.globals.stroke.colors : s.push(e.globals.stroke.colors) : Array.isArray(e.globals.fill.colors) ? s = e.globals.fill.colors : s.push(e.globals.fill.colors) : "line" === t.chart.type ? Array.isArray(e.globals.stroke.colors) ? s = e.globals.stroke.colors : s.push(e.globals.stroke.colors) : Array.isArray(e.globals.fill.colors) ? s = e.globals.fill.colors : s.push(e.globals.fill.colors),
                void 0 !== i.fillColors && (s = [],
                Array.isArray(i.fillColors) ? s = i.fillColors.slice() : s.push(i.fillColors)),
                s
            }
        }, {
            key: "handlePatternFill",
            value: function(e, t, i, s) {
                var a = this.w.config
                  , r = this.opts
                  , n = new D(this.ctx)
                  , o = void 0 === a.fill.pattern.strokeWidth ? Array.isArray(a.stroke.width) ? a.stroke.width[this.seriesIndex] : a.stroke.width : Array.isArray(a.fill.pattern.strokeWidth) ? a.fill.pattern.strokeWidth[this.seriesIndex] : a.fill.pattern.strokeWidth
                  , l = t;
                return Array.isArray(a.fill.pattern.style) ? void 0 !== a.fill.pattern.style[r.seriesNumber] ? n.drawPattern(a.fill.pattern.style[r.seriesNumber], a.fill.pattern.width, a.fill.pattern.height, l, o, i) : s : n.drawPattern(a.fill.pattern.style, a.fill.pattern.width, a.fill.pattern.height, l, o, i)
            }
        }, {
            key: "handleGradientFill",
            value: function(e, t, i) {
                var s, a = this.w.config, r = this.opts, n = new D(this.ctx), o = new M, l = a.fill.gradient.type, c = e, d = void 0 === a.fill.gradient.opacityFrom ? t : Array.isArray(a.fill.gradient.opacityFrom) ? a.fill.gradient.opacityFrom[i] : a.fill.gradient.opacityFrom;
                c.indexOf("rgba") > -1 && (d = M.getOpacityFromRGBA(c));
                var g = void 0 === a.fill.gradient.opacityTo ? t : Array.isArray(a.fill.gradient.opacityTo) ? a.fill.gradient.opacityTo[i] : a.fill.gradient.opacityTo;
                if (void 0 === a.fill.gradient.gradientToColors || 0 === a.fill.gradient.gradientToColors.length)
                    s = o.shadeColor("dark" === a.fill.gradient.shade ? -1 * parseFloat(a.fill.gradient.shadeIntensity) : parseFloat(a.fill.gradient.shadeIntensity), e.indexOf("rgb") > -1 ? M.rgb2hex(e) : e);
                else if (a.fill.gradient.gradientToColors[r.seriesNumber]) {
                    var p = a.fill.gradient.gradientToColors[r.seriesNumber];
                    s = p,
                    p.indexOf("rgba") > -1 && (g = M.getOpacityFromRGBA(p))
                } else
                    s = e;
                if (a.fill.gradient.inverseColors) {
                    var m = c;
                    c = s,
                    s = m
                }
                return c.indexOf("rgb") > -1 && (c = M.rgb2hex(c)),
                s.indexOf("rgb") > -1 && (s = M.rgb2hex(s)),
                n.drawGradient(l, c, s, d, g, r.size, a.fill.gradient.stops, a.fill.gradient.colorStops, i)
            }
        }]),
        y
    }()
      , Ae = function() {
        function y(e, t) {
            W(this, y),
            this.ctx = e,
            this.w = e.w
        }
        return V(y, [{
            key: "setGlobalMarkerSize",
            value: function() {
                var e = this.w;
                if (e.globals.markers.size = Array.isArray(e.config.markers.size) ? e.config.markers.size : [e.config.markers.size],
                e.globals.markers.size.length > 0) {
                    if (e.globals.markers.size.length < e.globals.series.length + 1)
                        for (var t = 0; t <= e.globals.series.length; t++)
                            void 0 === e.globals.markers.size[t] && e.globals.markers.size.push(e.globals.markers.size[0])
                } else
                    e.globals.markers.size = e.config.series.map(function(i) {
                        return e.config.markers.size
                    })
            }
        }, {
            key: "plotChartMarkers",
            value: function(e, t, i, s) {
                var a, r = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], n = this.w, o = t, l = e, c = null, d = new D(this.ctx);
                if ((n.globals.markers.size[t] > 0 || r) && (c = d.group({
                    class: r ? "" : "apexcharts-series-markers"
                })).attr("clip-path", "url(#gridRectMarkerMask".concat(n.globals.cuid, ")")),
                Array.isArray(l.x))
                    for (var g = 0; g < l.x.length; g++) {
                        var p = i;
                        1 === i && 0 === g && (p = 0),
                        1 === i && 1 === g && (p = 1);
                        var m = "apexcharts-marker";
                        "line" !== n.config.chart.type && "area" !== n.config.chart.type || n.globals.comboCharts || n.config.tooltip.intersect || (m += " no-pointer-events");
                        var x = Array.isArray(n.config.markers.size) ? n.globals.markers.size[t] > 0 : n.config.markers.size > 0;
                        if (x || r) {
                            M.isNumber(l.y[g]) ? m += " w".concat(M.randomId()) : m = "apexcharts-nullpoint";
                            var v = this.getMarkerConfig({
                                cssClass: m,
                                seriesIndex: t,
                                dataPointIndex: p
                            });
                            n.config.series[o].data[p] && (n.config.series[o].data[p].fillColor && (v.pointFillColor = n.config.series[o].data[p].fillColor),
                            n.config.series[o].data[p].strokeColor && (v.pointStrokeColor = n.config.series[o].data[p].strokeColor)),
                            s && (v.pSize = s),
                            (a = d.drawMarker(l.x[g], l.y[g], v)).attr("rel", p),
                            a.attr("j", p),
                            a.attr("index", t),
                            a.node.setAttribute("default-marker-size", v.pSize);
                            var k = new me(this.ctx);
                            k.setSelectionFilter(a, t, p),
                            this.addEvents(a),
                            c && c.add(a)
                        } else
                            void 0 === n.globals.pointsArray[t] && (n.globals.pointsArray[t] = []),
                            n.globals.pointsArray[t].push([l.x[g], l.y[g]])
                    }
                return c
            }
        }, {
            key: "getMarkerConfig",
            value: function(e) {
                var t = e.cssClass
                  , i = e.seriesIndex
                  , s = e.dataPointIndex
                  , a = void 0 === s ? null : s
                  , r = e.finishRadius
                  , n = void 0 === r ? null : r
                  , o = this.w
                  , l = this.getMarkerStyle(i)
                  , c = o.globals.markers.size[i]
                  , d = o.config.markers;
                return null !== a && d.discrete.length && d.discrete.map(function(g) {
                    g.seriesIndex === i && g.dataPointIndex === a && (l.pointStrokeColor = g.strokeColor,
                    l.pointFillColor = g.fillColor,
                    c = g.size,
                    l.pointShape = g.shape)
                }),
                {
                    pSize: null === n ? c : n,
                    pRadius: d.radius,
                    width: Array.isArray(d.width) ? d.width[i] : d.width,
                    height: Array.isArray(d.height) ? d.height[i] : d.height,
                    pointStrokeWidth: Array.isArray(d.strokeWidth) ? d.strokeWidth[i] : d.strokeWidth,
                    pointStrokeColor: l.pointStrokeColor,
                    pointFillColor: l.pointFillColor,
                    shape: l.pointShape || (Array.isArray(d.shape) ? d.shape[i] : d.shape),
                    class: t,
                    pointStrokeOpacity: Array.isArray(d.strokeOpacity) ? d.strokeOpacity[i] : d.strokeOpacity,
                    pointStrokeDashArray: Array.isArray(d.strokeDashArray) ? d.strokeDashArray[i] : d.strokeDashArray,
                    pointFillOpacity: Array.isArray(d.fillOpacity) ? d.fillOpacity[i] : d.fillOpacity,
                    seriesIndex: i
                }
            }
        }, {
            key: "addEvents",
            value: function(e) {
                var t = this.w
                  , i = new D(this.ctx);
                e.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this.ctx, e)),
                e.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this.ctx, e)),
                e.node.addEventListener("mousedown", i.pathMouseDown.bind(this.ctx, e)),
                e.node.addEventListener("click", t.config.markers.onClick),
                e.node.addEventListener("dblclick", t.config.markers.onDblClick),
                e.node.addEventListener("touchstart", i.pathMouseDown.bind(this.ctx, e), {
                    passive: !0
                })
            }
        }, {
            key: "getMarkerStyle",
            value: function(e) {
                var t = this.w
                  , i = t.globals.markers.colors
                  , s = t.config.markers.strokeColor || t.config.markers.strokeColors;
                return {
                    pointStrokeColor: Array.isArray(s) ? s[e] : s,
                    pointFillColor: Array.isArray(i) ? i[e] : i
                }
            }
        }]),
        y
    }()
      , _e = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w,
            this.initialAnim = this.w.config.chart.animations.enabled,
            this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled
        }
        return V(y, [{
            key: "draw",
            value: function(e, t, i) {
                var s = this.w
                  , a = new D(this.ctx)
                  , r = i.realIndex
                  , n = i.pointsPos
                  , o = i.zRatio
                  , l = i.elParent
                  , c = a.group({
                    class: "apexcharts-series-markers apexcharts-series-".concat(s.config.chart.type)
                });
                if (c.attr("clip-path", "url(#gridRectMarkerMask".concat(s.globals.cuid, ")")),
                Array.isArray(n.x))
                    for (var d = 0; d < n.x.length; d++) {
                        var g = t + 1
                          , p = !0;
                        0 === t && 0 === d && (g = 0),
                        0 === t && 1 === d && (g = 1);
                        var m = 0
                          , x = s.globals.markers.size[r];
                        if (o !== 1 / 0) {
                            x = s.globals.seriesZ[r][g] / o;
                            var v = s.config.plotOptions.bubble;
                            v.minBubbleRadius && x < v.minBubbleRadius && (x = v.minBubbleRadius),
                            v.maxBubbleRadius && x > v.maxBubbleRadius && (x = v.maxBubbleRadius)
                        }
                        s.config.chart.animations.enabled || (m = x);
                        var S = n.y[d];
                        if (m = m || 0,
                        null !== S && void 0 !== s.globals.series[r][g] || (p = !1),
                        p) {
                            var C = this.drawPoint(n.x[d], S, m, x, r, g, t);
                            c.add(C)
                        }
                        l.add(c)
                    }
            }
        }, {
            key: "drawPoint",
            value: function(e, t, i, s, a, r, n) {
                var o = this.w
                  , l = a
                  , c = new Ce(this.ctx)
                  , d = new me(this.ctx)
                  , g = new ue(this.ctx)
                  , p = new Ae(this.ctx)
                  , m = new D(this.ctx)
                  , x = p.getMarkerConfig({
                    cssClass: "apexcharts-marker",
                    seriesIndex: l,
                    dataPointIndex: r,
                    finishRadius: "bubble" === o.config.chart.type || o.globals.comboCharts && o.config.series[a] && "bubble" === o.config.series[a].type ? s : null
                });
                s = x.pSize;
                var v, k = g.fillPath({
                    seriesNumber: a,
                    dataPointIndex: r,
                    color: x.pointFillColor,
                    patternUnits: "objectBoundingBox",
                    value: o.globals.series[a][n]
                });
                if ("circle" === x.shape ? v = m.drawCircle(i) : "square" !== x.shape && "rect" !== x.shape || (v = m.drawRect(0, 0, x.width - x.pointStrokeWidth / 2, x.height - x.pointStrokeWidth / 2, x.pRadius)),
                o.config.series[l].data[r] && o.config.series[l].data[r].fillColor && (k = o.config.series[l].data[r].fillColor),
                v.attr({
                    x: e - x.width / 2 - x.pointStrokeWidth / 2,
                    y: t - x.height / 2 - x.pointStrokeWidth / 2,
                    cx: e,
                    cy: t,
                    fill: k,
                    "fill-opacity": x.pointFillOpacity,
                    stroke: x.pointStrokeColor,
                    r: s,
                    "stroke-width": x.pointStrokeWidth,
                    "stroke-dasharray": x.pointStrokeDashArray,
                    "stroke-opacity": x.pointStrokeOpacity
                }),
                o.config.chart.dropShadow.enabled && d.dropShadow(v, o.config.chart.dropShadow, a),
                !this.initialAnim || o.globals.dataChanged || o.globals.resized ? o.globals.animationEnded = !0 : c.animateMarker(v, 0, "circle" === x.shape ? s : {
                    width: x.width,
                    height: x.height
                }, o.config.chart.animations.speed, o.globals.easing, function() {
                    window.setTimeout(function() {
                        c.animationCompleted(v)
                    }, 100)
                }),
                o.globals.dataChanged && "circle" === x.shape)
                    if (this.dynamicAnim) {
                        var h, u, b, w, _ = o.config.chart.animations.dynamicAnimation.speed;
                        null != (w = o.globals.previousPaths[a] && o.globals.previousPaths[a][n]) && (h = w.x,
                        u = w.y,
                        b = void 0 !== w.r ? w.r : s);
                        for (var X = 0; X < o.globals.collapsedSeries.length; X++)
                            o.globals.collapsedSeries[X].index === a && (_ = 1,
                            s = 0);
                        0 === e && 0 === t && (s = 0),
                        c.animateCircle(v, {
                            cx: h,
                            cy: u,
                            r: b
                        }, {
                            cx: e,
                            cy: t,
                            r: s
                        }, _, o.globals.easing)
                    } else
                        v.attr({
                            r: s
                        });
                return v.attr({
                    rel: r,
                    j: r,
                    index: a,
                    "default-marker-size": s
                }),
                d.setSelectionFilter(v, a, r),
                p.addEvents(v),
                v.node.classList.add("apexcharts-marker"),
                v
            }
        }, {
            key: "centerTextInBubble",
            value: function(e) {
                return {
                    y: e += parseInt(this.w.config.dataLabels.style.fontSize, 10) / 4
                }
            }
        }]),
        y
    }()
      , Ge = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w
        }
        return V(y, [{
            key: "dataLabelsCorrection",
            value: function(e, t, i, s, a, r, n) {
                var o = this.w
                  , l = !1
                  , c = new D(this.ctx).getTextRects(i, n)
                  , d = c.width
                  , g = c.height;
                if (t < 0 && (t = 0),
                t > o.globals.gridHeight + g && (t = o.globals.gridHeight + g / 2),
                void 0 === o.globals.dataLabelsRects[s] && (o.globals.dataLabelsRects[s] = []),
                o.globals.dataLabelsRects[s].push({
                    x: e,
                    y: t,
                    width: d,
                    height: g
                }),
                void 0 !== o.globals.dataLabelsRects[s][o.globals.dataLabelsRects[s].length - 2]) {
                    var x = o.globals.dataLabelsRects[s][void 0 !== o.globals.lastDrawnDataLabelsIndexes[s] ? o.globals.lastDrawnDataLabelsIndexes[s][o.globals.lastDrawnDataLabelsIndexes[s].length - 1] : 0];
                    (e > x.x + x.width + 2 || t > x.y + x.height + 2 || e + d < x.x) && (l = !0)
                }
                return (0 === a || r) && (l = !0),
                {
                    x: e,
                    y: t,
                    textRects: c,
                    drawnextLabel: l
                }
            }
        }, {
            key: "drawDataLabel",
            value: function(e, t, i) {
                var s = this
                  , a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 2
                  , r = this.w
                  , n = new D(this.ctx)
                  , o = r.config.dataLabels
                  , l = 0
                  , c = 0
                  , d = i
                  , g = null;
                if (!o.enabled || !Array.isArray(e.x))
                    return g;
                g = n.group({
                    class: "apexcharts-data-labels"
                });
                for (var p = 0; p < e.x.length; p++)
                    if (l = e.x[p] + o.offsetX,
                    c = e.y[p] + o.offsetY + a,
                    !isNaN(l)) {
                        1 === i && 0 === p && (d = 0),
                        1 === i && 1 === p && (d = 1);
                        var m = r.globals.series[t][d]
                          , x = ""
                          , v = function(C) {
                            return r.config.dataLabels.formatter(C, {
                                ctx: s.ctx,
                                seriesIndex: t,
                                dataPointIndex: d,
                                w: r
                            })
                        };
                        if ("bubble" === r.config.chart.type) {
                            x = v(m = r.globals.seriesZ[t][d]),
                            c = e.y[p];
                            var k = new _e(this.ctx)
                              , S = k.centerTextInBubble(c, t, d);
                            c = S.y
                        } else
                            void 0 !== m && (x = v(m));
                        this.plotDataLabelsText({
                            x: l,
                            y: c,
                            text: x,
                            i: t,
                            j: d,
                            parent: g,
                            offsetCorrection: !0,
                            dataLabelsConfig: r.config.dataLabels
                        })
                    }
                return g
            }
        }, {
            key: "plotDataLabelsText",
            value: function(e) {
                var t = this.w
                  , i = new D(this.ctx)
                  , s = e.x
                  , a = e.y
                  , r = e.i
                  , n = e.j
                  , o = e.text
                  , l = e.textAnchor
                  , c = e.fontSize
                  , d = e.parent
                  , g = e.dataLabelsConfig
                  , p = e.color
                  , m = e.alwaysDrawDataLabel
                  , x = e.offsetCorrection;
                if (!(Array.isArray(t.config.dataLabels.enabledOnSeries) && t.config.dataLabels.enabledOnSeries.indexOf(r) < 0)) {
                    var v = {
                        x: s,
                        y: a,
                        drawnextLabel: !0,
                        textRects: null
                    };
                    x && (v = this.dataLabelsCorrection(s, a, o, r, n, m, parseInt(g.style.fontSize, 10))),
                    t.globals.zoomed || (s = v.x,
                    a = v.y),
                    v.textRects && (s < -10 - v.textRects.width || s > t.globals.gridWidth + v.textRects.width + 10) && (o = "");
                    var k = t.globals.dataLabels.style.colors[r];
                    (("bar" === t.config.chart.type || "rangeBar" === t.config.chart.type) && t.config.plotOptions.bar.distributed || t.config.dataLabels.distributed) && (k = t.globals.dataLabels.style.colors[n]),
                    "function" == typeof k && (k = k({
                        series: t.globals.series,
                        seriesIndex: r,
                        dataPointIndex: n,
                        w: t
                    })),
                    p && (k = p);
                    var S = g.offsetX
                      , C = g.offsetY;
                    if ("bar" !== t.config.chart.type && "rangeBar" !== t.config.chart.type || (S = 0,
                    C = 0),
                    v.drawnextLabel) {
                        var h = i.drawText({
                            width: 100,
                            height: parseInt(g.style.fontSize, 10),
                            x: s + S,
                            y: a + C,
                            foreColor: k,
                            textAnchor: l || g.textAnchor,
                            text: o,
                            fontSize: c || g.style.fontSize,
                            fontFamily: g.style.fontFamily,
                            fontWeight: g.style.fontWeight || "normal"
                        });
                        if (h.attr({
                            class: "apexcharts-datalabel",
                            cx: s,
                            cy: a
                        }),
                        g.dropShadow.enabled) {
                            var u = g.dropShadow;
                            new me(this.ctx).dropShadow(h, u)
                        }
                        d.add(h),
                        void 0 === t.globals.lastDrawnDataLabelsIndexes[r] && (t.globals.lastDrawnDataLabelsIndexes[r] = []),
                        t.globals.lastDrawnDataLabelsIndexes[r].push(n)
                    }
                }
            }
        }, {
            key: "addBackgroundToDataLabel",
            value: function(e, t) {
                var i = this.w
                  , s = i.config.dataLabels.background
                  , a = s.padding
                  , r = s.padding / 2
                  , n = t.width
                  , o = t.height
                  , l = new D(this.ctx).drawRect(t.x - a, t.y - r / 2, n + 2 * a, o + r, s.borderRadius, "transparent" === i.config.chart.background ? "#fff" : i.config.chart.background, s.opacity, s.borderWidth, s.borderColor);
                return s.dropShadow.enabled && new me(this.ctx).dropShadow(l, s.dropShadow),
                l
            }
        }, {
            key: "dataLabelsBackground",
            value: function() {
                var e = this.w;
                if ("bubble" !== e.config.chart.type)
                    for (var t = e.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), i = 0; i < t.length; i++) {
                        var s = t[i]
                          , a = s.getBBox()
                          , r = null;
                        if (a.width && a.height && (r = this.addBackgroundToDataLabel(s, a)),
                        r) {
                            s.parentNode.insertBefore(r.node, s);
                            var n = s.getAttribute("fill");
                            !e.config.chart.animations.enabled || e.globals.resized || e.globals.dataChanged ? r.attr({
                                fill: n
                            }) : r.animate().attr({
                                fill: n
                            }),
                            s.setAttribute("fill", e.config.dataLabels.background.foreColor)
                        }
                    }
            }
        }, {
            key: "bringForward",
            value: function() {
                for (var e = this.w, t = e.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"), i = e.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"), s = 0; s < t.length; s++)
                    i && i.insertBefore(t[s], i.nextSibling)
            }
        }]),
        y
    }()
      , lt = function() {
        function y(e) {
            W(this, y),
            this.w = e.w,
            this.barCtx = e
        }
        return V(y, [{
            key: "handleBarDataLabels",
            value: function(e) {
                var t = e.x
                  , i = e.y
                  , s = e.y1
                  , a = e.y2
                  , r = e.i
                  , n = e.j
                  , o = e.realIndex
                  , l = e.series
                  , c = e.barHeight
                  , d = e.barWidth
                  , g = e.barYPosition
                  , p = e.visibleSeries
                  , m = e.renderedPath
                  , x = this.w
                  , v = new D(this.barCtx.ctx)
                  , k = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[o] : this.barCtx.strokeWidth
                  , S = t + parseFloat(d * p)
                  , C = i + parseFloat(c * p);
                x.globals.isXNumeric && !x.globals.isBarHorizontal && (S = t + parseFloat(d * (p + 1)),
                C = i + parseFloat(c * (p + 1)) - k);
                var b, h = t, u = i, w = x.config.dataLabels, _ = this.barCtx.barOptions.dataLabels;
                void 0 !== g && this.barCtx.isRangeBar && (C = g,
                u = g);
                var X = w.offsetX
                  , I = w.offsetY
                  , R = {
                    width: 0,
                    height: 0
                };
                x.config.dataLabels.enabled && (R = v.getTextRects(x.globals.yLabelFormatters[0](this.barCtx.series[r][n]), parseFloat(w.style.fontSize)));
                var G = {
                    x: t,
                    y: i,
                    i: r,
                    j: n,
                    renderedPath: m,
                    bcx: S,
                    bcy: C,
                    barHeight: c,
                    barWidth: d,
                    textRects: R,
                    strokeWidth: k,
                    dataLabelsX: h,
                    dataLabelsY: u,
                    barDataLabelsConfig: _,
                    offX: X,
                    offY: I
                };
                return b = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(G) : this.calculateColumnsDataLabelsPosition(G),
                m.attr({
                    cy: b.bcy,
                    cx: b.bcx,
                    j: n,
                    val: l[r][n],
                    barHeight: c,
                    barWidth: d
                }),
                this.drawCalculatedDataLabels({
                    x: b.dataLabelsX,
                    y: b.dataLabelsY,
                    val: this.barCtx.isRangeBar ? [s, a] : l[r][n],
                    i: o,
                    j: n,
                    barWidth: d,
                    barHeight: c,
                    textRects: R,
                    dataLabelsConfig: w
                })
            }
        }, {
            key: "calculateColumnsDataLabelsPosition",
            value: function(e) {
                var t, i = this.w, s = e.i, a = e.j, r = e.y, n = e.bcx, o = e.barWidth, l = e.barHeight, c = e.textRects, d = e.dataLabelsY, g = e.barDataLabelsConfig, p = e.strokeWidth, m = e.offX, x = e.offY;
                l = Math.abs(l);
                var v = "vertical" === i.config.plotOptions.bar.dataLabels.orientation;
                n -= p / 2,
                t = i.globals.isXNumeric ? n - o / 2 + m : n - i.globals.gridWidth / i.globals.dataPoints + o / 2 + m,
                v && (t = t + c.height / 2 - p / 2 - 2);
                var S = this.barCtx.series[s][a] < 0
                  , C = r;
                switch (this.barCtx.isReversed && (C = r - l + (S ? 2 * l : 0),
                r -= l),
                g.position) {
                case "center":
                    d = v ? S ? C + l / 2 + x : C + l / 2 - x : S ? C - l / 2 + c.height / 2 + x : C + l / 2 + c.height / 2 - x;
                    break;
                case "bottom":
                    d = v ? S ? C + l + x : C + l - x : S ? C - l + c.height + p + x : C + l - c.height / 2 + p - x;
                    break;
                case "top":
                    d = v ? S ? C + x : C - x : S ? C - c.height / 2 - x : C + c.height + x
                }
                return i.config.chart.stacked || (d < 0 ? d = 0 + p : d + c.height / 3 > i.globals.gridHeight && (d = i.globals.gridHeight - p)),
                {
                    bcx: n,
                    bcy: r,
                    dataLabelsX: t,
                    dataLabelsY: d
                }
            }
        }, {
            key: "calculateBarsDataLabelsPosition",
            value: function(e) {
                var t = this.w
                  , i = e.x
                  , s = e.i
                  , a = e.j
                  , r = e.bcy
                  , n = e.barHeight
                  , o = e.barWidth
                  , l = e.textRects
                  , c = e.dataLabelsX
                  , d = e.strokeWidth
                  , g = e.barDataLabelsConfig
                  , p = e.offX
                  , m = e.offY
                  , x = t.globals.gridHeight / t.globals.dataPoints;
                o = Math.abs(o);
                var v = r - (this.barCtx.isRangeBar ? 0 : x) + n / 2 + l.height / 2 + m - 3
                  , k = this.barCtx.series[s][a] < 0
                  , S = i;
                switch (this.barCtx.isReversed && (S = i + o - (k ? 2 * o : 0),
                i = t.globals.gridWidth - o),
                g.position) {
                case "center":
                    c = k ? S + o / 2 - p : Math.max(l.width / 2, S - o / 2) + p;
                    break;
                case "bottom":
                    c = k ? S + o - d - Math.round(l.width / 2) - p : S - o + d + Math.round(l.width / 2) + p;
                    break;
                case "top":
                    c = k ? S - d + Math.round(l.width / 2) - p : S - d - Math.round(l.width / 2) + p
                }
                return t.config.chart.stacked || (c < 0 ? c = c + l.width + d : c + l.width / 2 > t.globals.gridWidth && (c = t.globals.gridWidth - l.width - d)),
                {
                    bcx: i,
                    bcy: r,
                    dataLabelsX: c,
                    dataLabelsY: v
                }
            }
        }, {
            key: "drawCalculatedDataLabels",
            value: function(e) {
                var t = e.x
                  , i = e.y
                  , s = e.val
                  , a = e.i
                  , r = e.j
                  , n = e.textRects
                  , o = e.barHeight
                  , l = e.barWidth
                  , c = e.dataLabelsConfig
                  , d = this.w
                  , g = "rotate(0)";
                "vertical" === d.config.plotOptions.bar.dataLabels.orientation && (g = "rotate(-90, ".concat(t, ", ").concat(i, ")"));
                var p = new Ge(this.barCtx.ctx)
                  , m = new D(this.barCtx.ctx)
                  , x = c.formatter
                  , v = null
                  , k = d.globals.collapsedSeriesIndices.indexOf(a) > -1;
                if (c.enabled && !k) {
                    v = m.group({
                        class: "apexcharts-data-labels",
                        transform: g
                    });
                    var S = "";
                    void 0 !== s && (S = x(s, {
                        seriesIndex: a,
                        dataPointIndex: r,
                        w: d
                    }));
                    var C = d.globals.series[a][r] < 0
                      , h = d.config.plotOptions.bar.dataLabels.position;
                    "vertical" === d.config.plotOptions.bar.dataLabels.orientation && ("top" === h && (c.textAnchor = C ? "end" : "start"),
                    "center" === h && (c.textAnchor = "middle"),
                    "bottom" === h && (c.textAnchor = C ? "end" : "start")),
                    this.barCtx.isRangeBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && l < m.getTextRects(S, parseFloat(c.style.fontSize)).width && (S = ""),
                    d.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? n.width / 1.6 > Math.abs(l) && (S = "") : n.height / 1.6 > Math.abs(o) && (S = ""));
                    var u = Z({}, c);
                    this.barCtx.isHorizontal && s < 0 && ("start" === c.textAnchor ? u.textAnchor = "end" : "end" === c.textAnchor && (u.textAnchor = "start")),
                    p.plotDataLabelsText({
                        x: t,
                        y: i,
                        text: S,
                        i: a,
                        j: r,
                        parent: v,
                        dataLabelsConfig: u,
                        alwaysDrawDataLabel: !0,
                        offsetCorrection: !0
                    })
                }
                return v
            }
        }]),
        y
    }()
      , ve = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w,
            this.legendInactiveClass = "legend-mouseover-inactive"
        }
        return V(y, [{
            key: "getAllSeriesEls",
            value: function() {
                return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series")
            }
        }, {
            key: "getSeriesByName",
            value: function(e) {
                return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(M.escapeString(e), "']"))
            }
        }, {
            key: "isSeriesHidden",
            value: function(e) {
                var t = this.getSeriesByName(e)
                  , i = parseInt(t.getAttribute("data:realIndex"), 10);
                return {
                    isHidden: t.classList.contains("apexcharts-series-collapsed"),
                    realIndex: i
                }
            }
        }, {
            key: "addCollapsedClassToSeries",
            value: function(e, t) {
                var i = this.w;
                function s(a) {
                    for (var r = 0; r < a.length; r++)
                        a[r].index === t && e.node.classList.add("apexcharts-series-collapsed")
                }
                s(i.globals.collapsedSeries),
                s(i.globals.ancillaryCollapsedSeries)
            }
        }, {
            key: "toggleSeries",
            value: function(e) {
                var t = this.isSeriesHidden(e);
                return this.ctx.legend.legendHelpers.toggleDataSeries(t.realIndex, t.isHidden),
                t.isHidden
            }
        }, {
            key: "showSeries",
            value: function(e) {
                var t = this.isSeriesHidden(e);
                t.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(t.realIndex, !0)
            }
        }, {
            key: "hideSeries",
            value: function(e) {
                var t = this.isSeriesHidden(e);
                t.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(t.realIndex, !1)
            }
        }, {
            key: "resetSeries",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]
                  , t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                  , i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
                  , s = this.w
                  , a = M.clone(s.globals.initialSeries);
                s.globals.previousPaths = [],
                i ? (s.globals.collapsedSeries = [],
                s.globals.ancillaryCollapsedSeries = [],
                s.globals.collapsedSeriesIndices = [],
                s.globals.ancillaryCollapsedSeriesIndices = []) : a = this.emptyCollapsedSeries(a),
                s.config.series = a,
                e && (t && (s.globals.zoomed = !1,
                this.ctx.updateHelpers.revertDefaultAxisMinMax()),
                this.ctx.updateHelpers._updateSeries(a, s.config.chart.animations.dynamicAnimation.enabled))
            }
        }, {
            key: "emptyCollapsedSeries",
            value: function(e) {
                for (var t = this.w, i = 0; i < e.length; i++)
                    t.globals.collapsedSeriesIndices.indexOf(i) > -1 && (e[i].data = []);
                return e
            }
        }, {
            key: "toggleSeriesOnHover",
            value: function(e, t) {
                var i = this.w;
                t || (t = e.target);
                var s = i.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels");
                if ("mousemove" === e.type) {
                    var a = parseInt(t.getAttribute("rel"), 10) - 1
                      , r = null
                      , n = null;
                    i.globals.axisCharts || "radialBar" === i.config.chart.type ? i.globals.axisCharts ? (r = i.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(a, "']")),
                    n = i.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(a, "']"))) : r = i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(a + 1, "']")) : r = i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(a + 1, "'] path"));
                    for (var o = 0; o < s.length; o++)
                        s[o].classList.add(this.legendInactiveClass);
                    null !== r && (i.globals.axisCharts || r.parentNode.classList.remove(this.legendInactiveClass),
                    r.classList.remove(this.legendInactiveClass),
                    null !== n && n.classList.remove(this.legendInactiveClass))
                } else if ("mouseout" === e.type)
                    for (var l = 0; l < s.length; l++)
                        s[l].classList.remove(this.legendInactiveClass)
            }
        }, {
            key: "highlightRangeInSeries",
            value: function(e, t) {
                var i = this
                  , s = this.w
                  , a = s.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect")
                  , r = function(o) {
                    for (var l = 0; l < a.length; l++)
                        a[l].classList[o](i.legendInactiveClass)
                };
                if ("mousemove" === e.type) {
                    var n = parseInt(t.getAttribute("rel"), 10) - 1;
                    r("add"),
                    function(o) {
                        for (var l = 0; l < a.length; l++) {
                            var c = parseInt(a[l].getAttribute("val"), 10);
                            c >= o.from && c <= o.to && a[l].classList.remove(i.legendInactiveClass)
                        }
                    }(s.config.plotOptions.heatmap.colorScale.ranges[n])
                } else
                    "mouseout" === e.type && r("remove")
            }
        }, {
            key: "getActiveConfigSeriesIndex",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "asc"
                  , i = this.w
                  , s = 0;
                if (i.config.series.length > 1)
                    for (var a = i.config.series.map(function(n, o) {
                        var l = !1;
                        return e && (l = "bar" === i.config.series[o].type || "column" === i.config.series[o].type),
                        n.data && n.data.length > 0 && !l ? o : -1
                    }), r = "asc" === t ? 0 : a.length - 1; "asc" === t ? r < a.length : r >= 0; "asc" === t ? r++ : r--)
                        if (-1 !== a[r]) {
                            s = a[r];
                            break
                        }
                return s
            }
        }, {
            key: "getPreviousPaths",
            value: function() {
                var e = this.w;
                function t(r, n, o) {
                    for (var l = r[n].childNodes, c = {
                        type: o,
                        paths: [],
                        realIndex: r[n].getAttribute("data:realIndex")
                    }, d = 0; d < l.length; d++)
                        if (l[d].hasAttribute("pathTo")) {
                            var g = l[d].getAttribute("pathTo");
                            c.paths.push({
                                d: g
                            })
                        }
                    e.globals.previousPaths.push(c)
                }
                e.globals.previousPaths = [],
                ["line", "area", "bar", "rangebar", "candlestick", "radar"].forEach(function(r) {
                    for (var o = e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(r, "-series .apexcharts-series")), l = 0; l < o.length; l++)
                        t(o, l, r)
                }),
                this.handlePrevBubbleScatterPaths("bubble"),
                this.handlePrevBubbleScatterPaths("scatter");
                var i = e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(e.config.chart.type, " .apexcharts-series"));
                if (i.length > 0)
                    for (var s = function(r) {
                        for (var n = e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(e.config.chart.type, " .apexcharts-series[data\\:realIndex='").concat(r, "'] rect")), o = [], l = function(d) {
                            var g = function(m) {
                                return n[d].getAttribute(m)
                            }
                              , p = {
                                x: parseFloat(g("x")),
                                y: parseFloat(g("y")),
                                width: parseFloat(g("width")),
                                height: parseFloat(g("height"))
                            };
                            o.push({
                                rect: p,
                                color: n[d].getAttribute("color")
                            })
                        }, c = 0; c < n.length; c++)
                            l(c);
                        e.globals.previousPaths.push(o)
                    }, a = 0; a < i.length; a++)
                        s(a);
                e.globals.axisCharts || (e.globals.previousPaths = e.globals.series)
            }
        }, {
            key: "handlePrevBubbleScatterPaths",
            value: function(e) {
                var t = this.w
                  , i = t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(e, "-series .apexcharts-series"));
                if (i.length > 0)
                    for (var s = 0; s < i.length; s++) {
                        for (var a = t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(e, "-series .apexcharts-series[data\\:realIndex='").concat(s, "'] circle")), r = [], n = 0; n < a.length; n++)
                            r.push({
                                x: a[n].getAttribute("cx"),
                                y: a[n].getAttribute("cy"),
                                r: a[n].getAttribute("r")
                            });
                        t.globals.previousPaths.push(r)
                    }
            }
        }, {
            key: "clearPreviousPaths",
            value: function() {
                var e = this.w;
                e.globals.previousPaths = [],
                e.globals.allSeriesCollapsed = !1
            }
        }, {
            key: "handleNoData",
            value: function() {
                var e = this.w
                  , t = e.config.noData
                  , i = new D(this.ctx)
                  , s = e.globals.svgWidth / 2
                  , a = e.globals.svgHeight / 2
                  , r = "middle";
                if (e.globals.noData = !0,
                e.globals.animationEnded = !0,
                "left" === t.align ? (s = 10,
                r = "start") : "right" === t.align && (s = e.globals.svgWidth - 10,
                r = "end"),
                "top" === t.verticalAlign ? a = 50 : "bottom" === t.verticalAlign && (a = e.globals.svgHeight - 50),
                s += t.offsetX,
                a = a + parseInt(t.style.fontSize, 10) + 2 + t.offsetY,
                void 0 !== t.text && "" !== t.text) {
                    var n = i.drawText({
                        x: s,
                        y: a,
                        text: t.text,
                        textAnchor: r,
                        fontSize: t.style.fontSize,
                        fontFamily: t.style.fontFamily,
                        foreColor: t.style.color,
                        opacity: 1,
                        class: "apexcharts-text-nodata"
                    });
                    e.globals.dom.Paper.add(n)
                }
            }
        }, {
            key: "setNullSeriesToZeroValues",
            value: function(e) {
                for (var t = this.w, i = 0; i < e.length; i++)
                    if (0 === e[i].length)
                        for (var s = 0; s < e[t.globals.maxValsInArrayIndex].length; s++)
                            e[i].push(0);
                return e
            }
        }, {
            key: "hasAllSeriesEqualX",
            value: function() {
                for (var e = !0, t = this.w, i = this.filteredSeriesX(), s = 0; s < i.length - 1; s++)
                    if (i[s][0] !== i[s + 1][0]) {
                        e = !1;
                        break
                    }
                return t.globals.allSeriesHasEqualX = e,
                e
            }
        }, {
            key: "filteredSeriesX",
            value: function() {
                return this.w.globals.seriesX.map(function(t) {
                    return t.length > 0 ? t : []
                })
            }
        }]),
        y
    }()
      , ht = function() {
        function y(e) {
            W(this, y),
            this.w = e.w,
            this.barCtx = e
        }
        return V(y, [{
            key: "initVariables",
            value: function(e) {
                var t = this.w;
                this.barCtx.series = e,
                this.barCtx.totalItems = 0,
                this.barCtx.seriesLen = 0,
                this.barCtx.visibleI = -1,
                this.barCtx.visibleItems = 1;
                for (var i = 0; i < e.length; i++)
                    if (e[i].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1,
                    this.barCtx.totalItems += e[i].length),
                    t.globals.isXNumeric)
                        for (var s = 0; s < e[i].length; s++)
                            t.globals.seriesX[i][s] > t.globals.minX && t.globals.seriesX[i][s] < t.globals.maxX && this.barCtx.visibleItems++;
                    else
                        this.barCtx.visibleItems = t.globals.dataPoints;
                0 === this.barCtx.seriesLen && (this.barCtx.seriesLen = 1),
                this.barCtx.zeroSerieses = [],
                this.barCtx.radiusOnSeriesNumber = e.length - 1,
                t.globals.comboCharts || this.checkZeroSeries({
                    series: e
                })
            }
        }, {
            key: "initialPositions",
            value: function() {
                var e, t, i, s, a, r, n, o, l = this.w, c = l.globals.dataPoints;
                this.barCtx.isRangeBar && (c = l.globals.labels.length);
                var d = this.barCtx.seriesLen;
                if (l.config.plotOptions.bar.rangeBarGroupRows && (d = 1),
                this.barCtx.isHorizontal)
                    a = (i = l.globals.gridHeight / c) / d,
                    l.globals.isXNumeric && (a = (i = l.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen),
                    a = a * parseInt(this.barCtx.barOptions.barHeight, 10) / 100,
                    o = this.barCtx.baseLineInvertedY + l.globals.padHorizontal + (this.barCtx.isReversed ? l.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0),
                    t = (i - a * this.barCtx.seriesLen) / 2;
                else {
                    if (s = l.globals.gridWidth / this.barCtx.visibleItems,
                    l.config.xaxis.convertedCatToNumeric && (s = l.globals.gridWidth / l.globals.dataPoints),
                    r = s / this.barCtx.seriesLen * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100,
                    l.globals.isXNumeric) {
                        var g = this.barCtx.xRatio;
                        l.config.xaxis.convertedCatToNumeric && (g = this.barCtx.initialXRatio),
                        l.globals.minXDiff && .5 !== l.globals.minXDiff && l.globals.minXDiff / g > 0 && (s = l.globals.minXDiff / g),
                        (r = s / this.barCtx.seriesLen * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (r = 1)
                    }
                    n = l.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.yaxisIndex] - (this.barCtx.isReversed ? l.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.yaxisIndex] : 0),
                    e = l.globals.padHorizontal + (s - r * this.barCtx.seriesLen) / 2
                }
                return {
                    x: e,
                    y: t,
                    yDivision: i,
                    xDivision: s,
                    barHeight: a,
                    barWidth: r,
                    zeroH: n,
                    zeroW: o
                }
            }
        }, {
            key: "getPathFillColor",
            value: function(e, t, i, s) {
                var a = this.w
                  , r = new ue(this.barCtx.ctx)
                  , n = null
                  , o = this.barCtx.barOptions.distributed ? i : t;
                return this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map(function(l) {
                    e[t][i] >= l.from && e[t][i] <= l.to && (n = l.color)
                }),
                a.config.series[t].data[i] && a.config.series[t].data[i].fillColor && (n = a.config.series[t].data[i].fillColor),
                r.fillPath({
                    seriesNumber: this.barCtx.barOptions.distributed ? o : s,
                    dataPointIndex: i,
                    color: n,
                    value: e[t][i]
                })
            }
        }, {
            key: "getStrokeWidth",
            value: function(e, t, i) {
                var s = 0
                  , a = this.w;
                return this.barCtx.isNullValue = null == this.barCtx.series[e][t],
                a.config.stroke.show && (this.barCtx.isNullValue || (s = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[i] : this.barCtx.strokeWidth)),
                s
            }
        }, {
            key: "barBackground",
            value: function(e) {
                var t = e.j
                  , i = e.i
                  , s = e.x1
                  , a = e.x2
                  , r = e.y1
                  , n = e.y2
                  , o = e.elSeries
                  , l = this.w
                  , c = new D(this.barCtx.ctx)
                  , d = new ve(this.barCtx.ctx).getActiveConfigSeriesIndex();
                if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && d === i) {
                    t >= this.barCtx.barOptions.colors.backgroundBarColors.length && (t -= this.barCtx.barOptions.colors.backgroundBarColors.length);
                    var p = c.drawRect(void 0 !== s ? s : 0, void 0 !== r ? r : 0, void 0 !== a ? a : l.globals.gridWidth, void 0 !== n ? n : l.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, this.barCtx.barOptions.colors.backgroundBarColors[t], this.barCtx.barOptions.colors.backgroundBarOpacity);
                    o.add(p),
                    p.node.classList.add("apexcharts-backgroundBar")
                }
            }
        }, {
            key: "getColumnPaths",
            value: function(e) {
                var t = e.barWidth
                  , i = e.barXPosition
                  , s = e.yRatio
                  , a = e.y1
                  , r = e.y2
                  , n = e.strokeWidth
                  , o = e.series
                  , l = e.realIndex
                  , c = e.i
                  , d = e.j
                  , g = e.w
                  , p = new D(this.barCtx.ctx);
                (n = Array.isArray(n) ? n[l] : n) || (n = 0);
                var x = this.getRoundedBars(g, {
                    barWidth: t,
                    strokeWidth: n,
                    yRatio: s,
                    barXPosition: i,
                    y1: a,
                    y2: r
                }, o, c, d)
                  , v = i
                  , k = i + t
                  , S = p.move(v, a)
                  , C = p.move(v, a)
                  , h = p.line(k - n, a);
                return g.globals.previousPaths.length > 0 && (C = this.barCtx.getPreviousPath(l, d, !1)),
                S = S + p.line(v, x.y2) + x.pathWithRadius + p.line(k - n, x.y2) + h + h + "z",
                C = C + p.line(v, a) + h + h + h + h + h + p.line(v, a),
                g.config.chart.stacked && (this.barCtx.yArrj.push(x.y2),
                this.barCtx.yArrjF.push(Math.abs(a - x.y2)),
                this.barCtx.yArrjVal.push(this.barCtx.series[c][d])),
                {
                    pathTo: S,
                    pathFrom: C
                }
            }
        }, {
            key: "getBarpaths",
            value: function(e) {
                var t = e.barYPosition
                  , i = e.barHeight
                  , s = e.x1
                  , a = e.x2
                  , r = e.strokeWidth
                  , n = e.series
                  , o = e.realIndex
                  , l = e.i
                  , c = e.j
                  , d = e.w
                  , g = new D(this.barCtx.ctx);
                (r = Array.isArray(r) ? r[o] : r) || (r = 0);
                var m = this.getRoundedBars(d, {
                    barHeight: i,
                    strokeWidth: r,
                    barYPosition: t,
                    x2: a,
                    x1: s
                }, n, l, c)
                  , x = g.move(s, t)
                  , v = g.move(s, t);
                d.globals.previousPaths.length > 0 && (v = this.barCtx.getPreviousPath(o, c, !1));
                var k = t
                  , S = t + i
                  , C = g.line(s, S - r);
                return x = x + g.line(m.x2, k) + m.pathWithRadius + g.line(m.x2, S - r) + C + C + "z",
                v = v + g.line(s, k) + C + C + C + C + C + g.line(s, k),
                d.config.chart.stacked && (this.barCtx.xArrj.push(m.x2),
                this.barCtx.xArrjF.push(Math.abs(s - m.x2)),
                this.barCtx.xArrjVal.push(this.barCtx.series[l][c])),
                {
                    pathTo: x,
                    pathFrom: v
                }
            }
        }, {
            key: "getRoundedBars",
            value: function(e, t, i, s, a) {
                var r = new D(this.barCtx.ctx)
                  , n = 0
                  , o = e.config.plotOptions.bar.borderRadius
                  , l = Array.isArray(o);
                if (n = l ? o[s > o.length - 1 ? o.length - 1 : s] : o,
                e.config.chart.stacked && i.length > 1 && s !== this.barCtx.radiusOnSeriesNumber && !l && (n = 0),
                this.barCtx.isHorizontal) {
                    var c = ""
                      , d = t.x2;
                    if (Math.abs(t.x1 - t.x2) < n && (n = Math.abs(t.x1 - t.x2)),
                    void 0 !== i[s][a] || null !== i[s][a]) {
                        var g = this.barCtx.isReversed ? i[s][a] > 0 : i[s][a] < 0;
                        g && (n *= -1),
                        c = r.quadraticCurve((d -= n) + n, t.barYPosition, d + n, t.barYPosition + (g ? -1 * n : n)) + r.line(d + n, t.barYPosition + t.barHeight - t.strokeWidth - (g ? -1 * n : n)) + r.quadraticCurve(d + n, t.barYPosition + t.barHeight - t.strokeWidth, d, t.barYPosition + t.barHeight - t.strokeWidth)
                    }
                    return {
                        pathWithRadius: c,
                        x2: d
                    }
                }
                var p = ""
                  , m = t.y2;
                if (Math.abs(t.y1 - t.y2) < n && (n = Math.abs(t.y1 - t.y2)),
                void 0 !== i[s][a] || null !== i[s][a]) {
                    var x = i[s][a] < 0;
                    x && (n *= -1),
                    p = r.quadraticCurve(t.barXPosition, (m += n) - n, t.barXPosition + (x ? -1 * n : n), m - n) + r.line(t.barXPosition + t.barWidth - t.strokeWidth - (x ? -1 * n : n), m - n) + r.quadraticCurve(t.barXPosition + t.barWidth - t.strokeWidth, m - n, t.barXPosition + t.barWidth - t.strokeWidth, m)
                }
                return {
                    pathWithRadius: p,
                    y2: m
                }
            }
        }, {
            key: "checkZeroSeries",
            value: function(e) {
                for (var t = e.series, i = this.w, s = 0; s < t.length; s++) {
                    for (var a = 0, r = 0; r < t[i.globals.maxValsInArrayIndex].length; r++)
                        a += t[s][r];
                    0 === a && this.barCtx.zeroSerieses.push(s)
                }
                for (var n = t.length - 1; n >= 0; n--)
                    this.barCtx.zeroSerieses.indexOf(n) > -1 && n === this.radiusOnSeriesNumber && (this.barCtx.radiusOnSeriesNumber -= 1);
                for (var o = t.length - 1; o >= 0; o--)
                    i.globals.collapsedSeriesIndices.indexOf(this.barCtx.radiusOnSeriesNumber) > -1 && (this.barCtx.radiusOnSeriesNumber -= 1)
            }
        }, {
            key: "getXForValue",
            value: function(e, t) {
                var i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
                  , s = i ? t : null;
                return null != e && (s = t + e / this.barCtx.invertedYRatio - 2 * (this.barCtx.isReversed ? e / this.barCtx.invertedYRatio : 0)),
                s
            }
        }, {
            key: "getYForValue",
            value: function(e, t) {
                var i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
                  , s = i ? t : null;
                return null != e && (s = t - e / this.barCtx.yRatio[this.barCtx.yaxisIndex] + 2 * (this.barCtx.isReversed ? e / this.barCtx.yRatio[this.barCtx.yaxisIndex] : 0)),
                s
            }
        }, {
            key: "getGoalValues",
            value: function(e, t, i, s, a) {
                var r = this
                  , n = this.w
                  , o = [];
                return n.globals.seriesGoals[s] && n.globals.seriesGoals[s][a] && Array.isArray(n.globals.seriesGoals[s][a]) && n.globals.seriesGoals[s][a].forEach(function(l) {
                    var c;
                    o.push((Ke(c = {}, e, "x" === e ? r.getXForValue(l.value, t, !1) : r.getYForValue(l.value, i, !1)),
                    Ke(c, "attrs", l),
                    c))
                }),
                o
            }
        }, {
            key: "drawGoalLine",
            value: function(e) {
                var t = e.barXPosition
                  , i = e.barYPosition
                  , s = e.goalX
                  , a = e.goalY
                  , r = e.barWidth
                  , n = e.barHeight
                  , o = new D(this.barCtx.ctx)
                  , l = o.group({
                    className: "apexcharts-bar-goals-groups"
                })
                  , c = null;
                return this.barCtx.isHorizontal ? Array.isArray(s) && s.forEach(function(d) {
                    var g = void 0 !== d.attrs.strokeHeight ? d.attrs.strokeHeight : n / 2
                      , p = i + g + n / 2;
                    c = o.drawLine(d.x, p - 2 * g, d.x, p, d.attrs.strokeColor ? d.attrs.strokeColor : void 0, d.attrs.strokeDashArray, d.attrs.strokeWidth ? d.attrs.strokeWidth : 2, d.attrs.strokeLineCap),
                    l.add(c)
                }) : Array.isArray(a) && a.forEach(function(d) {
                    var g = void 0 !== d.attrs.strokeWidth ? d.attrs.strokeWidth : r / 2
                      , p = t + g + r / 2;
                    c = o.drawLine(p - 2 * g, d.y, p, d.y, d.attrs.strokeColor ? d.attrs.strokeColor : void 0, d.attrs.strokeDashArray, d.attrs.strokeHeight ? d.attrs.strokeHeight : 2, d.attrs.strokeLineCap),
                    l.add(c)
                }),
                l
            }
        }]),
        y
    }()
      , Je = function() {
        function y(e, t) {
            W(this, y),
            this.ctx = e,
            this.w = e.w;
            var i = this.w;
            this.barOptions = i.config.plotOptions.bar,
            this.isHorizontal = this.barOptions.horizontal,
            this.strokeWidth = i.config.stroke.width,
            this.isNullValue = !1,
            this.isRangeBar = i.globals.seriesRangeBar.length && this.isHorizontal,
            this.xyRatios = t,
            null !== this.xyRatios && (this.xRatio = t.xRatio,
            this.initialXRatio = t.initialXRatio,
            this.yRatio = t.yRatio,
            this.invertedXRatio = t.invertedXRatio,
            this.invertedYRatio = t.invertedYRatio,
            this.baseLineY = t.baseLineY,
            this.baseLineInvertedY = t.baseLineInvertedY),
            this.yaxisIndex = 0,
            this.seriesLen = 0,
            this.barHelpers = new ht(this)
        }
        return V(y, [{
            key: "draw",
            value: function(e, t) {
                var i = this.w
                  , s = new D(this.ctx)
                  , a = new xe(this.ctx,i);
                e = a.getLogSeries(e),
                this.series = e,
                this.yRatio = a.getLogYRatios(this.yRatio),
                this.barHelpers.initVariables(e);
                var r = s.group({
                    class: "apexcharts-bar-series apexcharts-plot-series"
                });
                i.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering.");
                for (var n = 0, o = 0; n < e.length; n++,
                o++) {
                    var l, c, d, g, p = void 0, m = void 0, x = [], v = [], k = i.globals.comboCharts ? t[n] : n, S = s.group({
                        class: "apexcharts-series",
                        rel: n + 1,
                        seriesName: M.escapeString(i.globals.seriesNames[k]),
                        "data:realIndex": k
                    });
                    this.ctx.series.addCollapsedClassToSeries(S, k),
                    e[n].length > 0 && (this.visibleI = this.visibleI + 1);
                    var C = 0
                      , h = 0;
                    this.yRatio.length > 1 && (this.yaxisIndex = k),
                    this.isReversed = i.config.yaxis[this.yaxisIndex] && i.config.yaxis[this.yaxisIndex].reversed;
                    var u = this.barHelpers.initialPositions();
                    m = u.y,
                    C = u.barHeight,
                    c = u.yDivision,
                    g = u.zeroW,
                    p = u.x,
                    h = u.barWidth,
                    l = u.xDivision,
                    d = u.zeroH,
                    this.horizontal || v.push(p + h / 2);
                    for (var b = s.group({
                        class: "apexcharts-datalabels",
                        "data:realIndex": k
                    }), w = s.group({
                        class: "apexcharts-bar-goals-markers",
                        style: "pointer-events: none"
                    }), _ = 0; _ < i.globals.dataPoints; _++) {
                        var X = this.barHelpers.getStrokeWidth(n, _, k)
                          , I = null
                          , R = {
                            indexes: {
                                i: n,
                                j: _,
                                realIndex: k,
                                bc: o
                            },
                            x: p,
                            y: m,
                            strokeWidth: X,
                            elSeries: S
                        };
                        this.isHorizontal ? (I = this.drawBarPaths(Z(Z({}, R), {}, {
                            barHeight: C,
                            zeroW: g,
                            yDivision: c
                        })),
                        h = this.series[n][_] / this.invertedYRatio) : (I = this.drawColumnPaths(Z(Z({}, R), {}, {
                            xDivision: l,
                            barWidth: h,
                            zeroH: d
                        })),
                        C = this.series[n][_] / this.yRatio[this.yaxisIndex]);
                        var H = this.barHelpers.drawGoalLine({
                            barXPosition: I.barXPosition,
                            barYPosition: I.barYPosition,
                            goalX: I.goalX,
                            goalY: I.goalY,
                            barHeight: C,
                            barWidth: h
                        });
                        H && w.add(H),
                        m = I.y,
                        p = I.x,
                        _ > 0 && v.push(p + h / 2),
                        x.push(m);
                        var G = this.barHelpers.getPathFillColor(e, n, _, k);
                        this.renderSeries({
                            realIndex: k,
                            pathFill: G,
                            j: _,
                            i: n,
                            pathFrom: I.pathFrom,
                            pathTo: I.pathTo,
                            strokeWidth: X,
                            elSeries: S,
                            x: p,
                            y: m,
                            series: e,
                            barHeight: C,
                            barWidth: h,
                            elDataLabelsWrap: b,
                            elGoalsMarkers: w,
                            visibleSeries: this.visibleI,
                            type: "bar"
                        })
                    }
                    i.globals.seriesXvalues[k] = v,
                    i.globals.seriesYvalues[k] = x,
                    r.add(S)
                }
                return r
            }
        }, {
            key: "renderSeries",
            value: function(e) {
                var t = e.realIndex
                  , i = e.pathFill
                  , s = e.lineFill
                  , a = e.j
                  , r = e.i
                  , n = e.pathFrom
                  , o = e.pathTo
                  , l = e.strokeWidth
                  , c = e.elSeries
                  , d = e.x
                  , g = e.y
                  , p = e.y1
                  , m = e.y2
                  , x = e.series
                  , v = e.barHeight
                  , k = e.barWidth
                  , S = e.barYPosition
                  , C = e.elDataLabelsWrap
                  , h = e.elGoalsMarkers
                  , u = e.visibleSeries
                  , b = e.type
                  , w = this.w
                  , _ = new D(this.ctx);
                s || (s = this.barOptions.distributed ? w.globals.stroke.colors[a] : w.globals.stroke.colors[t]),
                w.config.series[r].data[a] && w.config.series[r].data[a].strokeColor && (s = w.config.series[r].data[a].strokeColor),
                this.isNullValue && (i = "none");
                var I = _.renderPaths({
                    i: r,
                    j: a,
                    realIndex: t,
                    pathFrom: n,
                    pathTo: o,
                    stroke: s,
                    strokeWidth: l,
                    strokeLineCap: w.config.stroke.lineCap,
                    fill: i,
                    animationDelay: a / w.config.chart.animations.animateGradually.delay * (w.config.chart.animations.speed / w.globals.dataPoints) / 2.4,
                    initialSpeed: w.config.chart.animations.speed,
                    dataChangeSpeed: w.config.chart.animations.dynamicAnimation.speed,
                    className: "apexcharts-".concat(b, "-area")
                });
                I.attr("clip-path", "url(#gridRectMask".concat(w.globals.cuid, ")"));
                var R = w.config.forecastDataPoints;
                R.count > 0 && a >= w.globals.dataPoints - R.count && (I.node.setAttribute("stroke-dasharray", R.dashArray),
                I.node.setAttribute("stroke-width", R.strokeWidth),
                I.node.setAttribute("fill-opacity", R.fillOpacity)),
                void 0 !== p && void 0 !== m && (I.attr("data-range-y1", p),
                I.attr("data-range-y2", m)),
                new me(this.ctx).setSelectionFilter(I, t, a),
                c.add(I);
                var H = new lt(this).handleBarDataLabels({
                    x: d,
                    y: g,
                    y1: p,
                    y2: m,
                    i: r,
                    j: a,
                    series: x,
                    realIndex: t,
                    barHeight: v,
                    barWidth: k,
                    barYPosition: S,
                    renderedPath: I,
                    visibleSeries: u
                });
                return null !== H && C.add(H),
                c.add(C),
                h && c.add(h),
                c
            }
        }, {
            key: "drawBarPaths",
            value: function(e) {
                var r, t = e.indexes, i = e.barHeight, s = e.strokeWidth, a = e.zeroW, n = e.y, o = e.yDivision, l = e.elSeries, c = this.w, d = t.i, g = t.j;
                c.globals.isXNumeric && (n = (c.globals.seriesX[d][g] - c.globals.minX) / this.invertedXRatio - i);
                var p = n + i * this.visibleI;
                r = this.barHelpers.getXForValue(this.series[d][g], a);
                var m = this.barHelpers.getBarpaths({
                    barYPosition: p,
                    barHeight: i,
                    x1: a,
                    x2: r,
                    strokeWidth: s,
                    series: this.series,
                    realIndex: t.realIndex,
                    i: d,
                    j: g,
                    w: c
                });
                return c.globals.isXNumeric || (n += o),
                this.barHelpers.barBackground({
                    j: g,
                    i: d,
                    y1: p - i * this.visibleI,
                    y2: i * this.seriesLen,
                    elSeries: l
                }),
                {
                    pathTo: m.pathTo,
                    pathFrom: m.pathFrom,
                    x: r,
                    y: n,
                    goalX: this.barHelpers.getGoalValues("x", a, null, d, g),
                    barYPosition: p
                }
            }
        }, {
            key: "drawColumnPaths",
            value: function(e) {
                var s, t = e.indexes, i = e.x, a = e.xDivision, r = e.barWidth, n = e.zeroH, o = e.strokeWidth, l = e.elSeries, c = this.w, d = t.realIndex, g = t.i, p = t.j, m = t.bc;
                if (c.globals.isXNumeric) {
                    var x = d;
                    c.globals.seriesX[d].length || (x = c.globals.maxValsInArrayIndex),
                    i = (c.globals.seriesX[x][p] - c.globals.minX) / this.xRatio - r * this.seriesLen / 2
                }
                var v = i + r * this.visibleI;
                s = this.barHelpers.getYForValue(this.series[g][p], n);
                var k = this.barHelpers.getColumnPaths({
                    barXPosition: v,
                    barWidth: r,
                    y1: n,
                    y2: s,
                    strokeWidth: o,
                    series: this.series,
                    realIndex: t.realIndex,
                    i: g,
                    j: p,
                    w: c
                });
                return c.globals.isXNumeric || (i += a),
                this.barHelpers.barBackground({
                    bc: m,
                    j: p,
                    i: g,
                    x1: v - o / 2 - r * this.visibleI,
                    x2: r * this.seriesLen + o / 2,
                    elSeries: l
                }),
                {
                    pathTo: k.pathTo,
                    pathFrom: k.pathFrom,
                    x: i,
                    y: s,
                    goalY: this.barHelpers.getGoalValues("y", null, n, g, p),
                    barXPosition: v
                }
            }
        }, {
            key: "getPreviousPath",
            value: function(e, t) {
                for (var i, s = this.w, a = 0; a < s.globals.previousPaths.length; a++) {
                    var r = s.globals.previousPaths[a];
                    r.paths && r.paths.length > 0 && parseInt(r.realIndex, 10) === parseInt(e, 10) && void 0 !== s.globals.previousPaths[a].paths[t] && (i = s.globals.previousPaths[a].paths[t].d)
                }
                return i
            }
        }]),
        y
    }()
      , ge = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w,
            this.months31 = [1, 3, 5, 7, 8, 10, 12],
            this.months30 = [2, 4, 6, 9, 11],
            this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]
        }
        return V(y, [{
            key: "isValidDate",
            value: function(e) {
                return !isNaN(this.parseDate(e))
            }
        }, {
            key: "getTimeStamp",
            value: function(e) {
                return Date.parse(e) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(e).toISOString().substr(0, 25)).getTime() : new Date(e).getTime() : e
            }
        }, {
            key: "getDate",
            value: function(e) {
                return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(e).toUTCString()) : new Date(e)
            }
        }, {
            key: "parseDate",
            value: function(e) {
                var t = Date.parse(e);
                if (!isNaN(t))
                    return this.getTimeStamp(e);
                var i = Date.parse(e.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
                return this.getTimeStamp(i)
            }
        }, {
            key: "parseDateWithTimezone",
            value: function(e) {
                return Date.parse(e.replace(/-/g, "/").replace(/[a-z]+/gi, " "))
            }
        }, {
            key: "formatDate",
            value: function(e, t) {
                var i = this.w.globals.locale
                  , s = this.w.config.xaxis.labels.datetimeUTC
                  , a = ["\0"].concat(pe(i.months))
                  , r = ["\x01"].concat(pe(i.shortMonths))
                  , n = ["\x02"].concat(pe(i.days))
                  , o = ["\x03"].concat(pe(i.shortDays));
                function l(_, X) {
                    var I = _ + "";
                    for (X = X || 2; I.length < X; )
                        I = "0" + I;
                    return I
                }
                var c = s ? e.getUTCFullYear() : e.getFullYear();
                t = (t = (t = t.replace(/(^|[^\\])yyyy+/g, "$1" + c)).replace(/(^|[^\\])yy/g, "$1" + c.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + c);
                var d = (s ? e.getUTCMonth() : e.getMonth()) + 1;
                t = (t = (t = (t = t.replace(/(^|[^\\])MMMM+/g, "$1" + a[0])).replace(/(^|[^\\])MMM/g, "$1" + r[0])).replace(/(^|[^\\])MM/g, "$1" + l(d))).replace(/(^|[^\\])M/g, "$1" + d);
                var g = s ? e.getUTCDate() : e.getDate();
                t = (t = (t = (t = t.replace(/(^|[^\\])dddd+/g, "$1" + n[0])).replace(/(^|[^\\])ddd/g, "$1" + o[0])).replace(/(^|[^\\])dd/g, "$1" + l(g))).replace(/(^|[^\\])d/g, "$1" + g);
                var p = s ? e.getUTCHours() : e.getHours()
                  , m = p > 12 ? p - 12 : 0 === p ? 12 : p;
                t = (t = (t = (t = t.replace(/(^|[^\\])HH+/g, "$1" + l(p))).replace(/(^|[^\\])H/g, "$1" + p)).replace(/(^|[^\\])hh+/g, "$1" + l(m))).replace(/(^|[^\\])h/g, "$1" + m);
                var x = s ? e.getUTCMinutes() : e.getMinutes();
                t = (t = t.replace(/(^|[^\\])mm+/g, "$1" + l(x))).replace(/(^|[^\\])m/g, "$1" + x);
                var v = s ? e.getUTCSeconds() : e.getSeconds();
                t = (t = t.replace(/(^|[^\\])ss+/g, "$1" + l(v))).replace(/(^|[^\\])s/g, "$1" + v);
                var k = s ? e.getUTCMilliseconds() : e.getMilliseconds();
                t = t.replace(/(^|[^\\])fff+/g, "$1" + l(k, 3)),
                k = Math.round(k / 10),
                t = t.replace(/(^|[^\\])ff/g, "$1" + l(k)),
                k = Math.round(k / 10);
                var S = p < 12 ? "AM" : "PM";
                t = (t = (t = t.replace(/(^|[^\\])f/g, "$1" + k)).replace(/(^|[^\\])TT+/g, "$1" + S)).replace(/(^|[^\\])T/g, "$1" + S.charAt(0));
                var C = S.toLowerCase();
                t = (t = t.replace(/(^|[^\\])tt+/g, "$1" + C)).replace(/(^|[^\\])t/g, "$1" + C.charAt(0));
                var h = -e.getTimezoneOffset()
                  , u = s || !h ? "Z" : h > 0 ? "+" : "-";
                if (!s) {
                    var b = (h = Math.abs(h)) % 60;
                    u += l(Math.floor(h / 60)) + ":" + l(b)
                }
                t = t.replace(/(^|[^\\])K/g, "$1" + u);
                var w = (s ? e.getUTCDay() : e.getDay()) + 1;
                return (t = (t = (t = (t = t.replace(new RegExp(n[0],"g"), n[w])).replace(new RegExp(o[0],"g"), o[w])).replace(new RegExp(a[0],"g"), a[d])).replace(new RegExp(r[0],"g"), r[d])).replace(/\\(.)/g, "$1")
            }
        }, {
            key: "getTimeUnitsfromTimestamp",
            value: function(e, t, i) {
                var s = this.w;
                void 0 !== s.config.xaxis.min && (e = s.config.xaxis.min),
                void 0 !== s.config.xaxis.max && (t = s.config.xaxis.max);
                var a = this.getDate(e)
                  , r = this.getDate(t)
                  , n = this.formatDate(a, "yyyy MM dd HH mm ss fff").split(" ")
                  , o = this.formatDate(r, "yyyy MM dd HH mm ss fff").split(" ");
                return {
                    minMillisecond: parseInt(n[6], 10),
                    maxMillisecond: parseInt(o[6], 10),
                    minSecond: parseInt(n[5], 10),
                    maxSecond: parseInt(o[5], 10),
                    minMinute: parseInt(n[4], 10),
                    maxMinute: parseInt(o[4], 10),
                    minHour: parseInt(n[3], 10),
                    maxHour: parseInt(o[3], 10),
                    minDate: parseInt(n[2], 10),
                    maxDate: parseInt(o[2], 10),
                    minMonth: parseInt(n[1], 10) - 1,
                    maxMonth: parseInt(o[1], 10) - 1,
                    minYear: parseInt(n[0], 10),
                    maxYear: parseInt(o[0], 10)
                }
            }
        }, {
            key: "isLeapYear",
            value: function(e) {
                return e % 4 == 0 && e % 100 != 0 || e % 400 == 0
            }
        }, {
            key: "calculcateLastDaysOfMonth",
            value: function(e, t, i) {
                return this.determineDaysOfMonths(e, t) - i
            }
        }, {
            key: "determineDaysOfYear",
            value: function(e) {
                var t = 365;
                return this.isLeapYear(e) && (t = 366),
                t
            }
        }, {
            key: "determineRemainingDaysOfYear",
            value: function(e, t, i) {
                var s = this.daysCntOfYear[t] + i;
                return t > 1 && this.isLeapYear() && s++,
                s
            }
        }, {
            key: "determineDaysOfMonths",
            value: function(e, t) {
                var i = 30;
                switch (e = M.monthMod(e),
                !0) {
                case this.months30.indexOf(e) > -1:
                    2 === e && (i = this.isLeapYear(t) ? 29 : 28);
                    break;
                case this.months31.indexOf(e) > -1:
                default:
                    i = 31
                }
                return i
            }
        }]),
        y
    }()
      , kt = function(y) {
        Fe(t, y);
        var e = Te(t);
        function t() {
            return W(this, t),
            e.apply(this, arguments)
        }
        return V(t, [{
            key: "draw",
            value: function(i, s) {
                var a = this.w
                  , r = new D(this.ctx);
                this.rangeBarOptions = this.w.config.plotOptions.rangeBar,
                this.series = i,
                this.seriesRangeStart = a.globals.seriesRangeStart,
                this.seriesRangeEnd = a.globals.seriesRangeEnd,
                this.barHelpers.initVariables(i);
                for (var n = r.group({
                    class: "apexcharts-rangebar-series apexcharts-plot-series"
                }), o = 0; o < i.length; o++) {
                    var l, c, d, g = void 0, p = void 0, m = void 0, x = a.globals.comboCharts ? s[o] : o, v = r.group({
                        class: "apexcharts-series",
                        seriesName: M.escapeString(a.globals.seriesNames[x]),
                        rel: o + 1,
                        "data:realIndex": x
                    });
                    this.ctx.series.addCollapsedClassToSeries(v, x),
                    i[o].length > 0 && (this.visibleI = this.visibleI + 1);
                    var k = 0
                      , S = 0;
                    this.yRatio.length > 1 && (this.yaxisIndex = x);
                    var C = this.barHelpers.initialPositions();
                    p = C.y,
                    d = C.zeroW,
                    g = C.x,
                    S = C.barWidth,
                    l = C.xDivision,
                    c = C.zeroH;
                    for (var h = r.group({
                        class: "apexcharts-datalabels",
                        "data:realIndex": x
                    }), u = r.group({
                        class: "apexcharts-rangebar-goals-markers",
                        style: "pointer-events: none"
                    }), b = 0; b < a.globals.dataPoints; b++) {
                        var w = this.barHelpers.getStrokeWidth(o, b, x)
                          , _ = this.seriesRangeStart[o][b]
                          , X = this.seriesRangeEnd[o][b]
                          , I = null
                          , R = null
                          , H = {
                            x: g,
                            y: p,
                            strokeWidth: w,
                            elSeries: v
                        };
                        if (m = C.yDivision,
                        k = C.barHeight,
                        this.isHorizontal) {
                            R = p + k * this.visibleI;
                            var G = this.seriesLen;
                            a.config.plotOptions.bar.rangeBarGroupRows && (G = 1);
                            var ie = (m - k * G) / 2;
                            if (void 0 === a.config.series[o].data[b])
                                break;
                            if (a.config.series[o].data[b].x) {
                                var ne = this.detectOverlappingBars({
                                    i: o,
                                    j: b,
                                    barYPosition: R,
                                    srty: ie,
                                    barHeight: k,
                                    yDivision: m,
                                    initPositions: C
                                });
                                k = ne.barHeight,
                                R = ne.barYPosition
                            }
                            S = (I = this.drawRangeBarPaths(Z({
                                indexes: {
                                    i: o,
                                    j: b,
                                    realIndex: x
                                },
                                barHeight: k,
                                barYPosition: R,
                                zeroW: d,
                                yDivision: m,
                                y1: _,
                                y2: X
                            }, H))).barWidth
                        } else
                            k = (I = this.drawRangeColumnPaths(Z({
                                indexes: {
                                    i: o,
                                    j: b,
                                    realIndex: x
                                },
                                zeroH: c,
                                barWidth: S,
                                xDivision: l
                            }, H))).barHeight;
                        var oe = this.barHelpers.drawGoalLine({
                            barXPosition: I.barXPosition,
                            barYPosition: R,
                            goalX: I.goalX,
                            goalY: I.goalY,
                            barHeight: k,
                            barWidth: S
                        });
                        oe && u.add(oe),
                        p = I.y,
                        g = I.x;
                        var ye = this.barHelpers.getPathFillColor(i, o, b, x);
                        this.renderSeries({
                            realIndex: x,
                            pathFill: ye,
                            lineFill: a.globals.stroke.colors[x],
                            j: b,
                            i: o,
                            x: g,
                            y: p,
                            y1: _,
                            y2: X,
                            pathFrom: I.pathFrom,
                            pathTo: I.pathTo,
                            strokeWidth: w,
                            elSeries: v,
                            series: i,
                            barHeight: k,
                            barYPosition: R,
                            barWidth: S,
                            elDataLabelsWrap: h,
                            elGoalsMarkers: u,
                            visibleSeries: this.visibleI,
                            type: "rangebar"
                        })
                    }
                    n.add(v)
                }
                return n
            }
        }, {
            key: "detectOverlappingBars",
            value: function(i) {
                var s = i.i
                  , a = i.j
                  , r = i.barYPosition
                  , n = i.srty
                  , o = i.barHeight
                  , l = i.yDivision
                  , c = i.initPositions
                  , d = this.w
                  , g = []
                  , p = d.config.series[s].data[a].rangeName
                  , m = d.config.series[s].data[a].x
                  , x = d.globals.labels.indexOf(m)
                  , v = d.globals.seriesRangeBar[s].findIndex(function(k) {
                    return k.x === m && k.overlaps.length > 0
                });
                return r = d.config.plotOptions.bar.rangeBarGroupRows ? n + l * x : n + o * this.visibleI + l * x,
                v > -1 && !d.config.plotOptions.bar.rangeBarOverlap && (g = d.globals.seriesRangeBar[s][v].overlaps).indexOf(p) > -1 && (r = (o = c.barHeight / g.length) * this.visibleI + l * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + o * (this.visibleI + g.indexOf(p)) + l * x),
                {
                    barYPosition: r,
                    barHeight: o
                }
            }
        }, {
            key: "drawRangeColumnPaths",
            value: function(i) {
                var s = i.indexes
                  , a = i.x
                  , r = i.xDivision
                  , n = i.barWidth
                  , o = i.zeroH
                  , l = this.w
                  , c = s.i
                  , d = s.j
                  , g = this.yRatio[this.yaxisIndex]
                  , p = s.realIndex
                  , m = this.getRangeValue(p, d)
                  , x = Math.min(m.start, m.end)
                  , v = Math.max(m.start, m.end);
                l.globals.isXNumeric && (a = (l.globals.seriesX[c][d] - l.globals.minX) / this.xRatio - n / 2);
                var k = a + n * this.visibleI;
                null == this.series[c][d] ? x = o : (x = o - x / g,
                v = o - v / g);
                var S = Math.abs(v - x)
                  , C = this.barHelpers.getColumnPaths({
                    barXPosition: k,
                    barWidth: n,
                    y1: x,
                    y2: v,
                    strokeWidth: this.strokeWidth,
                    series: this.seriesRangeEnd,
                    realIndex: s.realIndex,
                    i: p,
                    j: d,
                    w: l
                });
                return l.globals.isXNumeric || (a += r),
                {
                    pathTo: C.pathTo,
                    pathFrom: C.pathFrom,
                    barHeight: S,
                    x: a,
                    y: v,
                    goalY: this.barHelpers.getGoalValues("y", null, o, c, d),
                    barXPosition: k
                }
            }
        }, {
            key: "drawRangeBarPaths",
            value: function(i) {
                var s = i.indexes
                  , a = i.y
                  , o = i.yDivision
                  , l = i.barHeight
                  , c = i.barYPosition
                  , d = i.zeroW
                  , g = this.w
                  , p = d + i.y1 / this.invertedYRatio
                  , m = d + i.y2 / this.invertedYRatio
                  , x = Math.abs(m - p)
                  , v = this.barHelpers.getBarpaths({
                    barYPosition: c,
                    barHeight: l,
                    x1: p,
                    x2: m,
                    strokeWidth: this.strokeWidth,
                    series: this.seriesRangeEnd,
                    i: s.realIndex,
                    realIndex: s.realIndex,
                    j: s.j,
                    w: g
                });
                return g.globals.isXNumeric || (a += o),
                {
                    pathTo: v.pathTo,
                    pathFrom: v.pathFrom,
                    barWidth: x,
                    x: m,
                    goalX: this.barHelpers.getGoalValues("x", d, null, s.realIndex, s.j),
                    y: a
                }
            }
        }, {
            key: "getRangeValue",
            value: function(i, s) {
                var a = this.w;
                return {
                    start: a.globals.seriesRangeStart[i][s],
                    end: a.globals.seriesRangeEnd[i][s]
                }
            }
        }, {
            key: "getTooltipValues",
            value: function(i) {
                var s = i.ctx
                  , a = i.seriesIndex
                  , r = i.dataPointIndex
                  , n = i.y1
                  , o = i.y2
                  , l = i.w
                  , c = l.globals.seriesRangeStart[a][r]
                  , d = l.globals.seriesRangeEnd[a][r]
                  , g = l.globals.labels[r]
                  , p = l.config.series[a].name ? l.config.series[a].name : ""
                  , m = l.config.tooltip.y.formatter
                  , x = l.config.tooltip.y.title.formatter
                  , v = {
                    w: l,
                    seriesIndex: a,
                    dataPointIndex: r,
                    start: c,
                    end: d
                };
                "function" == typeof x && (p = x(p, v)),
                Number.isFinite(n) && Number.isFinite(o) && (c = n,
                d = o,
                l.config.series[a].data[r].x && (g = l.config.series[a].data[r].x + ":"),
                "function" == typeof m && (g = m(g, v)));
                var k = ""
                  , S = ""
                  , C = l.globals.colors[a];
                if (void 0 === l.config.tooltip.x.formatter)
                    if ("datetime" === l.config.xaxis.type) {
                        var h = new ge(s);
                        k = h.formatDate(h.getDate(c), l.config.tooltip.x.format),
                        S = h.formatDate(h.getDate(d), l.config.tooltip.x.format)
                    } else
                        k = c,
                        S = d;
                else
                    k = l.config.tooltip.x.formatter(c),
                    S = l.config.tooltip.x.formatter(d);
                return {
                    start: c,
                    end: d,
                    startVal: k,
                    endVal: S,
                    ylabel: g,
                    color: C,
                    seriesName: p
                }
            }
        }, {
            key: "buildCustomTooltipHTML",
            value: function(i) {
                return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + i.color + '">' + (i.seriesName || "") + '</span></div><div> <span class="category">' + i.ylabel + ' </span> <span class="value start-value">' + i.start + '</span> <span class="separator">-</span> <span class="value end-value">' + i.end + "</span></div></div>"
            }
        }]),
        t
    }(Je)
      , it = function() {
        function y(e) {
            W(this, y),
            this.opts = e
        }
        return V(y, [{
            key: "line",
            value: function() {
                return {
                    chart: {
                        animations: {
                            easing: "swing"
                        }
                    },
                    dataLabels: {
                        enabled: !1
                    },
                    stroke: {
                        width: 5,
                        curve: "straight"
                    },
                    markers: {
                        size: 0,
                        hover: {
                            sizeOffset: 6
                        }
                    },
                    xaxis: {
                        crosshairs: {
                            width: 1
                        }
                    }
                }
            }
        }, {
            key: "sparkline",
            value: function(e) {
                return this.opts.yaxis[0].show = !1,
                this.opts.yaxis[0].title.text = "",
                this.opts.yaxis[0].axisBorder.show = !1,
                this.opts.yaxis[0].axisTicks.show = !1,
                this.opts.yaxis[0].floating = !0,
                M.extend(e, {
                    grid: {
                        show: !1,
                        padding: {
                            left: 0,
                            right: 0,
                            top: 0,
                            bottom: 0
                        }
                    },
                    legend: {
                        show: !1
                    },
                    xaxis: {
                        labels: {
                            show: !1
                        },
                        tooltip: {
                            enabled: !1
                        },
                        axisBorder: {
                            show: !1
                        },
                        axisTicks: {
                            show: !1
                        }
                    },
                    chart: {
                        toolbar: {
                            show: !1
                        },
                        zoom: {
                            enabled: !1
                        }
                    },
                    dataLabels: {
                        enabled: !1
                    }
                })
            }
        }, {
            key: "bar",
            value: function() {
                return {
                    chart: {
                        stacked: !1,
                        animations: {
                            easing: "swing"
                        }
                    },
                    plotOptions: {
                        bar: {
                            dataLabels: {
                                position: "center"
                            }
                        }
                    },
                    dataLabels: {
                        style: {
                            colors: ["#fff"]
                        },
                        background: {
                            enabled: !1
                        }
                    },
                    stroke: {
                        width: 0,
                        lineCap: "round"
                    },
                    fill: {
                        opacity: .85
                    },
                    legend: {
                        markers: {
                            shape: "square",
                            radius: 2,
                            size: 8
                        }
                    },
                    tooltip: {
                        shared: !1,
                        intersect: !0
                    },
                    xaxis: {
                        tooltip: {
                            enabled: !1
                        },
                        tickPlacement: "between",
                        crosshairs: {
                            width: "barWidth",
                            position: "back",
                            fill: {
                                type: "gradient"
                            },
                            dropShadow: {
                                enabled: !1
                            },
                            stroke: {
                                width: 0
                            }
                        }
                    }
                }
            }
        }, {
            key: "candlestick",
            value: function() {
                var e = this;
                return {
                    stroke: {
                        width: 1,
                        colors: ["#333"]
                    },
                    fill: {
                        opacity: 1
                    },
                    dataLabels: {
                        enabled: !1
                    },
                    tooltip: {
                        shared: !0,
                        custom: function(t) {
                            return e._getBoxTooltip(t.w, t.seriesIndex, t.dataPointIndex, ["Open", "High", "", "Low", "Close"], "candlestick")
                        }
                    },
                    states: {
                        active: {
                            filter: {
                                type: "none"
                            }
                        }
                    },
                    xaxis: {
                        crosshairs: {
                            width: 1
                        }
                    }
                }
            }
        }, {
            key: "boxPlot",
            value: function() {
                var e = this;
                return {
                    chart: {
                        animations: {
                            dynamicAnimation: {
                                enabled: !1
                            }
                        }
                    },
                    stroke: {
                        width: 1,
                        colors: ["#24292e"]
                    },
                    dataLabels: {
                        enabled: !1
                    },
                    tooltip: {
                        shared: !0,
                        custom: function(t) {
                            return e._getBoxTooltip(t.w, t.seriesIndex, t.dataPointIndex, ["Minimum", "Q1", "Median", "Q3", "Maximum"], "boxPlot")
                        }
                    },
                    markers: {
                        size: 5,
                        strokeWidth: 1,
                        strokeColors: "#111"
                    },
                    xaxis: {
                        crosshairs: {
                            width: 1
                        }
                    }
                }
            }
        }, {
            key: "rangeBar",
            value: function() {
                return {
                    stroke: {
                        width: 0,
                        lineCap: "square"
                    },
                    plotOptions: {
                        bar: {
                            borderRadius: 0,
                            dataLabels: {
                                position: "center"
                            }
                        }
                    },
                    dataLabels: {
                        enabled: !1,
                        formatter: function(e, t) {
                            var i = t.seriesIndex
                              , s = t.dataPointIndex
                              , a = t.w;
                            return a.globals.seriesRangeEnd[i][s] - a.globals.seriesRangeStart[i][s]
                        },
                        background: {
                            enabled: !1
                        },
                        style: {
                            colors: ["#fff"]
                        }
                    },
                    tooltip: {
                        shared: !1,
                        followCursor: !0,
                        custom: function(e) {
                            return e.w.config.plotOptions && e.w.config.plotOptions.bar && e.w.config.plotOptions.bar.horizontal ? (s = (i = new kt((t = e).ctx,null)).getTooltipValues(t),
                            i.buildCustomTooltipHTML({
                                color: s.color,
                                seriesName: s.seriesName,
                                ylabel: s.ylabel,
                                start: s.startVal,
                                end: s.endVal
                            })) : function(t) {
                                var i = new kt(t.ctx,null)
                                  , s = i.getTooltipValues(t);
                                return i.buildCustomTooltipHTML({
                                    color: s.color,
                                    seriesName: s.seriesName,
                                    ylabel: s.ylabel,
                                    start: s.start,
                                    end: s.end
                                })
                            }(e);
                            var t, i, s
                        }
                    },
                    xaxis: {
                        tickPlacement: "between",
                        tooltip: {
                            enabled: !1
                        },
                        crosshairs: {
                            stroke: {
                                width: 0
                            }
                        }
                    }
                }
            }
        }, {
            key: "area",
            value: function() {
                return {
                    stroke: {
                        width: 4
                    },
                    fill: {
                        type: "gradient",
                        gradient: {
                            inverseColors: !1,
                            shade: "light",
                            type: "vertical",
                            opacityFrom: .65,
                            opacityTo: .5,
                            stops: [0, 100, 100]
                        }
                    },
                    markers: {
                        size: 0,
                        hover: {
                            sizeOffset: 6
                        }
                    },
                    tooltip: {
                        followCursor: !1
                    }
                }
            }
        }, {
            key: "brush",
            value: function(e) {
                return M.extend(e, {
                    chart: {
                        toolbar: {
                            autoSelected: "selection",
                            show: !1
                        },
                        zoom: {
                            enabled: !1
                        }
                    },
                    dataLabels: {
                        enabled: !1
                    },
                    stroke: {
                        width: 1
                    },
                    tooltip: {
                        enabled: !1
                    },
                    xaxis: {
                        tooltip: {
                            enabled: !1
                        }
                    }
                })
            }
        }, {
            key: "stacked100",
            value: function(e) {
                e.dataLabels = e.dataLabels || {},
                e.dataLabels.formatter = e.dataLabels.formatter || void 0;
                var t = e.dataLabels.formatter;
                return e.yaxis.forEach(function(i, s) {
                    e.yaxis[s].min = 0,
                    e.yaxis[s].max = 100
                }),
                "bar" === e.chart.type && (e.dataLabels.formatter = t || function(i) {
                    return "number" == typeof i && i ? i.toFixed(0) + "%" : i
                }
                ),
                e
            }
        }, {
            key: "convertCatToNumeric",
            value: function(e) {
                return e.xaxis.convertedCatToNumeric = !0,
                e
            }
        }, {
            key: "convertCatToNumericXaxis",
            value: function(e, t, i) {
                e.xaxis.type = "numeric",
                e.xaxis.labels = e.xaxis.labels || {},
                e.xaxis.labels.formatter = e.xaxis.labels.formatter || function(r) {
                    return M.isNumber(r) ? Math.floor(r) : r
                }
                ;
                var s = e.xaxis.labels.formatter
                  , a = e.xaxis.categories && e.xaxis.categories.length ? e.xaxis.categories : e.labels;
                return i && i.length && (a = i.map(function(r) {
                    return Array.isArray(r) ? r : String(r)
                })),
                a && a.length && (e.xaxis.labels.formatter = function(r) {
                    return M.isNumber(r) ? s(a[Math.floor(r) - 1]) : s(r)
                }
                ),
                e.xaxis.categories = [],
                e.labels = [],
                e.xaxis.tickAmount = e.xaxis.tickAmount || "dataPoints",
                e
            }
        }, {
            key: "bubble",
            value: function() {
                return {
                    dataLabels: {
                        style: {
                            colors: ["#fff"]
                        }
                    },
                    tooltip: {
                        shared: !1,
                        intersect: !0
                    },
                    xaxis: {
                        crosshairs: {
                            width: 0
                        }
                    },
                    fill: {
                        type: "solid",
                        gradient: {
                            shade: "light",
                            inverse: !0,
                            shadeIntensity: .55,
                            opacityFrom: .4,
                            opacityTo: .8
                        }
                    }
                }
            }
        }, {
            key: "scatter",
            value: function() {
                return {
                    dataLabels: {
                        enabled: !1
                    },
                    tooltip: {
                        shared: !1,
                        intersect: !0
                    },
                    markers: {
                        size: 6,
                        strokeWidth: 1,
                        hover: {
                            sizeOffset: 2
                        }
                    }
                }
            }
        }, {
            key: "heatmap",
            value: function() {
                return {
                    chart: {
                        stacked: !1
                    },
                    fill: {
                        opacity: 1
                    },
                    dataLabels: {
                        style: {
                            colors: ["#fff"]
                        }
                    },
                    stroke: {
                        colors: ["#fff"]
                    },
                    tooltip: {
                        followCursor: !0,
                        marker: {
                            show: !1
                        },
                        x: {
                            show: !1
                        }
                    },
                    legend: {
                        position: "top",
                        markers: {
                            shape: "square",
                            size: 10,
                            offsetY: 2
                        }
                    },
                    grid: {
                        padding: {
                            right: 20
                        }
                    }
                }
            }
        }, {
            key: "treemap",
            value: function() {
                return {
                    chart: {
                        zoom: {
                            enabled: !1
                        }
                    },
                    dataLabels: {
                        style: {
                            fontSize: 14,
                            fontWeight: 600,
                            colors: ["#fff"]
                        }
                    },
                    stroke: {
                        show: !0,
                        width: 2,
                        colors: ["#fff"]
                    },
                    legend: {
                        show: !1
                    },
                    fill: {
                        gradient: {
                            stops: [0, 100]
                        }
                    },
                    tooltip: {
                        followCursor: !0,
                        x: {
                            show: !1
                        }
                    },
                    grid: {
                        padding: {
                            left: 0,
                            right: 0
                        }
                    },
                    xaxis: {
                        crosshairs: {
                            show: !1
                        },
                        tooltip: {
                            enabled: !1
                        }
                    }
                }
            }
        }, {
            key: "pie",
            value: function() {
                return {
                    chart: {
                        toolbar: {
                            show: !1
                        }
                    },
                    plotOptions: {
                        pie: {
                            donut: {
                                labels: {
                                    show: !1
                                }
                            }
                        }
                    },
                    dataLabels: {
                        formatter: function(e) {
                            return e.toFixed(1) + "%"
                        },
                        style: {
                            colors: ["#fff"]
                        },
                        background: {
                            enabled: !1
                        },
                        dropShadow: {
                            enabled: !0
                        }
                    },
                    stroke: {
                        colors: ["#fff"]
                    },
                    fill: {
                        opacity: 1,
                        gradient: {
                            shade: "light",
                            stops: [0, 100]
                        }
                    },
                    tooltip: {
                        theme: "dark",
                        fillSeriesColor: !0
                    },
                    legend: {
                        position: "right"
                    }
                }
            }
        }, {
            key: "donut",
            value: function() {
                return {
                    chart: {
                        toolbar: {
                            show: !1
                        }
                    },
                    dataLabels: {
                        formatter: function(e) {
                            return e.toFixed(1) + "%"
                        },
                        style: {
                            colors: ["#fff"]
                        },
                        background: {
                            enabled: !1
                        },
                        dropShadow: {
                            enabled: !0
                        }
                    },
                    stroke: {
                        colors: ["#fff"]
                    },
                    fill: {
                        opacity: 1,
                        gradient: {
                            shade: "light",
                            shadeIntensity: .35,
                            stops: [80, 100],
                            opacityFrom: 1,
                            opacityTo: 1
                        }
                    },
                    tooltip: {
                        theme: "dark",
                        fillSeriesColor: !0
                    },
                    legend: {
                        position: "right"
                    }
                }
            }
        }, {
            key: "polarArea",
            value: function() {
                return this.opts.yaxis[0].tickAmount = this.opts.yaxis[0].tickAmount ? this.opts.yaxis[0].tickAmount : 6,
                {
                    chart: {
                        toolbar: {
                            show: !1
                        }
                    },
                    dataLabels: {
                        formatter: function(e) {
                            return e.toFixed(1) + "%"
                        },
                        enabled: !1
                    },
                    stroke: {
                        show: !0,
                        width: 2
                    },
                    fill: {
                        opacity: .7
                    },
                    tooltip: {
                        theme: "dark",
                        fillSeriesColor: !0
                    },
                    legend: {
                        position: "right"
                    }
                }
            }
        }, {
            key: "radar",
            value: function() {
                return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6,
                {
                    dataLabels: {
                        enabled: !1,
                        style: {
                            fontSize: "11px"
                        }
                    },
                    stroke: {
                        width: 2
                    },
                    markers: {
                        size: 3,
                        strokeWidth: 1,
                        strokeOpacity: 1
                    },
                    fill: {
                        opacity: .2
                    },
                    tooltip: {
                        shared: !1,
                        intersect: !0,
                        followCursor: !0
                    },
                    grid: {
                        show: !1
                    },
                    xaxis: {
                        labels: {
                            formatter: function(e) {
                                return e
                            },
                            style: {
                                colors: ["#a8a8a8"],
                                fontSize: "11px"
                            }
                        },
                        tooltip: {
                            enabled: !1
                        },
                        crosshairs: {
                            show: !1
                        }
                    }
                }
            }
        }, {
            key: "radialBar",
            value: function() {
                return {
                    chart: {
                        animations: {
                            dynamicAnimation: {
                                enabled: !0,
                                speed: 800
                            }
                        },
                        toolbar: {
                            show: !1
                        }
                    },
                    fill: {
                        gradient: {
                            shade: "dark",
                            shadeIntensity: .4,
                            inverseColors: !1,
                            type: "diagonal2",
                            opacityFrom: 1,
                            opacityTo: 1,
                            stops: [70, 98, 100]
                        }
                    },
                    legend: {
                        show: !1,
                        position: "right"
                    },
                    tooltip: {
                        enabled: !1,
                        fillSeriesColor: !0
                    }
                }
            }
        }, {
            key: "_getBoxTooltip",
            value: function(e, t, i, s, a) {
                var r = e.globals.seriesCandleO[t][i]
                  , n = e.globals.seriesCandleH[t][i]
                  , o = e.globals.seriesCandleM[t][i]
                  , l = e.globals.seriesCandleL[t][i]
                  , c = e.globals.seriesCandleC[t][i];
                return e.config.series[t].type && e.config.series[t].type !== a ? '<div class="apexcharts-custom-tooltip">\n          '.concat(e.config.series[t].name ? e.config.series[t].name : "series-" + (t + 1), ": <strong>").concat(e.globals.series[t][i], "</strong>\n        </div>") : '<div class="apexcharts-tooltip-box apexcharts-tooltip-'.concat(e.config.chart.type, '">') + "<div>".concat(s[0], ': <span class="value">') + r + "</span></div>" + "<div>".concat(s[1], ': <span class="value">') + n + "</span></div>" + (o ? "<div>".concat(s[2], ': <span class="value">') + o + "</span></div>" : "") + "<div>".concat(s[3], ': <span class="value">') + l + "</span></div>" + "<div>".concat(s[4], ': <span class="value">') + c + "</span></div></div>"
            }
        }]),
        y
    }()
      , F = function() {
        function y(e) {
            W(this, y),
            this.opts = e
        }
        return V(y, [{
            key: "init",
            value: function(e) {
                var t = e.responsiveOverride
                  , i = this.opts
                  , s = new He
                  , a = new it(i);
                this.chartType = i.chart.type,
                "histogram" === this.chartType && (i.chart.type = "bar",
                i = M.extend({
                    plotOptions: {
                        bar: {
                            columnWidth: "99.99%"
                        }
                    }
                }, i)),
                i = this.extendYAxis(i),
                i = this.extendAnnotations(i);
                var r = s.init()
                  , n = {};
                if (i && "object" === de(i)) {
                    var o = {};
                    o = -1 !== ["line", "area", "bar", "candlestick", "boxPlot", "rangeBar", "histogram", "bubble", "scatter", "heatmap", "treemap", "pie", "polarArea", "donut", "radar", "radialBar"].indexOf(i.chart.type) ? a[i.chart.type]() : a.line(),
                    i.chart.brush && i.chart.brush.enabled && (o = a.brush(o)),
                    i.chart.stacked && "100%" === i.chart.stackType && (i = a.stacked100(i)),
                    this.checkForDarkTheme(window.Apex),
                    this.checkForDarkTheme(i),
                    i.xaxis = i.xaxis || window.Apex.xaxis || {},
                    t || (i.xaxis.convertedCatToNumeric = !1),
                    ((i = this.checkForCatToNumericXAxis(this.chartType, o, i)).chart.sparkline && i.chart.sparkline.enabled || window.Apex.chart && window.Apex.chart.sparkline && window.Apex.chart.sparkline.enabled) && (o = a.sparkline(o)),
                    n = M.extend(r, o)
                }
                var l = M.extend(n, window.Apex);
                return r = M.extend(l, i),
                this.handleUserInputErrors(r)
            }
        }, {
            key: "checkForCatToNumericXAxis",
            value: function(e, t, i) {
                var s = new it(i);
                return ("bar" === e || "boxPlot" === e) && i.plotOptions && i.plotOptions.bar && i.plotOptions.bar.horizontal || "pie" === e || "polarArea" === e || "donut" === e || "radar" === e || "radialBar" === e || "heatmap" === e || !("datetime" !== i.xaxis.type && "numeric" !== i.xaxis.type) || "between" === (i.xaxis.tickPlacement ? i.xaxis.tickPlacement : t.xaxis && t.xaxis.tickPlacement) || (i = s.convertCatToNumeric(i)),
                i
            }
        }, {
            key: "extendYAxis",
            value: function(e, t) {
                var i = new He;
                (void 0 === e.yaxis || !e.yaxis || Array.isArray(e.yaxis) && 0 === e.yaxis.length) && (e.yaxis = {}),
                e.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (e.yaxis = M.extend(e.yaxis, window.Apex.yaxis)),
                e.yaxis = e.yaxis.constructor !== Array ? [M.extend(i.yAxis, e.yaxis)] : M.extendArray(e.yaxis, i.yAxis);
                var s = !1;
                e.yaxis.forEach(function(r) {
                    r.logarithmic && (s = !0)
                });
                var a = e.series;
                return t && !a && (a = t.config.series),
                s && a.length !== e.yaxis.length && a.length && (e.yaxis = a.map(function(r, n) {
                    if (r.name || (a[n].name = "series-".concat(n + 1)),
                    e.yaxis[n])
                        return e.yaxis[n].seriesName = a[n].name,
                        e.yaxis[n];
                    var o = M.extend(i.yAxis, e.yaxis[0]);
                    return o.show = !1,
                    o
                })),
                s && a.length > 1 && a.length !== e.yaxis.length && console.warn("A multi-series logarithmic chart should have equal number of series and y-axes. Please make sure to equalize both."),
                e
            }
        }, {
            key: "extendAnnotations",
            value: function(e) {
                return void 0 === e.annotations && (e.annotations = {},
                e.annotations.yaxis = [],
                e.annotations.xaxis = [],
                e.annotations.points = []),
                e = this.extendYAxisAnnotations(e),
                e = this.extendXAxisAnnotations(e),
                this.extendPointAnnotations(e)
            }
        }, {
            key: "extendYAxisAnnotations",
            value: function(e) {
                var t = new He;
                return e.annotations.yaxis = M.extendArray(void 0 !== e.annotations.yaxis ? e.annotations.yaxis : [], t.yAxisAnnotation),
                e
            }
        }, {
            key: "extendXAxisAnnotations",
            value: function(e) {
                var t = new He;
                return e.annotations.xaxis = M.extendArray(void 0 !== e.annotations.xaxis ? e.annotations.xaxis : [], t.xAxisAnnotation),
                e
            }
        }, {
            key: "extendPointAnnotations",
            value: function(e) {
                var t = new He;
                return e.annotations.points = M.extendArray(void 0 !== e.annotations.points ? e.annotations.points : [], t.pointAnnotation),
                e
            }
        }, {
            key: "checkForDarkTheme",
            value: function(e) {
                e.theme && "dark" === e.theme.mode && (e.tooltip || (e.tooltip = {}),
                "light" !== e.tooltip.theme && (e.tooltip.theme = "dark"),
                e.chart.foreColor || (e.chart.foreColor = "#f6f7f8"),
                e.chart.background || (e.chart.background = "#424242"),
                e.theme.palette || (e.theme.palette = "palette4"))
            }
        }, {
            key: "handleUserInputErrors",
            value: function(e) {
                var t = e;
                if (t.tooltip.shared && t.tooltip.intersect)
                    throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");
                if ("bar" === t.chart.type && t.plotOptions.bar.horizontal) {
                    if (t.yaxis.length > 1)
                        throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
                    t.yaxis[0].reversed && (t.yaxis[0].opposite = !0),
                    t.xaxis.tooltip.enabled = !1,
                    t.yaxis[0].tooltip.enabled = !1,
                    t.chart.zoom.enabled = !1
                }
                return "bar" !== t.chart.type && "rangeBar" !== t.chart.type || t.tooltip.shared && "barWidth" === t.xaxis.crosshairs.width && t.series.length > 1 && (t.xaxis.crosshairs.width = "tickWidth"),
                "candlestick" !== t.chart.type && "boxPlot" !== t.chart.type || t.yaxis[0].reversed && (console.warn("Reversed y-axis in ".concat(t.chart.type, " chart is not supported.")),
                t.yaxis[0].reversed = !1),
                Array.isArray(t.stroke.width) && "line" !== t.chart.type && "area" !== t.chart.type && (console.warn("stroke.width option accepts array only for line and area charts. Reverted back to Number"),
                t.stroke.width = t.stroke.width[0]),
                t
            }
        }]),
        y
    }()
      , At = function() {
        function y() {
            W(this, y)
        }
        return V(y, [{
            key: "initGlobalVars",
            value: function(e) {
                e.series = [],
                e.seriesCandleO = [],
                e.seriesCandleH = [],
                e.seriesCandleM = [],
                e.seriesCandleL = [],
                e.seriesCandleC = [],
                e.seriesRangeStart = [],
                e.seriesRangeEnd = [],
                e.seriesRangeBar = [],
                e.seriesPercent = [],
                e.seriesGoals = [],
                e.seriesX = [],
                e.seriesZ = [],
                e.seriesNames = [],
                e.seriesTotals = [],
                e.seriesLog = [],
                e.seriesColors = [],
                e.stackedSeriesTotals = [],
                e.seriesXvalues = [],
                e.seriesYvalues = [],
                e.labels = [],
                e.categoryLabels = [],
                e.timescaleLabels = [],
                e.noLabelsProvided = !1,
                e.resizeTimer = null,
                e.selectionResizeTimer = null,
                e.delayedElements = [],
                e.pointsArray = [],
                e.dataLabelsRects = [],
                e.isXNumeric = !1,
                e.xaxisLabelsCount = 0,
                e.skipLastTimelinelabel = !1,
                e.skipFirstTimelinelabel = !1,
                e.isDataXYZ = !1,
                e.isMultiLineX = !1,
                e.isMultipleYAxis = !1,
                e.maxY = -Number.MAX_VALUE,
                e.minY = Number.MIN_VALUE,
                e.minYArr = [],
                e.maxYArr = [],
                e.maxX = -Number.MAX_VALUE,
                e.minX = Number.MAX_VALUE,
                e.initialMaxX = -Number.MAX_VALUE,
                e.initialMinX = Number.MAX_VALUE,
                e.maxDate = 0,
                e.minDate = Number.MAX_VALUE,
                e.minZ = Number.MAX_VALUE,
                e.maxZ = -Number.MAX_VALUE,
                e.minXDiff = Number.MAX_VALUE,
                e.yAxisScale = [],
                e.xAxisScale = null,
                e.xAxisTicksPositions = [],
                e.yLabelsCoords = [],
                e.yTitleCoords = [],
                e.barPadForNumericAxis = 0,
                e.padHorizontal = 0,
                e.xRange = 0,
                e.yRange = [],
                e.zRange = 0,
                e.dataPoints = 0,
                e.xTickAmount = 0
            }
        }, {
            key: "globalVars",
            value: function(e) {
                return {
                    chartID: null,
                    cuid: null,
                    events: {
                        beforeMount: [],
                        mounted: [],
                        updated: [],
                        clicked: [],
                        selection: [],
                        dataPointSelection: [],
                        zoomed: [],
                        scrolled: []
                    },
                    colors: [],
                    clientX: null,
                    clientY: null,
                    fill: {
                        colors: []
                    },
                    stroke: {
                        colors: []
                    },
                    dataLabels: {
                        style: {
                            colors: []
                        }
                    },
                    radarPolygons: {
                        fill: {
                            colors: []
                        }
                    },
                    markers: {
                        colors: [],
                        size: e.markers.size,
                        largestSize: 0
                    },
                    animationEnded: !1,
                    isTouchDevice: "ontouchstart"in window || navigator.msMaxTouchPoints,
                    isDirty: !1,
                    isExecCalled: !1,
                    initialConfig: null,
                    initialSeries: [],
                    lastXAxis: [],
                    lastYAxis: [],
                    columnSeries: null,
                    labels: [],
                    timescaleLabels: [],
                    noLabelsProvided: !1,
                    allSeriesCollapsed: !1,
                    collapsedSeries: [],
                    collapsedSeriesIndices: [],
                    ancillaryCollapsedSeries: [],
                    ancillaryCollapsedSeriesIndices: [],
                    risingSeries: [],
                    dataFormatXNumeric: !1,
                    capturedSeriesIndex: -1,
                    capturedDataPointIndex: -1,
                    selectedDataPoints: [],
                    goldenPadding: 35,
                    invalidLogScale: !1,
                    ignoreYAxisIndexes: [],
                    yAxisSameScaleIndices: [],
                    maxValsInArrayIndex: 0,
                    radialSize: 0,
                    selection: void 0,
                    zoomEnabled: "zoom" === e.chart.toolbar.autoSelected && e.chart.toolbar.tools.zoom && e.chart.zoom.enabled,
                    panEnabled: "pan" === e.chart.toolbar.autoSelected && e.chart.toolbar.tools.pan,
                    selectionEnabled: "selection" === e.chart.toolbar.autoSelected && e.chart.toolbar.tools.selection,
                    yaxis: null,
                    mousedown: !1,
                    lastClientPosition: {},
                    visibleXRange: void 0,
                    yValueDecimal: 0,
                    total: 0,
                    SVGNS: "http://www.w3.org/2000/svg",
                    svgWidth: 0,
                    svgHeight: 0,
                    noData: !1,
                    locale: {},
                    dom: {},
                    memory: {
                        methodsToExec: []
                    },
                    shouldAnimate: !0,
                    skipLastTimelinelabel: !1,
                    skipFirstTimelinelabel: !1,
                    delayedElements: [],
                    axisCharts: !0,
                    isDataXYZ: !1,
                    resized: !1,
                    resizeTimer: null,
                    comboCharts: !1,
                    dataChanged: !1,
                    previousPaths: [],
                    allSeriesHasEqualX: !0,
                    pointsArray: [],
                    dataLabelsRects: [],
                    lastDrawnDataLabelsIndexes: [],
                    hasNullValues: !1,
                    easing: null,
                    zoomed: !1,
                    gridWidth: 0,
                    gridHeight: 0,
                    rotateXLabels: !1,
                    defaultLabels: !1,
                    xLabelFormatter: void 0,
                    yLabelFormatters: [],
                    xaxisTooltipFormatter: void 0,
                    ttKeyFormatter: void 0,
                    ttVal: void 0,
                    ttZFormatter: void 0,
                    LINE_HEIGHT_RATIO: 1.618,
                    xAxisLabelsHeight: 0,
                    xAxisLabelsWidth: 0,
                    yAxisLabelsWidth: 0,
                    scaleX: 1,
                    scaleY: 1,
                    translateX: 0,
                    translateY: 0,
                    translateYAxisX: [],
                    yAxisWidths: [],
                    translateXAxisY: 0,
                    translateXAxisX: 0,
                    tooltip: null
                }
            }
        }, {
            key: "init",
            value: function(e) {
                var t = this.globalVars(e);
                return this.initGlobalVars(t),
                t.initialConfig = M.extend({}, e),
                t.initialSeries = M.clone(e.series),
                t.lastXAxis = M.clone(t.initialConfig.xaxis),
                t.lastYAxis = M.clone(t.initialConfig.yaxis),
                t
            }
        }]),
        y
    }()
      , It = function() {
        function y(e) {
            W(this, y),
            this.opts = e
        }
        return V(y, [{
            key: "init",
            value: function() {
                var e = new F(this.opts).init({
                    responsiveOverride: !1
                });
                return {
                    config: e,
                    globals: (new At).init(e)
                }
            }
        }]),
        y
    }()
      , ct = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w,
            this.twoDSeries = [],
            this.threeDSeries = [],
            this.twoDSeriesX = [],
            this.seriesGoals = [],
            this.coreUtils = new xe(this.ctx)
        }
        return V(y, [{
            key: "isMultiFormat",
            value: function() {
                return this.isFormatXY() || this.isFormat2DArray()
            }
        }, {
            key: "isFormatXY",
            value: function() {
                var e = this.w.config.series.slice()
                  , t = new ve(this.ctx);
                if (this.activeSeriesIndex = t.getActiveConfigSeriesIndex(),
                void 0 !== e[this.activeSeriesIndex].data && e[this.activeSeriesIndex].data.length > 0 && null !== e[this.activeSeriesIndex].data[0] && void 0 !== e[this.activeSeriesIndex].data[0].x && null !== e[this.activeSeriesIndex].data[0])
                    return !0
            }
        }, {
            key: "isFormat2DArray",
            value: function() {
                var e = this.w.config.series.slice()
                  , t = new ve(this.ctx);
                if (this.activeSeriesIndex = t.getActiveConfigSeriesIndex(),
                void 0 !== e[this.activeSeriesIndex].data && e[this.activeSeriesIndex].data.length > 0 && null != e[this.activeSeriesIndex].data[0] && e[this.activeSeriesIndex].data[0].constructor === Array)
                    return !0
            }
        }, {
            key: "handleFormat2DArray",
            value: function(e, t) {
                for (var i = this.w.config, s = this.w.globals, a = "boxPlot" === i.chart.type || "boxPlot" === i.series[t].type, r = 0; r < e[t].data.length; r++)
                    if (void 0 !== e[t].data[r][1] && (Array.isArray(e[t].data[r][1]) && 4 === e[t].data[r][1].length && !a ? this.twoDSeries.push(M.parseNumber(e[t].data[r][1][3])) : this.twoDSeries.push(M.parseNumber(e[t].data[r].length >= 5 ? e[t].data[r][4] : e[t].data[r][1])),
                    s.dataFormatXNumeric = !0),
                    "datetime" === i.xaxis.type) {
                        var n = new Date(e[t].data[r][0]);
                        n = new Date(n).getTime(),
                        this.twoDSeriesX.push(n)
                    } else
                        this.twoDSeriesX.push(e[t].data[r][0]);
                for (var o = 0; o < e[t].data.length; o++)
                    void 0 !== e[t].data[o][2] && (this.threeDSeries.push(e[t].data[o][2]),
                    s.isDataXYZ = !0)
            }
        }, {
            key: "handleFormatXY",
            value: function(e, t) {
                var i = this.w.config
                  , s = this.w.globals
                  , a = new ge(this.ctx)
                  , r = t;
                s.collapsedSeriesIndices.indexOf(t) > -1 && (r = this.activeSeriesIndex);
                for (var n = 0; n < e[t].data.length; n++)
                    void 0 !== e[t].data[n].y && (Array.isArray(e[t].data[n].y) ? this.twoDSeries.push(M.parseNumber(e[t].data[n].y[e[t].data[n].y.length - 1])) : this.twoDSeries.push(M.parseNumber(e[t].data[n].y))),
                    void 0 !== e[t].data[n].goals && Array.isArray(e[t].data[n].goals) ? (void 0 === this.seriesGoals[t] && (this.seriesGoals[t] = []),
                    this.seriesGoals[t].push(e[t].data[n].goals)) : (void 0 === this.seriesGoals[t] && (this.seriesGoals[t] = []),
                    this.seriesGoals[t].push(null));
                for (var o = 0; o < e[r].data.length; o++) {
                    var l = "string" == typeof e[r].data[o].x
                      , c = Array.isArray(e[r].data[o].x)
                      , d = !c && !!a.isValidDate(e[r].data[o].x.toString());
                    l || d ? l || i.xaxis.convertedCatToNumeric ? "datetime" !== i.xaxis.type || s.isBarHorizontal && s.isRangeData ? (this.fallbackToCategory = !0,
                    this.twoDSeriesX.push(e[r].data[o].x)) : this.twoDSeriesX.push(a.parseDate(e[r].data[o].x)) : "datetime" === i.xaxis.type ? this.twoDSeriesX.push(a.parseDate(e[r].data[o].x.toString())) : (s.dataFormatXNumeric = !0,
                    s.isXNumeric = !0,
                    this.twoDSeriesX.push(parseFloat(e[r].data[o].x))) : c ? (this.fallbackToCategory = !0,
                    this.twoDSeriesX.push(e[r].data[o].x)) : (s.isXNumeric = !0,
                    s.dataFormatXNumeric = !0,
                    this.twoDSeriesX.push(e[r].data[o].x))
                }
                if (e[t].data[0] && void 0 !== e[t].data[0].z) {
                    for (var p = 0; p < e[t].data.length; p++)
                        this.threeDSeries.push(e[t].data[p].z);
                    s.isDataXYZ = !0
                }
            }
        }, {
            key: "handleRangeData",
            value: function(e, t) {
                var i = this.w.globals
                  , s = {};
                return this.isFormat2DArray() ? s = this.handleRangeDataFormat("array", e, t) : this.isFormatXY() && (s = this.handleRangeDataFormat("xy", e, t)),
                i.seriesRangeStart.push(s.start),
                i.seriesRangeEnd.push(s.end),
                i.seriesRangeBar.push(s.rangeUniques),
                i.seriesRangeBar.forEach(function(a, r) {
                    a && a.forEach(function(n, o) {
                        n.y.forEach(function(l, c) {
                            for (var d = 0; d < n.y.length; d++)
                                c !== d && l.y1 <= n.y[d].y2 && n.y[d].y1 <= l.y2 && (n.overlaps.indexOf(l.rangeName) < 0 && n.overlaps.push(l.rangeName),
                                n.overlaps.indexOf(n.y[d].rangeName) < 0 && n.overlaps.push(n.y[d].rangeName))
                        })
                    })
                }),
                s
            }
        }, {
            key: "handleCandleStickBoxData",
            value: function(e, t) {
                var i = this.w.globals
                  , s = {};
                return this.isFormat2DArray() ? s = this.handleCandleStickBoxDataFormat("array", e, t) : this.isFormatXY() && (s = this.handleCandleStickBoxDataFormat("xy", e, t)),
                i.seriesCandleO[t] = s.o,
                i.seriesCandleH[t] = s.h,
                i.seriesCandleM[t] = s.m,
                i.seriesCandleL[t] = s.l,
                i.seriesCandleC[t] = s.c,
                s
            }
        }, {
            key: "handleRangeDataFormat",
            value: function(e, t, i) {
                var s = []
                  , a = []
                  , r = t[i].data.filter(function(g, p, m) {
                    return p === m.findIndex(function(x) {
                        return x.x === g.x
                    })
                }).map(function(g, p) {
                    return {
                        x: g.x,
                        overlaps: [],
                        y: []
                    }
                })
                  , n = "Please provide [Start, End] values in valid format. Read more https://apexcharts.com/docs/series/#rangecharts"
                  , o = new ve(this.ctx).getActiveConfigSeriesIndex();
                if ("array" === e) {
                    if (2 !== t[o].data[0][1].length)
                        throw new Error(n);
                    for (var l = 0; l < t[i].data.length; l++)
                        s.push(t[i].data[l][1][0]),
                        a.push(t[i].data[l][1][1])
                } else if ("xy" === e) {
                    if (2 !== t[o].data[0].y.length)
                        throw new Error(n);
                    for (var c = function(g) {
                        var p = M.randomId()
                          , m = t[i].data[g].x
                          , x = {
                            y1: t[i].data[g].y[0],
                            y2: t[i].data[g].y[1],
                            rangeName: p
                        };
                        t[i].data[g].rangeName = p;
                        var v = r.findIndex(function(k) {
                            return k.x === m
                        });
                        r[v].y.push(x),
                        s.push(x.y1),
                        a.push(x.y2)
                    }, d = 0; d < t[i].data.length; d++)
                        c(d)
                }
                return {
                    start: s,
                    end: a,
                    rangeUniques: r
                }
            }
        }, {
            key: "handleCandleStickBoxDataFormat",
            value: function(e, t, i) {
                var s = this.w
                  , a = "boxPlot" === s.config.chart.type || "boxPlot" === s.config.series[i].type
                  , r = []
                  , n = []
                  , o = []
                  , l = []
                  , c = [];
                if ("array" === e)
                    if (a && 6 === t[i].data[0].length || !a && 5 === t[i].data[0].length)
                        for (var d = 0; d < t[i].data.length; d++)
                            r.push(t[i].data[d][1]),
                            n.push(t[i].data[d][2]),
                            a ? (o.push(t[i].data[d][3]),
                            l.push(t[i].data[d][4]),
                            c.push(t[i].data[d][5])) : (l.push(t[i].data[d][3]),
                            c.push(t[i].data[d][4]));
                    else
                        for (var g = 0; g < t[i].data.length; g++)
                            Array.isArray(t[i].data[g][1]) && (r.push(t[i].data[g][1][0]),
                            n.push(t[i].data[g][1][1]),
                            a ? (o.push(t[i].data[g][1][2]),
                            l.push(t[i].data[g][1][3]),
                            c.push(t[i].data[g][1][4])) : (l.push(t[i].data[g][1][2]),
                            c.push(t[i].data[g][1][3])));
                else if ("xy" === e)
                    for (var p = 0; p < t[i].data.length; p++)
                        Array.isArray(t[i].data[p].y) && (r.push(t[i].data[p].y[0]),
                        n.push(t[i].data[p].y[1]),
                        a ? (o.push(t[i].data[p].y[2]),
                        l.push(t[i].data[p].y[3]),
                        c.push(t[i].data[p].y[4])) : (l.push(t[i].data[p].y[2]),
                        c.push(t[i].data[p].y[3])));
                return {
                    o: r,
                    h: n,
                    m: o,
                    l,
                    c
                }
            }
        }, {
            key: "parseDataAxisCharts",
            value: function(e) {
                var t = this
                  , i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.ctx
                  , s = this.w.config
                  , a = this.w.globals
                  , r = new ge(i)
                  , n = s.labels.length > 0 ? s.labels.slice() : s.xaxis.categories.slice();
                a.isRangeBar = "rangeBar" === s.chart.type && a.isBarHorizontal;
                for (var o = function() {
                    for (var d = 0; d < n.length; d++)
                        if ("string" == typeof n[d]) {
                            if (!r.isValidDate(n[d]))
                                throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
                            t.twoDSeriesX.push(r.parseDate(n[d]))
                        } else
                            t.twoDSeriesX.push(n[d])
                }, l = 0; l < e.length; l++) {
                    if (this.twoDSeries = [],
                    this.twoDSeriesX = [],
                    this.threeDSeries = [],
                    void 0 === e[l].data)
                        return void console.error("It is a possibility that you may have not included 'data' property in series.");
                    if ("rangeBar" !== s.chart.type && "rangeArea" !== s.chart.type && "rangeBar" !== e[l].type && "rangeArea" !== e[l].type || (a.isRangeData = !0,
                    this.handleRangeData(e, l)),
                    this.isMultiFormat())
                        this.isFormat2DArray() ? this.handleFormat2DArray(e, l) : this.isFormatXY() && this.handleFormatXY(e, l),
                        "candlestick" !== s.chart.type && "candlestick" !== e[l].type && "boxPlot" !== s.chart.type && "boxPlot" !== e[l].type || this.handleCandleStickBoxData(e, l),
                        a.series.push(this.twoDSeries),
                        a.labels.push(this.twoDSeriesX),
                        a.seriesX.push(this.twoDSeriesX),
                        a.seriesGoals = this.seriesGoals,
                        l !== this.activeSeriesIndex || this.fallbackToCategory || (a.isXNumeric = !0);
                    else {
                        "datetime" === s.xaxis.type ? (a.isXNumeric = !0,
                        o(),
                        a.seriesX.push(this.twoDSeriesX)) : "numeric" === s.xaxis.type && (a.isXNumeric = !0,
                        n.length > 0 && (this.twoDSeriesX = n,
                        a.seriesX.push(this.twoDSeriesX))),
                        a.labels.push(this.twoDSeriesX);
                        var c = e[l].data.map(function(d) {
                            return M.parseNumber(d)
                        });
                        a.series.push(c)
                    }
                    a.seriesZ.push(this.threeDSeries),
                    a.seriesNames.push(void 0 !== e[l].name ? e[l].name : "series-" + parseInt(l + 1, 10)),
                    a.seriesColors.push(void 0 !== e[l].color ? e[l].color : void 0)
                }
                return this.w
            }
        }, {
            key: "parseDataNonAxisCharts",
            value: function(e) {
                var t = this.w.globals
                  , i = this.w.config;
                t.series = e.slice(),
                t.seriesNames = i.labels.slice();
                for (var s = 0; s < t.series.length; s++)
                    void 0 === t.seriesNames[s] && t.seriesNames.push("series-" + (s + 1));
                return this.w
            }
        }, {
            key: "handleExternalLabelsData",
            value: function(e) {
                var t = this.w.config
                  , i = this.w.globals;
                t.xaxis.categories.length > 0 ? i.labels = t.xaxis.categories : t.labels.length > 0 ? i.labels = t.labels.slice() : this.fallbackToCategory ? (i.labels = i.labels[0],
                i.seriesRangeBar.length && (i.seriesRangeBar.map(function(s) {
                    s.forEach(function(a) {
                        i.labels.indexOf(a.x) < 0 && a.x && i.labels.push(a.x)
                    })
                }),
                i.labels = i.labels.filter(function(s, a, r) {
                    return r.indexOf(s) === a
                })),
                t.xaxis.convertedCatToNumeric && (new it(t).convertCatToNumericXaxis(t, this.ctx, i.seriesX[0]),
                this._generateExternalLabels(e))) : this._generateExternalLabels(e)
            }
        }, {
            key: "_generateExternalLabels",
            value: function(e) {
                var t = this.w.globals
                  , i = this.w.config
                  , s = [];
                if (t.axisCharts) {
                    if (t.series.length > 0)
                        if (this.isFormatXY())
                            for (var a = i.series.map(function(d, g) {
                                return d.data.filter(function(p, m, x) {
                                    return x.findIndex(function(v) {
                                        return v.x === p.x
                                    }) === m
                                })
                            }), r = a.reduce(function(d, g, p, m) {
                                return m[d].length > g.length ? d : p
                            }, 0), n = 0; n < a[r].length; n++)
                                s.push(n + 1);
                        else
                            for (var o = 0; o < t.series[t.maxValsInArrayIndex].length; o++)
                                s.push(o + 1);
                    t.seriesX = [];
                    for (var l = 0; l < e.length; l++)
                        t.seriesX.push(s);
                    t.isXNumeric = !0
                }
                if (0 === s.length) {
                    s = t.axisCharts ? [] : t.series.map(function(d, g) {
                        return g + 1
                    });
                    for (var c = 0; c < e.length; c++)
                        t.seriesX.push(s)
                }
                t.labels = s,
                i.xaxis.convertedCatToNumeric && (t.categoryLabels = s.map(function(d) {
                    return i.xaxis.labels.formatter(d)
                })),
                t.noLabelsProvided = !0
            }
        }, {
            key: "parseData",
            value: function(e) {
                var t = this.w
                  , i = t.config
                  , s = t.globals;
                if (this.excludeCollapsedSeriesInYAxis(),
                this.fallbackToCategory = !1,
                this.ctx.core.resetGlobals(),
                this.ctx.core.isMultipleY(),
                s.axisCharts ? this.parseDataAxisCharts(e) : this.parseDataNonAxisCharts(e),
                this.coreUtils.getLargestSeries(),
                "bar" === i.chart.type && i.chart.stacked) {
                    var a = new ve(this.ctx);
                    s.series = a.setNullSeriesToZeroValues(s.series)
                }
                this.coreUtils.getSeriesTotals(),
                s.axisCharts && this.coreUtils.getStackedSeriesTotals(),
                this.coreUtils.getPercentSeries(),
                s.dataFormatXNumeric || s.isXNumeric && ("numeric" !== i.xaxis.type || 0 !== i.labels.length || 0 !== i.xaxis.categories.length) || this.handleExternalLabelsData(e);
                for (var r = this.coreUtils.getCategoryLabels(s.labels), n = 0; n < r.length; n++)
                    if (Array.isArray(r[n])) {
                        s.isMultiLineX = !0;
                        break
                    }
            }
        }, {
            key: "excludeCollapsedSeriesInYAxis",
            value: function() {
                var e = this
                  , t = this.w;
                t.globals.ignoreYAxisIndexes = t.globals.collapsedSeries.map(function(i, s) {
                    if (e.w.globals.isMultipleYAxis && !t.config.chart.stacked)
                        return i.index
                })
            }
        }]),
        y
    }()
      , ze = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w,
            this.tooltipKeyFormat = "dd MMM"
        }
        return V(y, [{
            key: "xLabelFormat",
            value: function(e, t, i, s) {
                var a = this.w;
                if ("datetime" === a.config.xaxis.type && void 0 === a.config.xaxis.labels.formatter && void 0 === a.config.tooltip.x.formatter) {
                    var r = new ge(this.ctx);
                    return r.formatDate(r.getDate(t), a.config.tooltip.x.format)
                }
                return e(t, i, s)
            }
        }, {
            key: "defaultGeneralFormatter",
            value: function(e) {
                return Array.isArray(e) ? e.map(function(t) {
                    return t
                }) : e
            }
        }, {
            key: "defaultYFormatter",
            value: function(e, t, i) {
                var s = this.w;
                return M.isNumber(e) && (e = e.toFixed(0 !== s.globals.yValueDecimal ? void 0 !== t.decimalsInFloat ? t.decimalsInFloat : s.globals.yValueDecimal : s.globals.maxYArr[i] - s.globals.minYArr[i] < 5 ? 1 : 0)),
                e
            }
        }, {
            key: "setLabelFormatters",
            value: function() {
                var e = this
                  , t = this.w;
                return t.globals.xaxisTooltipFormatter = function(i) {
                    return e.defaultGeneralFormatter(i)
                }
                ,
                t.globals.ttKeyFormatter = function(i) {
                    return e.defaultGeneralFormatter(i)
                }
                ,
                t.globals.ttZFormatter = function(i) {
                    return i
                }
                ,
                t.globals.legendFormatter = function(i) {
                    return e.defaultGeneralFormatter(i)
                }
                ,
                t.globals.xLabelFormatter = void 0 !== t.config.xaxis.labels.formatter ? t.config.xaxis.labels.formatter : function(i) {
                    if (M.isNumber(i)) {
                        if (!t.config.xaxis.convertedCatToNumeric && "numeric" === t.config.xaxis.type) {
                            if (M.isNumber(t.config.xaxis.decimalsInFloat))
                                return i.toFixed(t.config.xaxis.decimalsInFloat);
                            var s = t.globals.maxX - t.globals.minX;
                            return i.toFixed(s > 0 && s < 100 ? 1 : 0)
                        }
                        return i.toFixed(t.globals.isBarHorizontal && t.globals.maxY - t.globals.minYArr < 4 ? 1 : 0)
                    }
                    return i
                }
                ,
                t.globals.ttKeyFormatter = "function" == typeof t.config.tooltip.x.formatter ? t.config.tooltip.x.formatter : t.globals.xLabelFormatter,
                "function" == typeof t.config.xaxis.tooltip.formatter && (t.globals.xaxisTooltipFormatter = t.config.xaxis.tooltip.formatter),
                (Array.isArray(t.config.tooltip.y) || void 0 !== t.config.tooltip.y.formatter) && (t.globals.ttVal = t.config.tooltip.y),
                void 0 !== t.config.tooltip.z.formatter && (t.globals.ttZFormatter = t.config.tooltip.z.formatter),
                void 0 !== t.config.legend.formatter && (t.globals.legendFormatter = t.config.legend.formatter),
                t.config.yaxis.forEach(function(i, s) {
                    t.globals.yLabelFormatters[s] = void 0 !== i.labels.formatter ? i.labels.formatter : function(a) {
                        return t.globals.xyCharts ? Array.isArray(a) ? a.map(function(r) {
                            return e.defaultYFormatter(r, i, s)
                        }) : e.defaultYFormatter(a, i, s) : a
                    }
                }),
                t.globals
            }
        }, {
            key: "heatmapLabelFormatters",
            value: function() {
                var e = this.w;
                if ("heatmap" === e.config.chart.type) {
                    e.globals.yAxisScale[0].result = e.globals.seriesNames.slice();
                    var t = e.globals.seriesNames.reduce(function(i, s) {
                        return i.length > s.length ? i : s
                    }, 0);
                    e.globals.yAxisScale[0].niceMax = t,
                    e.globals.yAxisScale[0].niceMin = t
                }
            }
        }]),
        y
    }()
      , Re = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w
        }
        return V(y, [{
            key: "getLabel",
            value: function(e, t, i, s) {
                var a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : []
                  , r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "12px"
                  , n = this.w
                  , o = void 0 === e[s] ? "" : e[s]
                  , l = o
                  , c = n.globals.xLabelFormatter
                  , d = n.config.xaxis.labels.formatter
                  , g = !1
                  , p = new ze(this.ctx)
                  , m = o;
                l = p.xLabelFormat(c, o, m, {
                    i: s,
                    dateFormatter: new ge(this.ctx).formatDate,
                    w: n
                }),
                void 0 !== d && (l = d(o, e[s], {
                    i: s,
                    dateFormatter: new ge(this.ctx).formatDate,
                    w: n
                }));
                var x = function(C) {
                    var h = null;
                    return t.forEach(function(u) {
                        "month" === u.unit ? h = "year" : "day" === u.unit ? h = "month" : "hour" === u.unit ? h = "day" : "minute" === u.unit && (h = "hour")
                    }),
                    h === C
                };
                t.length > 0 ? (g = x(t[s].unit),
                i = t[s].position,
                l = t[s].value) : "datetime" === n.config.xaxis.type && void 0 === d && (l = ""),
                void 0 === l && (l = ""),
                l = Array.isArray(l) ? l : l.toString();
                var v = new D(this.ctx)
                  , k = {};
                k = n.globals.rotateXLabels ? v.getTextRects(l, parseInt(r, 10), null, "rotate(".concat(n.config.xaxis.labels.rotate, " 0 0)"), !1) : v.getTextRects(l, parseInt(r, 10));
                var S = !n.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
                return !Array.isArray(l) && (0 === l.indexOf("NaN") || 0 === l.toLowerCase().indexOf("invalid") || l.toLowerCase().indexOf("infinity") >= 0 || a.indexOf(l) >= 0 && S) && (l = ""),
                {
                    x: i,
                    text: l,
                    textRect: k,
                    isBold: g
                }
            }
        }, {
            key: "checkLabelBasedOnTickamount",
            value: function(e, t, i) {
                var s = this.w
                  , a = s.config.xaxis.tickAmount;
                return "dataPoints" === a && (a = Math.round(s.globals.gridWidth / 120)),
                a > i || e % Math.round(i / (a + 1)) == 0 || (t.text = ""),
                t
            }
        }, {
            key: "checkForOverflowingLabels",
            value: function(e, t, i, s, a) {
                var r = this.w;
                if (0 === e && r.globals.skipFirstTimelinelabel && (t.text = ""),
                e === i - 1 && r.globals.skipLastTimelinelabel && (t.text = ""),
                r.config.xaxis.labels.hideOverlappingLabels && s.length > 0) {
                    var n = a[a.length - 1];
                    t.x < n.textRect.width / (r.globals.rotateXLabels ? Math.abs(r.config.xaxis.labels.rotate) / 12 : 1.01) + n.x && (t.text = "")
                }
                return t
            }
        }, {
            key: "checkForReversedLabels",
            value: function(e, t) {
                var i = this.w;
                return i.config.yaxis[e] && i.config.yaxis[e].reversed && t.reverse(),
                t
            }
        }, {
            key: "isYAxisHidden",
            value: function(e) {
                var t = this.w
                  , i = new xe(this.ctx);
                return !t.config.yaxis[e].show || !t.config.yaxis[e].showForNullSeries && i.isSeriesNull(e) && -1 === t.globals.collapsedSeriesIndices.indexOf(e)
            }
        }, {
            key: "getYAxisForeColor",
            value: function(e, t) {
                var i = this.w;
                return Array.isArray(e) && i.globals.yAxisScale[t] && this.ctx.theme.pushExtraColors(e, i.globals.yAxisScale[t].result.length, !1),
                e
            }
        }, {
            key: "drawYAxisTicks",
            value: function(e, t, i, s, a, r, n) {
                var o = this.w
                  , l = new D(this.ctx)
                  , c = o.globals.translateY;
                if (s.show && t > 0) {
                    !0 === o.config.yaxis[a].opposite && (e += s.width);
                    for (var d = t; d >= 0; d--) {
                        var g = c + t / 10 + o.config.yaxis[a].labels.offsetY - 1;
                        o.globals.isBarHorizontal && (g = r * d),
                        "heatmap" === o.config.chart.type && (g += r / 2);
                        var p = l.drawLine(e + i.offsetX - s.width + s.offsetX, g + s.offsetY, e + i.offsetX + s.offsetX, g + s.offsetY, s.color);
                        n.add(p),
                        c += r
                    }
                }
            }
        }]),
        y
    }()
      , fe = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w
        }
        return V(y, [{
            key: "scaleSvgNode",
            value: function(e, t) {
                var i = parseFloat(e.getAttributeNS(null, "width"))
                  , s = parseFloat(e.getAttributeNS(null, "height"));
                e.setAttributeNS(null, "width", i * t),
                e.setAttributeNS(null, "height", s * t),
                e.setAttributeNS(null, "viewBox", "0 0 " + i + " " + s)
            }
        }, {
            key: "fixSvgStringForIe11",
            value: function(e) {
                if (!M.isIE11())
                    return e.replace(/&nbsp;/g, "&#160;");
                var t = 0
                  , i = e.replace(/xmlns="http:\/\/www.w3.org\/2000\/svg"/g, function(s) {
                    return 2 == ++t ? 'xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.dev"' : s
                });
                return (i = i.replace(/xmlns:NS\d+=""/g, "")).replace(/NS\d+:(\w+:\w+=")/g, "$1")
            }
        }, {
            key: "getSvgString",
            value: function(e) {
                var t = this.w.globals.dom.Paper.svg();
                if (1 !== e) {
                    var i = this.w.globals.dom.Paper.node.cloneNode(!0);
                    this.scaleSvgNode(i, e),
                    t = (new XMLSerializer).serializeToString(i)
                }
                return this.fixSvgStringForIe11(t)
            }
        }, {
            key: "cleanup",
            value: function() {
                var e = this.w
                  , t = e.globals.dom.baseEl.getElementsByClassName("apexcharts-xcrosshairs")
                  , i = e.globals.dom.baseEl.getElementsByClassName("apexcharts-ycrosshairs")
                  , s = e.globals.dom.baseEl.querySelectorAll(".apexcharts-zoom-rect, .apexcharts-selection-rect");
                Array.prototype.forEach.call(s, function(a) {
                    a.setAttribute("width", 0)
                }),
                t && t[0] && (t[0].setAttribute("x", -500),
                t[0].setAttribute("x1", -500),
                t[0].setAttribute("x2", -500)),
                i && i[0] && (i[0].setAttribute("y", -100),
                i[0].setAttribute("y1", -100),
                i[0].setAttribute("y2", -100))
            }
        }, {
            key: "svgUrl",
            value: function() {
                this.cleanup();
                var e = this.getSvgString()
                  , t = new Blob([e],{
                    type: "image/svg+xml;charset=utf-8"
                });
                return URL.createObjectURL(t)
            }
        }, {
            key: "dataURI",
            value: function(e) {
                var t = this;
                return new Promise(function(i) {
                    var s = t.w
                      , a = e ? e.scale || e.width / s.globals.svgWidth : 1;
                    t.cleanup();
                    var r = document.createElement("canvas");
                    r.width = s.globals.svgWidth * a,
                    r.height = parseInt(s.globals.dom.elWrap.style.height, 10) * a;
                    var n = "transparent" === s.config.chart.background ? "#fff" : s.config.chart.background
                      , o = r.getContext("2d");
                    o.fillStyle = n,
                    o.fillRect(0, 0, r.width * a, r.height * a);
                    var l = t.getSvgString(a);
                    if (window.canvg && M.isIE11()) {
                        var c = window.canvg.Canvg.fromString(o, l, {
                            ignoreClear: !0,
                            ignoreDimensions: !0
                        });
                        c.start();
                        var d = r.msToBlob();
                        c.stop(),
                        i({
                            blob: d
                        })
                    } else {
                        var g = "data:image/svg+xml," + encodeURIComponent(l)
                          , p = new Image;
                        p.crossOrigin = "anonymous",
                        p.onload = function() {
                            if (o.drawImage(p, 0, 0),
                            r.msToBlob) {
                                var m = r.msToBlob();
                                i({
                                    blob: m
                                })
                            } else {
                                var x = r.toDataURL("image/png");
                                i({
                                    imgURI: x
                                })
                            }
                        }
                        ,
                        p.src = g
                    }
                }
                )
            }
        }, {
            key: "exportToSVG",
            value: function() {
                this.triggerDownload(this.svgUrl(), this.w.config.chart.toolbar.export.svg.filename, ".svg")
            }
        }, {
            key: "exportToPng",
            value: function() {
                var e = this;
                this.dataURI().then(function(t) {
                    var i = t.imgURI
                      , s = t.blob;
                    s ? navigator.msSaveOrOpenBlob(s, e.w.globals.chartID + ".png") : e.triggerDownload(i, e.w.config.chart.toolbar.export.png.filename, ".png")
                })
            }
        }, {
            key: "exportToCSV",
            value: function(e) {
                var t = this
                  , i = e.series
                  , s = e.columnDelimiter
                  , a = e.lineDelimiter
                  , r = void 0 === a ? "\n" : a
                  , n = this.w
                  , o = []
                  , l = []
                  , c = ""
                  , d = new ct(this.ctx)
                  , g = new Re(this.ctx)
                  , p = function(m) {
                    var x = "";
                    if (n.globals.axisCharts) {
                        if ("category" === n.config.xaxis.type || n.config.xaxis.convertedCatToNumeric)
                            if (n.globals.isBarHorizontal) {
                                var v = n.globals.yLabelFormatters[0]
                                  , k = new ve(t.ctx).getActiveConfigSeriesIndex();
                                x = v(n.globals.labels[m], {
                                    seriesIndex: k,
                                    dataPointIndex: m,
                                    w: n
                                })
                            } else
                                x = g.getLabel(n.globals.labels, n.globals.timescaleLabels, 0, m).text;
                        "datetime" === n.config.xaxis.type && (n.config.xaxis.categories.length ? x = n.config.xaxis.categories[m] : n.config.labels.length && (x = n.config.labels[m]))
                    } else
                        x = n.config.labels[m];
                    return Array.isArray(x) && (x = x.join(" ")),
                    M.isNumber(x) ? x : x.split(s).join("")
                };
                o.push(n.config.chart.toolbar.export.csv.headerCategory),
                i.map(function(m, x) {
                    var v = m.name ? m.name : "series-".concat(x);
                    n.globals.axisCharts && o.push(v.split(s).join("") ? v.split(s).join("") : "series-".concat(x))
                }),
                n.globals.axisCharts || (o.push(n.config.chart.toolbar.export.csv.headerValue),
                l.push(o.join(s))),
                i.map(function(m, x) {
                    n.globals.axisCharts ? function(v, k) {
                        if (o.length && 0 === k && l.push(o.join(s)),
                        v.data && v.data.length)
                            for (var S = 0; S < v.data.length; S++) {
                                o = [];
                                var C = p(S);
                                if (C || (d.isFormatXY() ? C = i[k].data[S].x : d.isFormat2DArray() && (C = i[k].data[S] ? i[k].data[S][0] : "")),
                                0 === k) {
                                    o.push("datetime" === n.config.xaxis.type && String(C).length >= 10 ? n.config.chart.toolbar.export.csv.dateFormatter(C) : M.isNumber(C) ? C : C.split(s).join(""));
                                    for (var h = 0; h < n.globals.series.length; h++)
                                        o.push(n.globals.series[h][S])
                                }
                                ("candlestick" === n.config.chart.type || v.type && "candlestick" === v.type) && (o.pop(),
                                o.push(n.globals.seriesCandleO[k][S]),
                                o.push(n.globals.seriesCandleH[k][S]),
                                o.push(n.globals.seriesCandleL[k][S]),
                                o.push(n.globals.seriesCandleC[k][S])),
                                ("boxPlot" === n.config.chart.type || v.type && "boxPlot" === v.type) && (o.pop(),
                                o.push(n.globals.seriesCandleO[k][S]),
                                o.push(n.globals.seriesCandleH[k][S]),
                                o.push(n.globals.seriesCandleM[k][S]),
                                o.push(n.globals.seriesCandleL[k][S]),
                                o.push(n.globals.seriesCandleC[k][S])),
                                "rangeBar" === n.config.chart.type && (o.pop(),
                                o.push(n.globals.seriesRangeStart[k][S]),
                                o.push(n.globals.seriesRangeEnd[k][S])),
                                o.length && l.push(o.join(s))
                            }
                    }(m, x) : ((o = []).push(n.globals.labels[x].split(s).join("")),
                    o.push(n.globals.series[x]),
                    l.push(o.join(s)))
                }),
                c += l.join(r),
                this.triggerDownload("data:text/csv; charset=utf-8," + encodeURIComponent("\ufeff" + c), n.config.chart.toolbar.export.csv.filename, ".csv")
            }
        }, {
            key: "triggerDownload",
            value: function(e, t, i) {
                var s = document.createElement("a");
                s.href = e,
                s.download = (t || this.w.globals.chartID) + i,
                document.body.appendChild(s),
                s.click(),
                document.body.removeChild(s)
            }
        }]),
        y
    }()
      , Xe = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w;
            var t = this.w;
            this.axesUtils = new Re(e),
            this.xaxisLabels = t.globals.labels.slice(),
            t.globals.timescaleLabels.length > 0 && !t.globals.isBarHorizontal && (this.xaxisLabels = t.globals.timescaleLabels.slice()),
            t.config.xaxis.overwriteCategories && (this.xaxisLabels = t.config.xaxis.overwriteCategories),
            this.drawnLabels = [],
            this.drawnLabelsRects = [],
            this.offY = "top" === t.config.xaxis.position ? 0 : t.globals.gridHeight + 1,
            this.offY = this.offY + t.config.xaxis.axisBorder.offsetY,
            this.isCategoryBarHorizontal = "bar" === t.config.chart.type && t.config.plotOptions.bar.horizontal,
            this.xaxisFontSize = t.config.xaxis.labels.style.fontSize,
            this.xaxisFontFamily = t.config.xaxis.labels.style.fontFamily,
            this.xaxisForeColors = t.config.xaxis.labels.style.colors,
            this.xaxisBorderWidth = t.config.xaxis.axisBorder.width,
            this.isCategoryBarHorizontal && (this.xaxisBorderWidth = t.config.yaxis[0].axisBorder.width.toString()),
            this.xaxisBorderWidth = this.xaxisBorderWidth.indexOf("%") > -1 ? t.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : parseInt(this.xaxisBorderWidth, 10),
            this.xaxisBorderHeight = t.config.xaxis.axisBorder.height,
            this.yaxis = t.config.yaxis[0]
        }
        return V(y, [{
            key: "drawXaxis",
            value: function() {
                var e, t = this, i = this.w, s = new D(this.ctx), a = s.group({
                    class: "apexcharts-xaxis",
                    transform: "translate(".concat(i.config.xaxis.offsetX, ", ").concat(i.config.xaxis.offsetY, ")")
                }), r = s.group({
                    class: "apexcharts-xaxis-texts-g",
                    transform: "translate(".concat(i.globals.translateXAxisX, ", ").concat(i.globals.translateXAxisY, ")")
                });
                a.add(r);
                for (var n = i.globals.padHorizontal, o = [], l = 0; l < this.xaxisLabels.length; l++)
                    o.push(this.xaxisLabels[l]);
                var c = o.length;
                n = i.globals.isXNumeric ? n + (e = i.globals.gridWidth / (c > 1 ? c - 1 : c)) / 2 + i.config.xaxis.labels.offsetX : n + (e = i.globals.gridWidth / o.length) + i.config.xaxis.labels.offsetX;
                for (var g = function(S) {
                    var C = n - e / 2 + i.config.xaxis.labels.offsetX;
                    0 === S && 1 === c && e / 2 === n && 1 === i.globals.dataPoints && (C = i.globals.gridWidth / 2);
                    var h = t.axesUtils.getLabel(o, i.globals.timescaleLabels, C, S, t.drawnLabels, t.xaxisFontSize)
                      , u = 28;
                    if (i.globals.rotateXLabels && (u = 22),
                    (h = void 0 !== i.config.xaxis.tickAmount && "dataPoints" !== i.config.xaxis.tickAmount && "datetime" !== i.config.xaxis.type ? t.axesUtils.checkLabelBasedOnTickamount(S, h, c) : t.axesUtils.checkForOverflowingLabels(S, h, c, t.drawnLabels, t.drawnLabelsRects)).text && i.globals.xaxisLabelsCount++,
                    i.config.xaxis.labels.show) {
                        var b = s.drawText({
                            x: h.x,
                            y: t.offY + i.config.xaxis.labels.offsetY + u - ("top" === i.config.xaxis.position ? i.globals.xAxisHeight + i.config.xaxis.axisTicks.height - 2 : 0),
                            text: h.text,
                            textAnchor: "middle",
                            fontWeight: h.isBold ? 600 : i.config.xaxis.labels.style.fontWeight,
                            fontSize: t.xaxisFontSize,
                            fontFamily: t.xaxisFontFamily,
                            foreColor: Array.isArray(t.xaxisForeColors) ? i.config.xaxis.convertedCatToNumeric ? t.xaxisForeColors[i.globals.minX + S - 1] : t.xaxisForeColors[S] : t.xaxisForeColors,
                            isPlainText: !1,
                            cssClass: "apexcharts-xaxis-label " + i.config.xaxis.labels.style.cssClass
                        });
                        r.add(b);
                        var w = document.createElementNS(i.globals.SVGNS, "title");
                        w.textContent = Array.isArray(h.text) ? h.text.join(" ") : h.text,
                        b.node.appendChild(w),
                        "" !== h.text && (t.drawnLabels.push(h.text),
                        t.drawnLabelsRects.push(h))
                    }
                    n += e
                }, p = 0; p <= c - 1; p++)
                    g(p);
                if (void 0 !== i.config.xaxis.title.text) {
                    var m = s.group({
                        class: "apexcharts-xaxis-title"
                    })
                      , x = s.drawText({
                        x: i.globals.gridWidth / 2 + i.config.xaxis.title.offsetX,
                        y: this.offY + parseFloat(this.xaxisFontSize) + i.globals.xAxisLabelsHeight + i.config.xaxis.title.offsetY,
                        text: i.config.xaxis.title.text,
                        textAnchor: "middle",
                        fontSize: i.config.xaxis.title.style.fontSize,
                        fontFamily: i.config.xaxis.title.style.fontFamily,
                        fontWeight: i.config.xaxis.title.style.fontWeight,
                        foreColor: i.config.xaxis.title.style.color,
                        cssClass: "apexcharts-xaxis-title-text " + i.config.xaxis.title.style.cssClass
                    });
                    m.add(x),
                    a.add(m)
                }
                if (i.config.xaxis.axisBorder.show) {
                    var v = i.globals.barPadForNumericAxis
                      , k = s.drawLine(i.globals.padHorizontal + i.config.xaxis.axisBorder.offsetX - v, this.offY, this.xaxisBorderWidth + v, this.offY, i.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
                    a.add(k)
                }
                return a
            }
        }, {
            key: "drawXaxisInversed",
            value: function(e) {
                var t, i, s = this, a = this.w, r = new D(this.ctx), n = a.config.yaxis[0].opposite ? a.globals.translateYAxisX[e] : 0, o = r.group({
                    class: "apexcharts-yaxis apexcharts-xaxis-inversed",
                    rel: e
                }), l = r.group({
                    class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g",
                    transform: "translate(" + n + ", 0)"
                });
                o.add(l);
                var c = [];
                if (a.config.yaxis[e].show)
                    for (var d = 0; d < this.xaxisLabels.length; d++)
                        c.push(this.xaxisLabels[d]);
                i = -(t = a.globals.gridHeight / c.length) / 2.2;
                var g = a.globals.yLabelFormatters[0]
                  , p = a.config.yaxis[0].labels;
                if (p.show)
                    for (var m = function(u) {
                        var b = void 0 === c[u] ? "" : c[u];
                        b = g(b, {
                            seriesIndex: e,
                            dataPointIndex: u,
                            w: a
                        });
                        var w = s.axesUtils.getYAxisForeColor(p.style.colors, e)
                          , _ = 0;
                        Array.isArray(b) && (_ = b.length / 2 * parseInt(p.style.fontSize, 10));
                        var X = r.drawText({
                            x: p.offsetX - 15,
                            y: i + t + p.offsetY - _,
                            text: b,
                            textAnchor: s.yaxis.opposite ? "start" : "end",
                            foreColor: Array.isArray(w) ? w[u] : w,
                            fontSize: p.style.fontSize,
                            fontFamily: p.style.fontFamily,
                            fontWeight: p.style.fontWeight,
                            isPlainText: !1,
                            cssClass: "apexcharts-yaxis-label " + p.style.cssClass
                        });
                        l.add(X);
                        var I = document.createElementNS(a.globals.SVGNS, "title");
                        if (I.textContent = Array.isArray(b) ? b.join(" ") : b,
                        X.node.appendChild(I),
                        0 !== a.config.yaxis[e].labels.rotate) {
                            var R = r.rotateAroundCenter(X.node);
                            X.node.setAttribute("transform", "rotate(".concat(a.config.yaxis[e].labels.rotate, " 0 ").concat(R.y, ")"))
                        }
                        i += t
                    }, x = 0; x <= c.length - 1; x++)
                        m(x);
                if (void 0 !== a.config.yaxis[0].title.text) {
                    var v = r.group({
                        class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed",
                        transform: "translate(" + n + ", 0)"
                    })
                      , k = r.drawText({
                        x: 0,
                        y: a.globals.gridHeight / 2,
                        text: a.config.yaxis[0].title.text,
                        textAnchor: "middle",
                        foreColor: a.config.yaxis[0].title.style.color,
                        fontSize: a.config.yaxis[0].title.style.fontSize,
                        fontWeight: a.config.yaxis[0].title.style.fontWeight,
                        fontFamily: a.config.yaxis[0].title.style.fontFamily,
                        cssClass: "apexcharts-yaxis-title-text " + a.config.yaxis[0].title.style.cssClass
                    });
                    v.add(k),
                    o.add(v)
                }
                var S = 0;
                this.isCategoryBarHorizontal && a.config.yaxis[0].opposite && (S = a.globals.gridWidth);
                var C = a.config.xaxis.axisBorder;
                if (C.show) {
                    var h = r.drawLine(a.globals.padHorizontal + C.offsetX + S, 1 + C.offsetY, a.globals.padHorizontal + C.offsetX + S, a.globals.gridHeight + C.offsetY, C.color, 0);
                    o.add(h)
                }
                return a.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(S, c.length, a.config.yaxis[0].axisBorder, a.config.yaxis[0].axisTicks, 0, t, o),
                o
            }
        }, {
            key: "drawXaxisTicks",
            value: function(e, t) {
                var i = this.w
                  , s = e;
                if (!(e < 0 || e - 2 > i.globals.gridWidth)) {
                    var a = this.offY + i.config.xaxis.axisTicks.offsetY
                      , r = a + i.config.xaxis.axisTicks.height;
                    if ("top" === i.config.xaxis.position && (r = a - i.config.xaxis.axisTicks.height),
                    i.config.xaxis.axisTicks.show) {
                        var n = new D(this.ctx).drawLine(e + i.config.xaxis.axisTicks.offsetX, a + i.config.xaxis.offsetY, s + i.config.xaxis.axisTicks.offsetX, r + i.config.xaxis.offsetY, i.config.xaxis.axisTicks.color);
                        t.add(n),
                        n.node.classList.add("apexcharts-xaxis-tick")
                    }
                }
            }
        }, {
            key: "getXAxisTicksPositions",
            value: function() {
                var e = this.w
                  , t = []
                  , i = this.xaxisLabels.length
                  , s = e.globals.padHorizontal;
                if (e.globals.timescaleLabels.length > 0)
                    for (var a = 0; a < i; a++)
                        t.push(s = this.xaxisLabels[a].position);
                else
                    for (var r = i, n = 0; n < r; n++) {
                        var o = r;
                        e.globals.isXNumeric && "bar" !== e.config.chart.type && (o -= 1),
                        t.push(s += e.globals.gridWidth / o)
                    }
                return t
            }
        }, {
            key: "xAxisLabelCorrections",
            value: function() {
                var e = this.w
                  , t = new D(this.ctx)
                  , i = e.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g")
                  , s = e.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text")
                  , a = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text")
                  , r = e.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
                if (e.globals.rotateXLabels || e.config.xaxis.labels.rotateAlways)
                    for (var n = 0; n < s.length; n++) {
                        var o = t.rotateAroundCenter(s[n]);
                        o.y = o.y - 1,
                        o.x = o.x + 1,
                        s[n].setAttribute("transform", "rotate(".concat(e.config.xaxis.labels.rotate, " ").concat(o.x, " ").concat(o.y, ")")),
                        s[n].setAttribute("text-anchor", "end"),
                        i.setAttribute("transform", "translate(0, ".concat(-10, ")")),
                        e.config.xaxis.labels.trim && Array.prototype.forEach.call(s[n].childNodes, function(p) {
                            t.placeTextWithEllipsis(p, p.textContent, e.globals.xAxisLabelsHeight - ("bottom" === e.config.legend.position ? 20 : 10))
                        })
                    }
                else
                    !function() {
                        for (var p = e.globals.gridWidth / (e.globals.labels.length + 1), m = 0; m < s.length; m++)
                            e.config.xaxis.labels.trim && "datetime" !== e.config.xaxis.type && Array.prototype.forEach.call(s[m].childNodes, function(v) {
                                t.placeTextWithEllipsis(v, v.textContent, p)
                            })
                    }();
                if (a.length > 0) {
                    var c = a[a.length - 1].getBBox()
                      , d = a[0].getBBox();
                    c.x < -20 && a[a.length - 1].parentNode.removeChild(a[a.length - 1]),
                    d.x + d.width > e.globals.gridWidth && !e.globals.isBarHorizontal && a[0].parentNode.removeChild(a[0]);
                    for (var g = 0; g < r.length; g++)
                        t.placeTextWithEllipsis(r[g], r[g].textContent, e.config.yaxis[0].labels.maxWidth - 2 * parseFloat(e.config.yaxis[0].title.style.fontSize) - 20)
                }
            }
        }]),
        y
    }()
      , te = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w;
            var t = this.w;
            this.xaxisLabels = t.globals.labels.slice(),
            this.axesUtils = new Re(e),
            this.isRangeBar = t.globals.seriesRangeBar.length,
            t.globals.timescaleLabels.length > 0 && (this.xaxisLabels = t.globals.timescaleLabels.slice())
        }
        return V(y, [{
            key: "drawGridArea",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
                  , t = this.w
                  , i = new D(this.ctx);
                null === e && (e = i.group({
                    class: "apexcharts-grid"
                }));
                var s = i.drawLine(t.globals.padHorizontal, 1, t.globals.padHorizontal, t.globals.gridHeight, "transparent")
                  , a = i.drawLine(t.globals.padHorizontal, t.globals.gridHeight, t.globals.gridWidth, t.globals.gridHeight, "transparent");
                return e.add(a),
                e.add(s),
                e
            }
        }, {
            key: "drawGrid",
            value: function() {
                var e = null;
                return this.w.globals.axisCharts && (e = this.renderGrid(),
                this.drawGridArea(e.el)),
                e
            }
        }, {
            key: "createGridMask",
            value: function() {
                var e = this.w
                  , t = e.globals
                  , i = new D(this.ctx)
                  , s = Array.isArray(e.config.stroke.width) ? 0 : e.config.stroke.width;
                if (Array.isArray(e.config.stroke.width)) {
                    var a = 0;
                    e.config.stroke.width.forEach(function(d) {
                        a = Math.max(a, d)
                    }),
                    s = a
                }
                t.dom.elGridRectMask = document.createElementNS(t.SVGNS, "clipPath"),
                t.dom.elGridRectMask.setAttribute("id", "gridRectMask".concat(t.cuid)),
                t.dom.elGridRectMarkerMask = document.createElementNS(t.SVGNS, "clipPath"),
                t.dom.elGridRectMarkerMask.setAttribute("id", "gridRectMarkerMask".concat(t.cuid)),
                t.dom.elForecastMask = document.createElementNS(t.SVGNS, "clipPath"),
                t.dom.elForecastMask.setAttribute("id", "forecastMask".concat(t.cuid)),
                t.dom.elNonForecastMask = document.createElementNS(t.SVGNS, "clipPath"),
                t.dom.elNonForecastMask.setAttribute("id", "nonForecastMask".concat(t.cuid));
                var r = e.config.chart.type
                  , n = 0
                  , o = 0;
                ("bar" === r || "rangeBar" === r || "candlestick" === r || "boxPlot" === r || e.globals.comboBarCount > 0) && e.globals.isXNumeric && !e.globals.isBarHorizontal && (o = e.config.grid.padding.right,
                t.barPadForNumericAxis > (n = e.config.grid.padding.left) && (n = t.barPadForNumericAxis,
                o = t.barPadForNumericAxis)),
                t.dom.elGridRect = i.drawRect(-s / 2 - n - 2, -s / 2, t.gridWidth + s + o + n + 4, t.gridHeight + s, 0, "#fff"),
                new xe(this).getLargestMarkerSize();
                var l = e.globals.markers.largestSize + 1;
                t.dom.elGridRectMarker = i.drawRect(2 * -l, 2 * -l, t.gridWidth + 4 * l, t.gridHeight + 4 * l, 0, "#fff"),
                t.dom.elGridRectMask.appendChild(t.dom.elGridRect.node),
                t.dom.elGridRectMarkerMask.appendChild(t.dom.elGridRectMarker.node);
                var c = t.dom.baseEl.querySelector("defs");
                c.appendChild(t.dom.elGridRectMask),
                c.appendChild(t.dom.elForecastMask),
                c.appendChild(t.dom.elNonForecastMask),
                c.appendChild(t.dom.elGridRectMarkerMask)
            }
        }, {
            key: "_drawGridLines",
            value: function(e) {
                var t = e.i
                  , i = e.x1
                  , l = this.w;
                0 === t && l.globals.skipFirstTimelinelabel || t === e.xCount - 1 && l.globals.skipLastTimelinelabel && !l.config.xaxis.labels.formatter || "radar" === l.config.chart.type || (l.config.grid.xaxis.lines.show && this._drawGridLine({
                    x1: i,
                    y1: e.y1,
                    x2: e.x2,
                    y2: e.y2,
                    parent: e.parent
                }),
                new Xe(this.ctx).drawXaxisTicks(i, this.elg))
            }
        }, {
            key: "_drawGridLine",
            value: function(e) {
                var t = e.x1
                  , i = e.y1
                  , s = e.x2
                  , a = e.y2
                  , r = e.parent
                  , n = this.w
                  , o = r.node.classList.contains("apexcharts-gridlines-horizontal")
                  , l = n.config.grid.strokeDashArray
                  , c = n.globals.barPadForNumericAxis
                  , d = new D(this).drawLine(t - (o ? c : 0), i, s + (o ? c : 0), a, n.config.grid.borderColor, l);
                d.node.classList.add("apexcharts-gridline"),
                r.add(d)
            }
        }, {
            key: "_drawGridBandRect",
            value: function(e) {
                var t = e.c
                  , i = e.x1
                  , s = e.y1
                  , a = e.x2
                  , r = e.y2
                  , n = e.type
                  , o = this.w
                  , l = new D(this.ctx)
                  , c = o.globals.barPadForNumericAxis;
                if ("column" !== n || "datetime" !== o.config.xaxis.type) {
                    var g = l.drawRect(i - ("row" === n ? c : 0), s, a + ("row" === n ? 2 * c : 0), r, 0, o.config.grid[n].colors[t], o.config.grid[n].opacity);
                    this.elg.add(g),
                    g.attr("clip-path", "url(#gridRectMask".concat(o.globals.cuid, ")")),
                    g.node.classList.add("apexcharts-grid-".concat(n))
                }
            }
        }, {
            key: "_drawXYLines",
            value: function(e) {
                var t = this
                  , i = e.xCount
                  , s = e.tickAmount
                  , a = this.w;
                if (a.config.grid.xaxis.lines.show || a.config.xaxis.axisTicks.show) {
                    var r, n = a.globals.padHorizontal, o = a.globals.gridHeight;
                    a.globals.timescaleLabels.length ? function(m) {
                        for (var x = m.xC, k = m.y1, C = m.y2, h = 0; h < x; h++)
                            t._drawGridLines({
                                i: h,
                                x1: t.xaxisLabels[h].position,
                                y1: k,
                                x2: t.xaxisLabels[h].position,
                                y2: C,
                                xCount: i,
                                parent: t.elgridLinesV
                            })
                    }({
                        xC: i,
                        x1: n,
                        y1: 0,
                        x2: r,
                        y2: o
                    }) : (a.globals.isXNumeric && (i = a.globals.xAxisScale.result.length),
                    a.config.xaxis.convertedCatToNumeric && (i = a.globals.xaxisLabelsCount),
                    function(m) {
                        var x = m.xC
                          , v = m.x1
                          , k = m.y1
                          , S = m.x2
                          , C = m.y2;
                        if (void 0 !== a.config.xaxis.tickAmount && "dataPoints" !== a.config.xaxis.tickAmount)
                            a.globals.dom.baseEl.querySelectorAll(".apexcharts-text.apexcharts-xaxis-label tspan:not(:empty)").forEach(function(u, b) {
                                var w = u.getBBox();
                                t._drawGridLines({
                                    i: b,
                                    x1: w.x + w.width / 2,
                                    y1: k,
                                    x2: w.x + w.width / 2,
                                    y2: C,
                                    xCount: i,
                                    parent: t.elgridLinesV
                                })
                            });
                        else
                            for (var h = 0; h < x + (a.globals.isXNumeric ? 0 : 1); h++)
                                0 === h && 1 === x && 1 === a.globals.dataPoints && (S = v = a.globals.gridWidth / 2),
                                t._drawGridLines({
                                    i: h,
                                    x1: v,
                                    y1: k,
                                    x2: S,
                                    y2: C,
                                    xCount: i,
                                    parent: t.elgridLinesV
                                }),
                                S = v += a.globals.gridWidth / (a.globals.isXNumeric ? x - 1 : x)
                    }({
                        xC: i,
                        x1: n,
                        y1: 0,
                        x2: r,
                        y2: o
                    }))
                }
                if (a.config.grid.yaxis.lines.show) {
                    var l = 0
                      , c = 0
                      , d = a.globals.gridWidth
                      , g = s + 1;
                    this.isRangeBar && (g = a.globals.labels.length);
                    for (var p = 0; p < g + (this.isRangeBar ? 1 : 0); p++)
                        this._drawGridLine({
                            x1: 0,
                            y1: l,
                            x2: d,
                            y2: c,
                            parent: this.elgridLinesH
                        }),
                        c = l += a.globals.gridHeight / (this.isRangeBar ? g : s)
                }
            }
        }, {
            key: "_drawInvertedXYLines",
            value: function(e) {
                var t = e.xCount
                  , i = this.w;
                if (i.config.grid.xaxis.lines.show || i.config.xaxis.axisTicks.show)
                    for (var s, a = i.globals.padHorizontal, r = i.globals.gridHeight, n = 0; n < t + 1; n++)
                        i.config.grid.xaxis.lines.show && this._drawGridLine({
                            x1: a,
                            y1: 0,
                            x2: s,
                            y2: r,
                            parent: this.elgridLinesV
                        }),
                        new Xe(this.ctx).drawXaxisTicks(a, this.elg),
                        s = a = a + i.globals.gridWidth / t + .3;
                if (i.config.grid.yaxis.lines.show)
                    for (var o = 0, l = 0, c = i.globals.gridWidth, d = 0; d < i.globals.dataPoints + 1; d++)
                        this._drawGridLine({
                            x1: 0,
                            y1: o,
                            x2: c,
                            y2: l,
                            parent: this.elgridLinesH
                        }),
                        l = o += i.globals.gridHeight / i.globals.dataPoints
            }
        }, {
            key: "renderGrid",
            value: function() {
                var e = this.w
                  , t = new D(this.ctx);
                this.elg = t.group({
                    class: "apexcharts-grid"
                }),
                this.elgridLinesH = t.group({
                    class: "apexcharts-gridlines-horizontal"
                }),
                this.elgridLinesV = t.group({
                    class: "apexcharts-gridlines-vertical"
                }),
                this.elg.add(this.elgridLinesH),
                this.elg.add(this.elgridLinesV),
                e.config.grid.show || (this.elgridLinesV.hide(),
                this.elgridLinesH.hide());
                for (var i, s = e.globals.yAxisScale.length ? e.globals.yAxisScale[0].result.length - 1 : 5, a = 0; a < e.globals.series.length && (void 0 !== e.globals.yAxisScale[a] && (s = e.globals.yAxisScale[a].result.length - 1),
                !(s > 2)); a++)
                    ;
                return !e.globals.isBarHorizontal || this.isRangeBar ? (i = this.xaxisLabels.length,
                this.isRangeBar && (s = e.globals.labels.length,
                e.config.xaxis.tickAmount && e.config.xaxis.labels.formatter && (i = e.config.xaxis.tickAmount)),
                this._drawXYLines({
                    xCount: i,
                    tickAmount: s
                })) : this._drawInvertedXYLines({
                    xCount: i = s,
                    tickAmount: s = e.globals.xTickAmount
                }),
                this.drawGridBands(i, s),
                {
                    el: this.elg,
                    xAxisTickWidth: e.globals.gridWidth / i
                }
            }
        }, {
            key: "drawGridBands",
            value: function(e, t) {
                var i = this.w;
                if (void 0 !== i.config.grid.row.colors && i.config.grid.row.colors.length > 0)
                    for (var s = 0, a = i.globals.gridHeight / t, r = i.globals.gridWidth, n = 0, o = 0; n < t; n++,
                    o++)
                        o >= i.config.grid.row.colors.length && (o = 0),
                        this._drawGridBandRect({
                            c: o,
                            x1: 0,
                            y1: s,
                            x2: r,
                            y2: a,
                            type: "row"
                        }),
                        s += i.globals.gridHeight / t;
                if (void 0 !== i.config.grid.column.colors && i.config.grid.column.colors.length > 0)
                    for (var l = i.globals.isBarHorizontal || "category" !== i.config.xaxis.type && !i.config.xaxis.convertedCatToNumeric ? e : e - 1, c = i.globals.padHorizontal, d = i.globals.padHorizontal + i.globals.gridWidth / l, g = i.globals.gridHeight, p = 0, m = 0; p < e; p++,
                    m++)
                        m >= i.config.grid.column.colors.length && (m = 0),
                        this._drawGridBandRect({
                            c: m,
                            x1: c,
                            y1: 0,
                            x2: d,
                            y2: g,
                            type: "column"
                        }),
                        c += i.globals.gridWidth / l
            }
        }]),
        y
    }()
      , Be = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w
        }
        return V(y, [{
            key: "niceScale",
            value: function(e, t) {
                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10
                  , s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0
                  , a = arguments.length > 4 ? arguments[4] : void 0
                  , r = this.w
                  , n = Math.abs(t - e);
                if ("dataPoints" === (i = this._adjustTicksForSmallRange(i, s, n)) && (i = r.globals.dataPoints - 1),
                e === Number.MIN_VALUE && 0 === t || !M.isNumber(e) && !M.isNumber(t) || e === Number.MIN_VALUE && t === -Number.MAX_VALUE) {
                    var o = this.linearScale(e = 0, t = i, i);
                    return o
                }
                e > t ? (console.warn("axis.min cannot be greater than axis.max"),
                t = e + .1) : e === t && (e = 0 === e ? 0 : e - .5,
                t = 0 === t ? 2 : t + .5);
                var l = [];
                n < 1 && a && ("candlestick" === r.config.chart.type || "candlestick" === r.config.series[s].type || "boxPlot" === r.config.chart.type || "boxPlot" === r.config.series[s].type || r.globals.isRangeData) && (t *= 1.01);
                var c = i + 1;
                c < 2 ? c = 2 : c > 2 && (c -= 2);
                var d = n / c
                  , g = Math.floor(M.log10(d))
                  , p = Math.pow(10, g)
                  , m = Math.round(d / p);
                m < 1 && (m = 1);
                var x = m * p
                  , v = x * Math.floor(e / x)
                  , k = x * Math.ceil(t / x)
                  , S = v;
                if (a && n > 2) {
                    for (; l.push(S),
                    !((S += x) > k); )
                        ;
                    return {
                        result: l,
                        niceMin: l[0],
                        niceMax: l[l.length - 1]
                    }
                }
                var C = e;
                (l = []).push(C);
                for (var h = Math.abs(t - e) / i, u = 0; u <= i; u++)
                    l.push(C += h);
                return l[l.length - 2] >= t && l.pop(),
                {
                    result: l,
                    niceMin: l[0],
                    niceMax: l[l.length - 1]
                }
            }
        }, {
            key: "linearScale",
            value: function(e, t) {
                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10
                  , s = arguments.length > 3 ? arguments[3] : void 0
                  , a = Math.abs(t - e);
                "dataPoints" === (i = this._adjustTicksForSmallRange(i, s, a)) && (i = this.w.globals.dataPoints - 1);
                var r = a / i;
                i === Number.MAX_VALUE && (i = 10,
                r = 1);
                for (var n = [], o = e; i >= 0; )
                    n.push(o),
                    o += r,
                    i -= 1;
                return {
                    result: n,
                    niceMin: n[0],
                    niceMax: n[n.length - 1]
                }
            }
        }, {
            key: "logarithmicScale",
            value: function(e, t, i) {
                for (var s = [], a = Math.ceil(Math.log(t) / Math.log(i)) + 1, r = 0; r < a; r++)
                    s.push(Math.pow(i, r));
                return 0 === e && s.unshift(e),
                {
                    result: s,
                    niceMin: s[0],
                    niceMax: s[s.length - 1]
                }
            }
        }, {
            key: "_adjustTicksForSmallRange",
            value: function(e, t, i) {
                var s = e;
                if (void 0 !== t && this.w.config.yaxis[t].labels.formatter && void 0 === this.w.config.yaxis[t].tickAmount) {
                    var a = this.w.config.yaxis[t].labels.formatter(1);
                    M.isNumber(Number(a)) && !M.isFloat(a) && (s = Math.ceil(i))
                }
                return s < e ? s : e
            }
        }, {
            key: "setYScaleForIndex",
            value: function(e, t, i) {
                var s = this.w.globals
                  , a = this.w.config
                  , r = s.isBarHorizontal ? a.xaxis : a.yaxis[e];
                void 0 === s.yAxisScale[e] && (s.yAxisScale[e] = []);
                var n = Math.abs(i - t);
                r.logarithmic && n <= 5 && (s.invalidLogScale = !0),
                r.logarithmic && n > 5 ? (s.allSeriesCollapsed = !1,
                s.yAxisScale[e] = this.logarithmicScale(t, i, r.logBase)) : i !== -Number.MAX_VALUE && M.isNumber(i) ? (s.allSeriesCollapsed = !1,
                s.yAxisScale[e] = void 0 === r.min && void 0 === r.max || r.forceNiceScale ? this.niceScale(t, i, r.tickAmount ? r.tickAmount : n < 5 && n > 1 ? n + 1 : 5, e, void 0 === a.yaxis[e].max && void 0 === a.yaxis[e].min || a.yaxis[e].forceNiceScale) : this.linearScale(t, i, r.tickAmount, e)) : s.yAxisScale[e] = this.linearScale(0, 5, 5)
            }
        }, {
            key: "setXScale",
            value: function(e, t) {
                var i = this.w
                  , s = i.globals
                  , a = i.config.xaxis
                  , r = Math.abs(t - e);
                return s.xAxisScale = t !== -Number.MAX_VALUE && M.isNumber(t) ? this.linearScale(e, t, a.tickAmount ? a.tickAmount : r < 5 && r > 1 ? r + 1 : 5, 0) : this.linearScale(0, 5, 5),
                s.xAxisScale
            }
        }, {
            key: "setMultipleYScales",
            value: function() {
                var e = this
                  , t = this.w.globals
                  , i = this.w.config
                  , s = t.minYArr.concat([])
                  , a = t.maxYArr.concat([])
                  , r = [];
                i.yaxis.forEach(function(n, o) {
                    var l = o;
                    i.series.forEach(function(g, p) {
                        g.name === n.seriesName && (l = p,
                        r.push(o !== p ? {
                            index: p,
                            similarIndex: o,
                            alreadyExists: !0
                        } : {
                            index: p
                        }))
                    }),
                    e.setYScaleForIndex(o, s[l], a[l])
                }),
                this.sameScaleInMultipleAxes(s, a, r)
            }
        }, {
            key: "sameScaleInMultipleAxes",
            value: function(e, t, i) {
                var s = this
                  , a = this.w.config
                  , r = this.w.globals
                  , n = [];
                i.forEach(function(x) {
                    x.alreadyExists && (void 0 === n[x.index] && (n[x.index] = []),
                    n[x.index].push(x.index),
                    n[x.index].push(x.similarIndex))
                }),
                r.yAxisSameScaleIndices = n,
                n.forEach(function(x, v) {
                    n.forEach(function(k, S) {
                        var C, h;
                        v !== S && (C = x,
                        h = k,
                        C.filter(function(u) {
                            return -1 !== h.indexOf(u)
                        })).length > 0 && (n[v] = n[v].concat(n[S]))
                    })
                });
                var o = n.map(function(x) {
                    return x.filter(function(v, k) {
                        return x.indexOf(v) === k
                    })
                }).map(function(x) {
                    return x.sort()
                });
                n = n.filter(function(x) {
                    return !!x
                });
                var l = o.slice()
                  , c = l.map(function(x) {
                    return JSON.stringify(x)
                });
                l = l.filter(function(x, v) {
                    return c.indexOf(JSON.stringify(x)) === v
                });
                var d = []
                  , g = [];
                e.forEach(function(x, v) {
                    l.forEach(function(k, S) {
                        k.indexOf(v) > -1 && (void 0 === d[S] && (d[S] = [],
                        g[S] = []),
                        d[S].push({
                            key: v,
                            value: x
                        }),
                        g[S].push({
                            key: v,
                            value: t[v]
                        }))
                    })
                });
                var p = Array.apply(null, Array(l.length)).map(Number.prototype.valueOf, Number.MIN_VALUE)
                  , m = Array.apply(null, Array(l.length)).map(Number.prototype.valueOf, -Number.MAX_VALUE);
                d.forEach(function(x, v) {
                    x.forEach(function(k, S) {
                        p[v] = Math.min(k.value, p[v])
                    })
                }),
                g.forEach(function(x, v) {
                    x.forEach(function(k, S) {
                        m[v] = Math.max(k.value, m[v])
                    })
                }),
                e.forEach(function(x, v) {
                    g.forEach(function(k, S) {
                        var C = p[S]
                          , h = m[S];
                        a.chart.stacked && (h = 0,
                        k.forEach(function(u, b) {
                            u.value !== -Number.MAX_VALUE && (h += u.value),
                            C !== Number.MIN_VALUE && (C += d[S][b].value)
                        })),
                        k.forEach(function(u, b) {
                            k[b].key === v && (void 0 !== a.yaxis[v].min && (C = "function" == typeof a.yaxis[v].min ? a.yaxis[v].min(r.minY) : a.yaxis[v].min),
                            void 0 !== a.yaxis[v].max && (h = "function" == typeof a.yaxis[v].max ? a.yaxis[v].max(r.maxY) : a.yaxis[v].max),
                            s.setYScaleForIndex(v, C, h))
                        })
                    })
                })
            }
        }, {
            key: "autoScaleY",
            value: function(e, t, i) {
                e || (e = this);
                var s = e.w;
                if (s.globals.isMultipleYAxis || s.globals.collapsedSeries.length)
                    return console.warn("autoScaleYaxis is not supported in a multi-yaxis chart."),
                    t;
                var a = s.globals.seriesX[0]
                  , r = s.config.chart.stacked;
                return t.forEach(function(n, o) {
                    for (var l = 0, c = 0; c < a.length; c++)
                        if (a[c] >= i.xaxis.min) {
                            l = c;
                            break
                        }
                    var d, g, p = s.globals.minYArr[o], m = s.globals.maxYArr[o], x = s.globals.stackedSeriesTotals;
                    s.globals.series.forEach(function(v, k) {
                        var S = v[l];
                        r ? (d = g = S = x[l],
                        x.forEach(function(C, h) {
                            a[h] <= i.xaxis.max && a[h] >= i.xaxis.min && (C > g && null !== C && (g = C),
                            v[h] < d && null !== v[h] && (d = v[h]))
                        })) : (d = g = S,
                        v.forEach(function(C, h) {
                            if (a[h] <= i.xaxis.max && a[h] >= i.xaxis.min) {
                                var u = C
                                  , b = C;
                                s.globals.series.forEach(function(w, _) {
                                    null !== C && (u = Math.min(w[h], u),
                                    b = Math.max(w[h], b))
                                }),
                                b > g && null !== b && (g = b),
                                u < d && null !== u && (d = u)
                            }
                        })),
                        void 0 === d && void 0 === g && (d = p,
                        g = m),
                        (g *= g < 0 ? .9 : 1.1) < 0 && g < m && (g = m),
                        (d *= d < 0 ? 1.1 : .9) < 0 && d > p && (d = p),
                        t.length > 1 ? (t[k].min = void 0 === n.min ? d : n.min,
                        t[k].max = void 0 === n.max ? g : n.max) : (t[0].min = void 0 === n.min ? d : n.min,
                        t[0].max = void 0 === n.max ? g : n.max)
                    })
                }),
                t
            }
        }]),
        y
    }()
      , pt = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w,
            this.scales = new Be(e)
        }
        return V(y, [{
            key: "init",
            value: function() {
                this.setYRange(),
                this.setXRange(),
                this.setZRange()
            }
        }, {
            key: "getMinYMaxY",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE
                  , i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -Number.MAX_VALUE
                  , s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null
                  , a = this.w.config
                  , r = this.w.globals
                  , n = -Number.MAX_VALUE
                  , o = Number.MIN_VALUE;
                null === s && (s = e + 1);
                var l = r.series
                  , c = l
                  , d = l;
                "candlestick" === a.chart.type ? (c = r.seriesCandleL,
                d = r.seriesCandleH) : "boxPlot" === a.chart.type ? (c = r.seriesCandleO,
                d = r.seriesCandleC) : r.isRangeData && (c = r.seriesRangeStart,
                d = r.seriesRangeEnd);
                for (var g = e; g < s; g++) {
                    r.dataPoints = Math.max(r.dataPoints, l[g].length),
                    r.categoryLabels.length && (r.dataPoints = r.categoryLabels.filter(function(x) {
                        return void 0 !== x
                    }).length);
                    for (var p = 0; p < r.series[g].length; p++) {
                        var m = l[g][p];
                        null !== m && M.isNumber(m) ? (void 0 !== d[g][p] && (n = Math.max(n, d[g][p]),
                        t = Math.min(t, d[g][p])),
                        void 0 !== c[g][p] && (t = Math.min(t, c[g][p]),
                        i = Math.max(i, c[g][p])),
                        "candlestick" !== this.w.config.chart.type && "boxPlot" !== this.w.config.chart.type || (void 0 !== r.seriesCandleC[g][p] && (n = Math.max(n, r.seriesCandleO[g][p]),
                        n = Math.max(n, r.seriesCandleH[g][p]),
                        n = Math.max(n, r.seriesCandleL[g][p]),
                        n = Math.max(n, r.seriesCandleC[g][p]),
                        "boxPlot" === this.w.config.chart.type && (n = Math.max(n, r.seriesCandleM[g][p]))),
                        !a.series[g].type || "candlestick" === a.series[g].type && "boxPlot" === a.series[g].type || (n = Math.max(n, r.series[g][p]),
                        t = Math.min(t, r.series[g][p])),
                        i = n),
                        r.seriesGoals[g] && r.seriesGoals[g][p] && Array.isArray(r.seriesGoals[g][p]) && r.seriesGoals[g][p].forEach(function(x) {
                            o !== Number.MIN_VALUE && (o = Math.min(o, x.value),
                            t = o),
                            n = Math.max(n, x.value),
                            i = n
                        }),
                        M.isFloat(m) && (m = M.noExponents(m),
                        r.yValueDecimal = Math.max(r.yValueDecimal, m.toString().split(".")[1].length)),
                        o > c[g][p] && c[g][p] < 0 && (o = c[g][p])) : r.hasNullValues = !0
                    }
                }
                return "rangeBar" === a.chart.type && r.seriesRangeStart.length && r.isBarHorizontal && (o = t),
                "bar" === a.chart.type && (o < 0 && n < 0 && (n = 0),
                o === Number.MIN_VALUE && (o = 0)),
                {
                    minY: o,
                    maxY: n,
                    lowestY: t,
                    highestY: i
                }
            }
        }, {
            key: "setYRange",
            value: function() {
                var e = this.w.globals
                  , t = this.w.config;
                e.maxY = -Number.MAX_VALUE,
                e.minY = Number.MIN_VALUE;
                var i = Number.MAX_VALUE;
                if (e.isMultipleYAxis)
                    for (var s = 0; s < e.series.length; s++) {
                        var a = this.getMinYMaxY(s, i, null, s + 1);
                        e.minYArr.push(a.minY),
                        e.maxYArr.push(a.maxY),
                        i = a.lowestY
                    }
                var r = this.getMinYMaxY(0, i, null, e.series.length);
                if (e.minY = r.minY,
                e.maxY = r.maxY,
                i = r.lowestY,
                t.chart.stacked && this._setStackedMinMax(),
                ("line" === t.chart.type || "area" === t.chart.type || "candlestick" === t.chart.type || "boxPlot" === t.chart.type || "rangeBar" === t.chart.type && !e.isBarHorizontal) && e.minY === Number.MIN_VALUE && i !== -Number.MAX_VALUE && i !== e.maxY) {
                    var n = e.maxY - i;
                    (i >= 0 && i <= 10 || void 0 !== t.yaxis[0].min || void 0 !== t.yaxis[0].max) && (n = 0),
                    e.minY = i - 5 * n / 100,
                    i > 0 && e.minY < 0 && (e.minY = 0),
                    e.maxY = e.maxY + 5 * n / 100
                }
                return t.yaxis.forEach(function(o, l) {
                    void 0 !== o.max && ("number" == typeof o.max ? e.maxYArr[l] = o.max : "function" == typeof o.max && (e.maxYArr[l] = o.max(e.isMultipleYAxis ? e.maxYArr[l] : e.maxY)),
                    e.maxY = e.maxYArr[l]),
                    void 0 !== o.min && ("number" == typeof o.min ? e.minYArr[l] = o.min : "function" == typeof o.min && (e.minYArr[l] = o.min(e.isMultipleYAxis ? e.minYArr[l] === Number.MIN_VALUE ? 0 : e.minYArr[l] : e.minY)),
                    e.minY = e.minYArr[l])
                }),
                e.isBarHorizontal && ["min", "max"].forEach(function(o) {
                    void 0 !== t.xaxis[o] && "number" == typeof t.xaxis[o] && ("min" === o ? e.minY = t.xaxis[o] : e.maxY = t.xaxis[o])
                }),
                e.isMultipleYAxis ? (this.scales.setMultipleYScales(),
                e.minY = i,
                e.yAxisScale.forEach(function(o, l) {
                    e.minYArr[l] = o.niceMin,
                    e.maxYArr[l] = o.niceMax
                })) : (this.scales.setYScaleForIndex(0, e.minY, e.maxY),
                e.minY = e.yAxisScale[0].niceMin,
                e.maxY = e.yAxisScale[0].niceMax,
                e.minYArr[0] = e.yAxisScale[0].niceMin,
                e.maxYArr[0] = e.yAxisScale[0].niceMax),
                {
                    minY: e.minY,
                    maxY: e.maxY,
                    minYArr: e.minYArr,
                    maxYArr: e.maxYArr,
                    yAxisScale: e.yAxisScale
                }
            }
        }, {
            key: "setXRange",
            value: function() {
                var e = this.w.globals
                  , t = this.w.config
                  , i = "numeric" === t.xaxis.type || "datetime" === t.xaxis.type || "category" === t.xaxis.type && !e.noLabelsProvided || e.noLabelsProvided || e.isXNumeric;
                if (e.isXNumeric && function() {
                    for (var n = 0; n < e.series.length; n++)
                        if (e.labels[n])
                            for (var o = 0; o < e.labels[n].length; o++)
                                null !== e.labels[n][o] && M.isNumber(e.labels[n][o]) && (e.maxX = Math.max(e.maxX, e.labels[n][o]),
                                e.initialMaxX = Math.max(e.maxX, e.labels[n][o]),
                                e.minX = Math.min(e.minX, e.labels[n][o]),
                                e.initialMinX = Math.min(e.minX, e.labels[n][o]))
                }(),
                e.noLabelsProvided && 0 === t.xaxis.categories.length && (e.maxX = e.labels[e.labels.length - 1],
                e.initialMaxX = e.labels[e.labels.length - 1],
                e.minX = 1,
                e.initialMinX = 1),
                e.isXNumeric || e.noLabelsProvided || e.dataFormatXNumeric) {
                    var s;
                    if (void 0 === t.xaxis.tickAmount ? (s = Math.round(e.svgWidth / 150),
                    "numeric" === t.xaxis.type && e.dataPoints < 30 && (s = e.dataPoints - 1),
                    s > e.dataPoints && 0 !== e.dataPoints && (s = e.dataPoints - 1)) : "dataPoints" === t.xaxis.tickAmount ? (e.series.length > 1 && (s = e.series[e.maxValsInArrayIndex].length - 1),
                    e.isXNumeric && (s = e.maxX - e.minX - 1)) : s = t.xaxis.tickAmount,
                    e.xTickAmount = s,
                    void 0 !== t.xaxis.max && "number" == typeof t.xaxis.max && (e.maxX = t.xaxis.max),
                    void 0 !== t.xaxis.min && "number" == typeof t.xaxis.min && (e.minX = t.xaxis.min),
                    void 0 !== t.xaxis.range && (e.minX = e.maxX - t.xaxis.range),
                    e.minX !== Number.MAX_VALUE && e.maxX !== -Number.MAX_VALUE)
                        if (t.xaxis.convertedCatToNumeric && !e.dataFormatXNumeric) {
                            for (var a = [], r = e.minX - 1; r < e.maxX; r++)
                                a.push(r + 1);
                            e.xAxisScale = {
                                result: a,
                                niceMin: a[0],
                                niceMax: a[a.length - 1]
                            }
                        } else
                            e.xAxisScale = this.scales.setXScale(e.minX, e.maxX);
                    else
                        e.xAxisScale = this.scales.linearScale(1, s, s),
                        e.noLabelsProvided && e.labels.length > 0 && (e.xAxisScale = this.scales.linearScale(1, e.labels.length, s - 1),
                        e.seriesX = e.labels.slice());
                    i && (e.labels = e.xAxisScale.result.slice())
                }
                return e.isBarHorizontal && e.labels.length && (e.xTickAmount = e.labels.length),
                this._handleSingleDataPoint(),
                this._getMinXDiff(),
                {
                    minX: e.minX,
                    maxX: e.maxX
                }
            }
        }, {
            key: "setZRange",
            value: function() {
                var e = this.w.globals;
                if (e.isDataXYZ)
                    for (var t = 0; t < e.series.length; t++)
                        if (void 0 !== e.seriesZ[t])
                            for (var i = 0; i < e.seriesZ[t].length; i++)
                                null !== e.seriesZ[t][i] && M.isNumber(e.seriesZ[t][i]) && (e.maxZ = Math.max(e.maxZ, e.seriesZ[t][i]),
                                e.minZ = Math.min(e.minZ, e.seriesZ[t][i]))
            }
        }, {
            key: "_handleSingleDataPoint",
            value: function() {
                var e = this.w.globals
                  , t = this.w.config;
                if (e.minX === e.maxX) {
                    var i = new ge(this.ctx);
                    if ("datetime" === t.xaxis.type) {
                        var s = i.getDate(e.minX);
                        t.xaxis.labels.datetimeUTC ? s.setUTCDate(s.getUTCDate() - 2) : s.setDate(s.getDate() - 2),
                        e.minX = new Date(s).getTime();
                        var a = i.getDate(e.maxX);
                        t.xaxis.labels.datetimeUTC ? a.setUTCDate(a.getUTCDate() + 2) : a.setDate(a.getDate() + 2),
                        e.maxX = new Date(a).getTime()
                    } else
                        ("numeric" === t.xaxis.type || "category" === t.xaxis.type && !e.noLabelsProvided) && (e.minX = e.minX - 2,
                        e.initialMinX = e.minX,
                        e.maxX = e.maxX + 2,
                        e.initialMaxX = e.maxX)
                }
            }
        }, {
            key: "_getMinXDiff",
            value: function() {
                var e = this.w.globals;
                e.isXNumeric && e.seriesX.forEach(function(t, i) {
                    1 === t.length && t.push(e.seriesX[e.maxValsInArrayIndex][e.seriesX[e.maxValsInArrayIndex].length - 1]);
                    var s = t.slice();
                    s.sort(function(a, r) {
                        return a - r
                    }),
                    s.forEach(function(a, r) {
                        if (r > 0) {
                            var n = a - s[r - 1];
                            n > 0 && (e.minXDiff = Math.min(n, e.minXDiff))
                        }
                    }),
                    1 !== e.dataPoints && e.minXDiff !== Number.MAX_VALUE || (e.minXDiff = .5)
                })
            }
        }, {
            key: "_setStackedMinMax",
            value: function() {
                var e = this.w.globals
                  , t = []
                  , i = [];
                if (e.series.length)
                    for (var s = 0; s < e.series[e.maxValsInArrayIndex].length; s++)
                        for (var a = 0, r = 0, n = 0; n < e.series.length; n++)
                            null !== e.series[n][s] && M.isNumber(e.series[n][s]) && (e.series[n][s] > 0 ? a = a + parseFloat(e.series[n][s]) + 1e-4 : r += parseFloat(e.series[n][s])),
                            n === e.series.length - 1 && (t.push(a),
                            i.push(r));
                for (var o = 0; o < t.length; o++)
                    e.maxY = Math.max(e.maxY, t[o]),
                    e.minY = Math.min(e.minY, i[o])
            }
        }]),
        y
    }()
      , St = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w;
            var t = this.w;
            this.xaxisFontSize = t.config.xaxis.labels.style.fontSize,
            this.axisFontFamily = t.config.xaxis.labels.style.fontFamily,
            this.xaxisForeColors = t.config.xaxis.labels.style.colors,
            this.isCategoryBarHorizontal = "bar" === t.config.chart.type && t.config.plotOptions.bar.horizontal,
            this.xAxisoffX = 0,
            "bottom" === t.config.xaxis.position && (this.xAxisoffX = t.globals.gridHeight),
            this.drawnLabels = [],
            this.axesUtils = new Re(e)
        }
        return V(y, [{
            key: "drawYaxis",
            value: function(e) {
                var t = this
                  , i = this.w
                  , s = new D(this.ctx)
                  , a = i.config.yaxis[e].labels.style
                  , r = a.fontSize
                  , n = a.fontFamily
                  , o = a.fontWeight
                  , l = s.group({
                    class: "apexcharts-yaxis",
                    rel: e,
                    transform: "translate(" + i.globals.translateYAxisX[e] + ", 0)"
                });
                if (this.axesUtils.isYAxisHidden(e))
                    return l;
                var c = s.group({
                    class: "apexcharts-yaxis-texts-g"
                });
                l.add(c);
                var d = i.globals.yAxisScale[e].result.length - 1
                  , g = i.globals.gridHeight / d
                  , p = i.globals.translateY
                  , m = i.globals.yLabelFormatters[e]
                  , x = i.globals.yAxisScale[e].result.slice();
                x = this.axesUtils.checkForReversedLabels(e, x);
                var v = "";
                if (i.config.yaxis[e].labels.show)
                    for (var k = function(X) {
                        var I = x[X];
                        I = m(I, X, i);
                        var R = i.config.yaxis[e].labels.padding;
                        i.config.yaxis[e].opposite && 0 !== i.config.yaxis.length && (R *= -1);
                        var H = t.axesUtils.getYAxisForeColor(a.colors, e)
                          , G = s.drawText({
                            x: R,
                            y: p + d / 10 + i.config.yaxis[e].labels.offsetY + 1,
                            text: I,
                            textAnchor: i.config.yaxis[e].opposite ? "start" : "end",
                            fontSize: r,
                            fontFamily: n,
                            fontWeight: o,
                            foreColor: Array.isArray(H) ? H[X] : H,
                            isPlainText: !1,
                            cssClass: "apexcharts-yaxis-label " + a.cssClass
                        });
                        X === d && (v = G),
                        c.add(G);
                        var ie = document.createElementNS(i.globals.SVGNS, "title");
                        if (ie.textContent = Array.isArray(I) ? I.join(" ") : I,
                        G.node.appendChild(ie),
                        0 !== i.config.yaxis[e].labels.rotate) {
                            var ne = s.rotateAroundCenter(v.node)
                              , oe = s.rotateAroundCenter(G.node);
                            G.node.setAttribute("transform", "rotate(".concat(i.config.yaxis[e].labels.rotate, " ").concat(ne.x, " ").concat(oe.y, ")"))
                        }
                        p += g
                    }, S = d; S >= 0; S--)
                        k(S);
                if (void 0 !== i.config.yaxis[e].title.text) {
                    var C = s.group({
                        class: "apexcharts-yaxis-title"
                    })
                      , h = 0;
                    i.config.yaxis[e].opposite && (h = i.globals.translateYAxisX[e]);
                    var u = s.drawText({
                        x: h,
                        y: i.globals.gridHeight / 2 + i.globals.translateY + i.config.yaxis[e].title.offsetY,
                        text: i.config.yaxis[e].title.text,
                        textAnchor: "end",
                        foreColor: i.config.yaxis[e].title.style.color,
                        fontSize: i.config.yaxis[e].title.style.fontSize,
                        fontWeight: i.config.yaxis[e].title.style.fontWeight,
                        fontFamily: i.config.yaxis[e].title.style.fontFamily,
                        cssClass: "apexcharts-yaxis-title-text " + i.config.yaxis[e].title.style.cssClass
                    });
                    C.add(u),
                    l.add(C)
                }
                var b = i.config.yaxis[e].axisBorder
                  , w = 31 + b.offsetX;
                if (i.config.yaxis[e].opposite && (w = -31 - b.offsetX),
                b.show) {
                    var _ = s.drawLine(w, i.globals.translateY + b.offsetY - 2, w, i.globals.gridHeight + i.globals.translateY + b.offsetY + 2, b.color, 0, b.width);
                    l.add(_)
                }
                return i.config.yaxis[e].axisTicks.show && this.axesUtils.drawYAxisTicks(w, d, b, i.config.yaxis[e].axisTicks, e, g, l),
                l
            }
        }, {
            key: "drawYaxisInversed",
            value: function(e) {
                var t = this.w
                  , i = new D(this.ctx)
                  , s = i.group({
                    class: "apexcharts-xaxis apexcharts-yaxis-inversed"
                })
                  , a = i.group({
                    class: "apexcharts-xaxis-texts-g",
                    transform: "translate(".concat(t.globals.translateXAxisX, ", ").concat(t.globals.translateXAxisY, ")")
                });
                s.add(a);
                var r = t.globals.yAxisScale[e].result.length - 1
                  , n = t.globals.gridWidth / r + .1
                  , o = n + t.config.xaxis.labels.offsetX
                  , l = t.globals.xLabelFormatter
                  , c = t.globals.yAxisScale[e].result.slice()
                  , d = t.globals.timescaleLabels;
                d.length > 0 && (this.xaxisLabels = d.slice(),
                r = (c = d.slice()).length),
                c = this.axesUtils.checkForReversedLabels(e, c);
                var g = d.length;
                if (t.config.xaxis.labels.show)
                    for (var p = g ? 0 : r; g ? p < g : p >= 0; g ? p++ : p--) {
                        var m = c[p];
                        m = l(m, p, t);
                        var x = t.globals.gridWidth + t.globals.padHorizontal - (o - n + t.config.xaxis.labels.offsetX);
                        if (d.length) {
                            var v = this.axesUtils.getLabel(c, d, x, p, this.drawnLabels, this.xaxisFontSize);
                            x = v.x,
                            m = v.text,
                            this.drawnLabels.push(v.text),
                            0 === p && t.globals.skipFirstTimelinelabel && (m = ""),
                            p === c.length - 1 && t.globals.skipLastTimelinelabel && (m = "")
                        }
                        var k = i.drawText({
                            x,
                            y: this.xAxisoffX + t.config.xaxis.labels.offsetY + 30 - ("top" === t.config.xaxis.position ? t.globals.xAxisHeight + t.config.xaxis.axisTicks.height - 2 : 0),
                            text: m,
                            textAnchor: "middle",
                            foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[e] : this.xaxisForeColors,
                            fontSize: this.xaxisFontSize,
                            fontFamily: this.xaxisFontFamily,
                            fontWeight: t.config.xaxis.labels.style.fontWeight,
                            isPlainText: !1,
                            cssClass: "apexcharts-xaxis-label " + t.config.xaxis.labels.style.cssClass
                        });
                        a.add(k),
                        k.tspan(m);
                        var S = document.createElementNS(t.globals.SVGNS, "title");
                        S.textContent = m,
                        k.node.appendChild(S),
                        o += n
                    }
                return this.inversedYAxisTitleText(s),
                this.inversedYAxisBorder(s),
                s
            }
        }, {
            key: "inversedYAxisBorder",
            value: function(e) {
                var t = this.w
                  , i = new D(this.ctx)
                  , s = t.config.xaxis.axisBorder;
                if (s.show) {
                    var a = 0;
                    "bar" === t.config.chart.type && t.globals.isXNumeric && (a -= 15);
                    var r = i.drawLine(t.globals.padHorizontal + a + s.offsetX, this.xAxisoffX, t.globals.gridWidth, this.xAxisoffX, s.color, 0, s.height);
                    e.add(r)
                }
            }
        }, {
            key: "inversedYAxisTitleText",
            value: function(e) {
                var t = this.w
                  , i = new D(this.ctx);
                if (void 0 !== t.config.xaxis.title.text) {
                    var s = i.group({
                        class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed"
                    })
                      , a = i.drawText({
                        x: t.globals.gridWidth / 2 + t.config.xaxis.title.offsetX,
                        y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(t.config.xaxis.title.style.fontSize) + t.config.xaxis.title.offsetY + 20,
                        text: t.config.xaxis.title.text,
                        textAnchor: "middle",
                        fontSize: t.config.xaxis.title.style.fontSize,
                        fontFamily: t.config.xaxis.title.style.fontFamily,
                        fontWeight: t.config.xaxis.title.style.fontWeight,
                        foreColor: t.config.xaxis.title.style.color,
                        cssClass: "apexcharts-xaxis-title-text " + t.config.xaxis.title.style.cssClass
                    });
                    s.add(a),
                    e.add(s)
                }
            }
        }, {
            key: "yAxisTitleRotate",
            value: function(e, t) {
                var i = this.w
                  , s = new D(this.ctx)
                  , a = {
                    width: 0,
                    height: 0
                }
                  , r = {
                    width: 0,
                    height: 0
                }
                  , n = i.globals.dom.baseEl.querySelector(" .apexcharts-yaxis[rel='".concat(e, "'] .apexcharts-yaxis-texts-g"));
                null !== n && (a = n.getBoundingClientRect());
                var o = i.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(e, "'] .apexcharts-yaxis-title text"));
                if (null !== o && (r = o.getBoundingClientRect()),
                null !== o) {
                    var l = this.xPaddingForYAxisTitle(e, a, r, t);
                    o.setAttribute("x", l.xPos - (t ? 10 : 0))
                }
                if (null !== o) {
                    var c = s.rotateAroundCenter(o);
                    o.setAttribute("transform", "rotate(".concat(t ? -1 * i.config.yaxis[e].title.rotate : i.config.yaxis[e].title.rotate, " ").concat(c.x, " ").concat(c.y, ")"))
                }
            }
        }, {
            key: "xPaddingForYAxisTitle",
            value: function(e, t, i, s) {
                var a = this.w
                  , r = 0
                  , n = 0
                  , o = 10;
                return void 0 === a.config.yaxis[e].title.text || e < 0 ? {
                    xPos: n,
                    padd: 0
                } : (s ? (n = t.width + a.config.yaxis[e].title.offsetX + i.width / 2 + o / 2,
                0 === (r += 1) && (n -= o / 2)) : (n = -1 * t.width + a.config.yaxis[e].title.offsetX + o / 2 + i.width / 2,
                a.globals.isBarHorizontal && (n = -1 * t.width - a.config.yaxis[e].title.offsetX - (o = 25))),
                {
                    xPos: n,
                    padd: o
                })
            }
        }, {
            key: "setYAxisXPosition",
            value: function(e, t) {
                var i = this.w
                  , s = 0
                  , a = 0
                  , r = 18
                  , n = 1;
                i.config.yaxis.length > 1 && (this.multipleYs = !0),
                i.config.yaxis.map(function(o, l) {
                    var c = i.globals.ignoreYAxisIndexes.indexOf(l) > -1 || !o.show || o.floating || 0 === e[l].width
                      , d = e[l].width + t[l].width;
                    o.opposite ? i.globals.isBarHorizontal ? i.globals.translateYAxisX[l] = (a = i.globals.gridWidth + i.globals.translateX - 1) - o.labels.offsetX : (a = i.globals.gridWidth + i.globals.translateX + n,
                    c || (n = n + d + 20),
                    i.globals.translateYAxisX[l] = a - o.labels.offsetX + 20) : (s = i.globals.translateX - r,
                    c || (r = r + d + 20),
                    i.globals.translateYAxisX[l] = s + o.labels.offsetX)
                })
            }
        }, {
            key: "setYAxisTextAlignments",
            value: function() {
                var e = this.w
                  , t = e.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis");
                (t = M.listToArray(t)).forEach(function(i, s) {
                    var a = e.config.yaxis[s];
                    if (a && void 0 !== a.labels.align) {
                        var r = e.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(s, "'] .apexcharts-yaxis-texts-g"))
                          , n = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(s, "'] .apexcharts-yaxis-label"));
                        n = M.listToArray(n);
                        var o = r.getBoundingClientRect();
                        "left" === a.labels.align ? (n.forEach(function(l, c) {
                            l.setAttribute("text-anchor", "start")
                        }),
                        a.opposite || r.setAttribute("transform", "translate(-".concat(o.width, ", 0)"))) : "center" === a.labels.align ? (n.forEach(function(l, c) {
                            l.setAttribute("text-anchor", "middle")
                        }),
                        r.setAttribute("transform", "translate(".concat(o.width / 2 * (a.opposite ? 1 : -1), ", 0)"))) : "right" === a.labels.align && (n.forEach(function(l, c) {
                            l.setAttribute("text-anchor", "end")
                        }),
                        a.opposite && r.setAttribute("transform", "translate(".concat(o.width, ", 0)")))
                    }
                })
            }
        }]),
        y
    }()
      , dt = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w,
            this.documentEvent = M.bind(this.documentEvent, this)
        }
        return V(y, [{
            key: "addEventListener",
            value: function(e, t) {
                var i = this.w;
                i.globals.events.hasOwnProperty(e) ? i.globals.events[e].push(t) : i.globals.events[e] = [t]
            }
        }, {
            key: "removeEventListener",
            value: function(e, t) {
                var i = this.w;
                if (i.globals.events.hasOwnProperty(e)) {
                    var s = i.globals.events[e].indexOf(t);
                    -1 !== s && i.globals.events[e].splice(s, 1)
                }
            }
        }, {
            key: "fireEvent",
            value: function(e, t) {
                var i = this.w;
                if (i.globals.events.hasOwnProperty(e)) {
                    t && t.length || (t = []);
                    for (var s = i.globals.events[e], a = s.length, r = 0; r < a; r++)
                        s[r].apply(null, t)
                }
            }
        }, {
            key: "setupEventHandlers",
            value: function() {
                var e = this
                  , t = this.w
                  , i = this.ctx
                  , s = t.globals.dom.baseEl.querySelector(t.globals.chartClass);
                this.ctx.eventList.forEach(function(a) {
                    s.addEventListener(a, function(r) {
                        var n = Object.assign({}, t, {
                            seriesIndex: t.globals.capturedSeriesIndex,
                            dataPointIndex: t.globals.capturedDataPointIndex
                        });
                        "mousemove" === r.type || "touchmove" === r.type ? "function" == typeof t.config.chart.events.mouseMove && t.config.chart.events.mouseMove(r, i, n) : "mouseleave" === r.type || "touchleave" === r.type ? "function" == typeof t.config.chart.events.mouseLeave && t.config.chart.events.mouseLeave(r, i, n) : ("mouseup" === r.type && 1 === r.which || "touchend" === r.type) && ("function" == typeof t.config.chart.events.click && t.config.chart.events.click(r, i, n),
                        i.ctx.events.fireEvent("click", [r, i, n]))
                    }, {
                        capture: !1,
                        passive: !0
                    })
                }),
                this.ctx.eventList.forEach(function(a) {
                    t.globals.dom.baseEl.addEventListener(a, e.documentEvent, {
                        passive: !0
                    })
                }),
                this.ctx.core.setupBrushHandler()
            }
        }, {
            key: "documentEvent",
            value: function(e) {
                var t = this.w
                  , i = e.target.className;
                if ("click" === e.type) {
                    var s = t.globals.dom.baseEl.querySelector(".apexcharts-menu");
                    s && s.classList.contains("apexcharts-menu-open") && "apexcharts-menu-icon" !== i && s.classList.remove("apexcharts-menu-open")
                }
                t.globals.clientX = "touchmove" === e.type ? e.touches[0].clientX : e.clientX,
                t.globals.clientY = "touchmove" === e.type ? e.touches[0].clientY : e.clientY
            }
        }]),
        y
    }()
      , ut = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w
        }
        return V(y, [{
            key: "setCurrentLocaleValues",
            value: function(e) {
                var t = this.w.config.chart.locales;
                window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (t = this.w.config.chart.locales.concat(window.Apex.chart.locales));
                var i = t.filter(function(a) {
                    return a.name === e
                })[0];
                if (!i)
                    throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
                var s = M.extend(Et, i);
                this.w.globals.locale = s.options
            }
        }]),
        y
    }()
      , Mt = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w
        }
        return V(y, [{
            key: "drawAxis",
            value: function(e, t) {
                var i, s, a = this.w.globals, r = this.w.config, n = new Xe(this.ctx), o = new St(this.ctx);
                a.axisCharts && "radar" !== e && (a.isBarHorizontal ? (s = o.drawYaxisInversed(0),
                i = n.drawXaxisInversed(0),
                a.dom.elGraphical.add(i),
                a.dom.elGraphical.add(s)) : (i = n.drawXaxis(),
                a.dom.elGraphical.add(i),
                r.yaxis.map(function(l, c) {
                    -1 === a.ignoreYAxisIndexes.indexOf(c) && (s = o.drawYaxis(c),
                    a.dom.Paper.add(s))
                })))
            }
        }]),
        y
    }()
      , je = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w
        }
        return V(y, [{
            key: "drawXCrosshairs",
            value: function() {
                var e = this.w
                  , t = new D(this.ctx)
                  , i = new me(this.ctx)
                  , s = e.config.xaxis.crosshairs.fill.gradient
                  , a = e.config.xaxis.crosshairs.dropShadow
                  , g = a.enabled
                  , p = a.left
                  , m = a.top
                  , x = a.blur
                  , v = a.color
                  , k = a.opacity
                  , S = e.config.xaxis.crosshairs.fill.color;
                if (e.config.xaxis.crosshairs.show) {
                    "gradient" === e.config.xaxis.crosshairs.fill.type && (S = t.drawGradient("vertical", s.colorFrom, s.colorTo, s.opacityFrom, s.opacityTo, null, s.stops, null));
                    var C = t.drawRect();
                    1 === e.config.xaxis.crosshairs.width && (C = t.drawLine());
                    var h = e.globals.gridHeight;
                    (!M.isNumber(h) || h < 0) && (h = 0);
                    var u = e.config.xaxis.crosshairs.width;
                    (!M.isNumber(u) || u < 0) && (u = 0),
                    C.attr({
                        class: "apexcharts-xcrosshairs",
                        x: 0,
                        y: 0,
                        y2: h,
                        width: u,
                        height: h,
                        fill: S,
                        filter: "none",
                        "fill-opacity": e.config.xaxis.crosshairs.opacity,
                        stroke: e.config.xaxis.crosshairs.stroke.color,
                        "stroke-width": e.config.xaxis.crosshairs.stroke.width,
                        "stroke-dasharray": e.config.xaxis.crosshairs.stroke.dashArray
                    }),
                    g && (C = i.dropShadow(C, {
                        left: p,
                        top: m,
                        blur: x,
                        color: v,
                        opacity: k
                    })),
                    e.globals.dom.elGraphical.add(C)
                }
            }
        }, {
            key: "drawYCrosshairs",
            value: function() {
                var e = this.w
                  , t = new D(this.ctx)
                  , i = e.config.yaxis[0].crosshairs
                  , s = e.globals.barPadForNumericAxis;
                if (e.config.yaxis[0].crosshairs.show) {
                    var a = t.drawLine(-s, 0, e.globals.gridWidth + s, 0, i.stroke.color, i.stroke.dashArray, i.stroke.width);
                    a.attr({
                        class: "apexcharts-ycrosshairs"
                    }),
                    e.globals.dom.elGraphical.add(a)
                }
                var r = t.drawLine(-s, 0, e.globals.gridWidth + s, 0, i.stroke.color, 0, 0);
                r.attr({
                    class: "apexcharts-ycrosshairs-hidden"
                }),
                e.globals.dom.elGraphical.add(r)
            }
        }]),
        y
    }()
      , Ue = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w
        }
        return V(y, [{
            key: "checkResponsiveConfig",
            value: function(e) {
                var t = this
                  , i = this.w
                  , s = i.config;
                if (0 !== s.responsive.length) {
                    var a = s.responsive.slice();
                    a.sort(function(l, c) {
                        return l.breakpoint > c.breakpoint ? 1 : c.breakpoint > l.breakpoint ? -1 : 0
                    }).reverse();
                    var r = new F({})
                      , n = function() {
                        var l = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                          , c = a[0].breakpoint
                          , d = window.innerWidth > 0 ? window.innerWidth : screen.width;
                        if (d > c) {
                            var g = xe.extendArrayProps(r, i.globals.initialConfig, i);
                            l = M.extend(g, l),
                            l = M.extend(i.config, l),
                            t.overrideResponsiveOptions(l)
                        } else
                            for (var p = 0; p < a.length; p++)
                                d < a[p].breakpoint && (l = xe.extendArrayProps(r, a[p].options, i),
                                l = M.extend(i.config, l),
                                t.overrideResponsiveOptions(l))
                    };
                    if (e) {
                        var o = xe.extendArrayProps(r, e, i);
                        o = M.extend(i.config, o),
                        n(o = M.extend(o, e))
                    } else
                        n({})
                }
            }
        }, {
            key: "overrideResponsiveOptions",
            value: function(e) {
                var t = new F(e).init({
                    responsiveOverride: !0
                });
                this.w.config = t
            }
        }]),
        y
    }()
      , zt = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.colors = [],
            this.w = e.w;
            var t = this.w;
            this.isColorFn = !1,
            this.isHeatmapDistributed = "treemap" === t.config.chart.type && t.config.plotOptions.treemap.distributed || "heatmap" === t.config.chart.type && t.config.plotOptions.heatmap.distributed,
            this.isBarDistributed = t.config.plotOptions.bar.distributed && ("bar" === t.config.chart.type || "rangeBar" === t.config.chart.type)
        }
        return V(y, [{
            key: "init",
            value: function() {
                this.setDefaultColors()
            }
        }, {
            key: "setDefaultColors",
            value: function() {
                var e = this
                  , t = this.w
                  , i = new M;
                if (t.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(t.config.theme.mode)),
                void 0 === t.config.colors ? t.globals.colors = this.predefined() : (t.globals.colors = t.config.colors,
                Array.isArray(t.config.colors) && t.config.colors.length > 0 && "function" == typeof t.config.colors[0] && (t.globals.colors = t.config.series.map(function(p, m) {
                    var x = t.config.colors[m];
                    return x || (x = t.config.colors[0]),
                    "function" == typeof x ? (e.isColorFn = !0,
                    x({
                        value: t.globals.axisCharts ? t.globals.series[m][0] ? t.globals.series[m][0] : 0 : t.globals.series[m],
                        seriesIndex: m,
                        dataPointIndex: m,
                        w: t
                    })) : x
                }))),
                t.globals.seriesColors.map(function(p, m) {
                    p && (t.globals.colors[m] = p)
                }),
                t.config.theme.monochrome.enabled) {
                    var s = []
                      , a = t.globals.series.length;
                    (this.isBarDistributed || this.isHeatmapDistributed) && (a = t.globals.series[0].length * t.globals.series.length);
                    for (var r = t.config.theme.monochrome.color, n = 1 / (a / t.config.theme.monochrome.shadeIntensity), o = t.config.theme.monochrome.shadeTo, l = 0, c = 0; c < a; c++) {
                        var d = void 0;
                        "dark" === o ? (d = i.shadeColor(-1 * l, r),
                        l += n) : (d = i.shadeColor(l, r),
                        l += n),
                        s.push(d)
                    }
                    t.globals.colors = s.slice()
                }
                var g = t.globals.colors.slice();
                this.pushExtraColors(t.globals.colors),
                ["fill", "stroke"].forEach(function(p) {
                    t.globals[p].colors = void 0 === t.config[p].colors ? e.isColorFn ? t.config.colors : g : t.config[p].colors.slice(),
                    e.pushExtraColors(t.globals[p].colors)
                }),
                t.globals.dataLabels.style.colors = void 0 === t.config.dataLabels.style.colors ? g : t.config.dataLabels.style.colors.slice(),
                this.pushExtraColors(t.globals.dataLabels.style.colors, 50),
                t.globals.radarPolygons.fill.colors = void 0 === t.config.plotOptions.radar.polygons.fill.colors ? ["dark" === t.config.theme.mode ? "#424242" : "none"] : t.config.plotOptions.radar.polygons.fill.colors.slice(),
                this.pushExtraColors(t.globals.radarPolygons.fill.colors, 20),
                t.globals.markers.colors = void 0 === t.config.markers.colors ? g : t.config.markers.colors.slice(),
                this.pushExtraColors(t.globals.markers.colors)
            }
        }, {
            key: "pushExtraColors",
            value: function(e, t) {
                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
                  , s = this.w
                  , a = t || s.globals.series.length;
                if (null === i && (i = this.isBarDistributed || this.isHeatmapDistributed || "heatmap" === s.config.chart.type && s.config.plotOptions.heatmap.colorScale.inverse),
                i && s.globals.series.length && (a = s.globals.series[s.globals.maxValsInArrayIndex].length * s.globals.series.length),
                e.length < a)
                    for (var r = a - e.length, n = 0; n < r; n++)
                        e.push(e[n])
            }
        }, {
            key: "updateThemeOptions",
            value: function(e) {
                e.chart = e.chart || {},
                e.tooltip = e.tooltip || {};
                var t = e.theme.mode || "light"
                  , i = e.theme.palette ? e.theme.palette : "dark" === t ? "palette4" : "palette1"
                  , s = e.chart.foreColor ? e.chart.foreColor : "dark" === t ? "#f6f7f8" : "#373d3f";
                return e.tooltip.theme = t,
                e.chart.foreColor = s,
                e.theme.palette = i,
                e
            }
        }, {
            key: "predefined",
            value: function() {
                switch (this.w.config.theme.palette) {
                case "palette1":
                default:
                    this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"];
                    break;
                case "palette2":
                    this.colors = ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"];
                    break;
                case "palette3":
                    this.colors = ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"];
                    break;
                case "palette4":
                    this.colors = ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"];
                    break;
                case "palette5":
                    this.colors = ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"];
                    break;
                case "palette6":
                    this.colors = ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"];
                    break;
                case "palette7":
                    this.colors = ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"];
                    break;
                case "palette8":
                    this.colors = ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"];
                    break;
                case "palette9":
                    this.colors = ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"];
                    break;
                case "palette10":
                    this.colors = ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"]
                }
                return this.colors
            }
        }]),
        y
    }()
      , Xt = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w
        }
        return V(y, [{
            key: "draw",
            value: function() {
                this.drawTitleSubtitle("title"),
                this.drawTitleSubtitle("subtitle")
            }
        }, {
            key: "drawTitleSubtitle",
            value: function(e) {
                var t = this.w
                  , i = "title" === e ? t.config.title : t.config.subtitle
                  , s = t.globals.svgWidth / 2
                  , a = i.offsetY
                  , r = "middle";
                if ("left" === i.align ? (s = 10,
                r = "start") : "right" === i.align && (s = t.globals.svgWidth - 10,
                r = "end"),
                s += i.offsetX,
                a = a + parseInt(i.style.fontSize, 10) + i.margin / 2,
                void 0 !== i.text) {
                    var n = new D(this.ctx).drawText({
                        x: s,
                        y: a,
                        text: i.text,
                        textAnchor: r,
                        fontSize: i.style.fontSize,
                        fontFamily: i.style.fontFamily,
                        fontWeight: i.style.fontWeight,
                        foreColor: i.style.color,
                        opacity: 1
                    });
                    n.node.setAttribute("class", "apexcharts-".concat(e, "-text")),
                    t.globals.dom.Paper.add(n)
                }
            }
        }]),
        y
    }()
      , ti = function() {
        function y(e) {
            W(this, y),
            this.w = e.w,
            this.dCtx = e
        }
        return V(y, [{
            key: "getTitleSubtitleCoords",
            value: function(e) {
                var t = this.w
                  , i = 0
                  , s = 0
                  , a = "title" === e ? t.config.title.floating : t.config.subtitle.floating
                  , r = t.globals.dom.baseEl.querySelector(".apexcharts-".concat(e, "-text"));
                if (null !== r && !a) {
                    var n = r.getBoundingClientRect();
                    i = n.width,
                    s = t.globals.axisCharts ? n.height + 5 : n.height
                }
                return {
                    width: i,
                    height: s
                }
            }
        }, {
            key: "getLegendsRect",
            value: function() {
                var e = this.w
                  , t = e.globals.dom.baseEl.querySelector(".apexcharts-legend");
                e.config.legend.height || "top" !== e.config.legend.position && "bottom" !== e.config.legend.position || (t.style.maxHeight = e.globals.svgHeight / 2 + "px");
                var i = Object.assign({}, M.getBoundingClientRect(t));
                return this.dCtx.lgRect = null !== t && !e.config.legend.floating && e.config.legend.show ? {
                    x: i.x,
                    y: i.y,
                    height: i.height,
                    width: 0 === i.height ? 0 : i.width
                } : {
                    x: 0,
                    y: 0,
                    height: 0,
                    width: 0
                },
                "left" !== e.config.legend.position && "right" !== e.config.legend.position || 1.5 * this.dCtx.lgRect.width > e.globals.svgWidth && (this.dCtx.lgRect.width = e.globals.svgWidth / 1.5),
                this.dCtx.lgRect
            }
        }, {
            key: "getLargestStringFromMultiArr",
            value: function(e, t) {
                var i = e;
                if (this.w.globals.isMultiLineX) {
                    var s = t.map(function(r, n) {
                        return Array.isArray(r) ? r.length : 1
                    })
                      , a = Math.max.apply(Math, pe(s));
                    i = t[s.indexOf(a)]
                }
                return i
            }
        }]),
        y
    }()
      , qt = function() {
        function y(e) {
            W(this, y),
            this.w = e.w,
            this.dCtx = e
        }
        return V(y, [{
            key: "getxAxisLabelsCoords",
            value: function() {
                var e, t = this.w, i = t.globals.labels.slice();
                if (t.config.xaxis.convertedCatToNumeric && 0 === i.length && (i = t.globals.categoryLabels),
                t.globals.timescaleLabels.length > 0) {
                    var s = this.getxAxisTimeScaleLabelsCoords();
                    e = {
                        width: s.width,
                        height: s.height
                    },
                    t.globals.rotateXLabels = !1
                } else {
                    this.dCtx.lgWidthForSideLegends = "left" !== t.config.legend.position && "right" !== t.config.legend.position || t.config.legend.floating ? 0 : this.dCtx.lgRect.width;
                    var a = t.globals.xLabelFormatter
                      , r = M.getLargestStringFromArr(i)
                      , n = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r, i);
                    t.globals.isBarHorizontal && (n = r = t.globals.yAxisScale[0].result.reduce(function(m, x) {
                        return m.length > x.length ? m : x
                    }, 0));
                    var o = new ze(this.dCtx.ctx)
                      , l = r;
                    r = o.xLabelFormat(a, r, l, {
                        i: void 0,
                        dateFormatter: new ge(this.dCtx.ctx).formatDate,
                        w: t
                    }),
                    n = o.xLabelFormat(a, n, l, {
                        i: void 0,
                        dateFormatter: new ge(this.dCtx.ctx).formatDate,
                        w: t
                    }),
                    (t.config.xaxis.convertedCatToNumeric && void 0 === r || "" === String(r).trim()) && (n = r = "1");
                    var c = new D(this.dCtx.ctx)
                      , d = c.getTextRects(r, t.config.xaxis.labels.style.fontSize)
                      , g = d;
                    if (r !== n && (g = c.getTextRects(n, t.config.xaxis.labels.style.fontSize)),
                    (e = {
                        width: d.width >= g.width ? d.width : g.width,
                        height: d.height >= g.height ? d.height : g.height
                    }).width * i.length > t.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && 0 !== t.config.xaxis.labels.rotate || t.config.xaxis.labels.rotateAlways) {
                        if (!t.globals.isBarHorizontal) {
                            t.globals.rotateXLabels = !0;
                            var p = function(m) {
                                return c.getTextRects(m, t.config.xaxis.labels.style.fontSize, t.config.xaxis.labels.style.fontFamily, "rotate(".concat(t.config.xaxis.labels.rotate, " 0 0)"), !1)
                            };
                            d = p(r),
                            r !== n && (g = p(n)),
                            e.height = (d.height > g.height ? d.height : g.height) / 1.5,
                            e.width = d.width > g.width ? d.width : g.width
                        }
                    } else
                        t.globals.rotateXLabels = !1
                }
                return t.config.xaxis.labels.show || (e = {
                    width: 0,
                    height: 0
                }),
                {
                    width: e.width,
                    height: e.height
                }
            }
        }, {
            key: "getxAxisTitleCoords",
            value: function() {
                var e = this.w
                  , t = 0
                  , i = 0;
                if (void 0 !== e.config.xaxis.title.text) {
                    var s = new D(this.dCtx.ctx).getTextRects(e.config.xaxis.title.text, e.config.xaxis.title.style.fontSize);
                    t = s.width,
                    i = s.height
                }
                return {
                    width: t,
                    height: i
                }
            }
        }, {
            key: "getxAxisTimeScaleLabelsCoords",
            value: function() {
                var e, t = this.w;
                this.dCtx.timescaleLabels = t.globals.timescaleLabels.slice();
                var i = this.dCtx.timescaleLabels.map(function(a) {
                    return a.value
                })
                  , s = i.reduce(function(a, r) {
                    return void 0 === a ? (console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"),
                    0) : a.length > r.length ? a : r
                }, 0);
                return 1.05 * (e = new D(this.dCtx.ctx).getTextRects(s, t.config.xaxis.labels.style.fontSize)).width * i.length > t.globals.gridWidth && 0 !== t.config.xaxis.labels.rotate && (t.globals.overlappingXLabels = !0),
                e
            }
        }, {
            key: "additionalPaddingXLabels",
            value: function(e) {
                var t = this
                  , i = this.w
                  , s = i.globals
                  , a = i.config
                  , r = a.xaxis.type
                  , n = e.width;
                s.skipLastTimelinelabel = !1,
                s.skipFirstTimelinelabel = !1;
                var o = i.config.yaxis[0].opposite && i.globals.isBarHorizontal;
                a.yaxis.forEach(function(c, d) {
                    o ? (t.dCtx.gridPad.left < n && (t.dCtx.xPadLeft = n / 2 + 1),
                    t.dCtx.xPadRight = n / 2 + 1) : function(c, d) {
                        -1 !== s.collapsedSeriesIndices.indexOf(d) || function(g) {
                            if (t.dCtx.timescaleLabels && t.dCtx.timescaleLabels.length) {
                                var x = t.dCtx.timescaleLabels[0].position - n / 1.75 + t.dCtx.yAxisWidthLeft;
                                t.dCtx.timescaleLabels[t.dCtx.timescaleLabels.length - 1].position + n / 1.75 - t.dCtx.yAxisWidthRight > s.svgWidth - s.translateX - ("right" === i.config.legend.position && t.dCtx.lgRect.width > 0 ? t.dCtx.lgRect.width : 0) && (s.skipLastTimelinelabel = !0),
                                x < -(g.show && !g.floating || "bar" !== a.chart.type && "candlestick" !== a.chart.type && "rangeBar" !== a.chart.type && "boxPlot" !== a.chart.type ? 10 : n / 1.75) && (s.skipFirstTimelinelabel = !0)
                            } else
                                "datetime" === r ? t.dCtx.gridPad.right < n && !s.rotateXLabels && (s.skipLastTimelinelabel = !0) : "datetime" !== r && t.dCtx.gridPad.right < n / 2 - t.dCtx.yAxisWidthRight && !s.rotateXLabels && !i.config.xaxis.labels.trim && ("between" !== i.config.xaxis.tickPlacement || i.globals.isBarHorizontal) && (t.dCtx.xPadRight = n / 2 + 1)
                        }(c)
                    }(c, d)
                })
            }
        }]),
        y
    }()
      , Ot = function() {
        function y(e) {
            W(this, y),
            this.w = e.w,
            this.dCtx = e
        }
        return V(y, [{
            key: "getyAxisLabelsCoords",
            value: function() {
                var e = this
                  , t = this.w
                  , i = []
                  , s = 10
                  , a = new Re(this.dCtx.ctx);
                return t.config.yaxis.map(function(r, n) {
                    var o = t.globals.yAxisScale[n]
                      , l = 0;
                    if (!a.isYAxisHidden(n) && r.labels.show && void 0 !== r.labels.minWidth && (l = r.labels.minWidth),
                    !a.isYAxisHidden(n) && r.labels.show && o.result.length) {
                        var c = t.globals.yLabelFormatters[n]
                          , d = o.niceMin === Number.MIN_VALUE ? 0 : o.niceMin
                          , g = String(d).length > String(o.niceMax).length ? d : o.niceMax
                          , p = c(g, {
                            seriesIndex: n,
                            dataPointIndex: -1,
                            w: t
                        })
                          , m = p;
                        if (void 0 !== p && 0 !== p.length || (p = g),
                        t.globals.isBarHorizontal) {
                            s = 0;
                            var x = t.globals.labels.slice();
                            p = c(p = M.getLargestStringFromArr(x), {
                                seriesIndex: n,
                                dataPointIndex: -1,
                                w: t
                            }),
                            m = e.dCtx.dimHelpers.getLargestStringFromMultiArr(p, x)
                        }
                        var v = new D(e.dCtx.ctx)
                          , k = "rotate(".concat(r.labels.rotate, " 0 0)")
                          , S = v.getTextRects(p, r.labels.style.fontSize, r.labels.style.fontFamily, k, !1)
                          , C = S;
                        p !== m && (C = v.getTextRects(m, r.labels.style.fontSize, r.labels.style.fontFamily, k, !1)),
                        i.push({
                            width: (l > C.width || l > S.width ? l : C.width > S.width ? C.width : S.width) + s,
                            height: C.height > S.height ? C.height : S.height
                        })
                    } else
                        i.push({
                            width: 0,
                            height: 0
                        })
                }),
                i
            }
        }, {
            key: "getyAxisTitleCoords",
            value: function() {
                var e = this
                  , i = [];
                return this.w.config.yaxis.map(function(s, a) {
                    if (s.show && void 0 !== s.title.text) {
                        var r = new D(e.dCtx.ctx)
                          , n = "rotate(".concat(s.title.rotate, " 0 0)")
                          , o = r.getTextRects(s.title.text, s.title.style.fontSize, s.title.style.fontFamily, n, !1);
                        i.push({
                            width: o.width,
                            height: o.height
                        })
                    } else
                        i.push({
                            width: 0,
                            height: 0
                        })
                }),
                i
            }
        }, {
            key: "getTotalYAxisWidth",
            value: function() {
                var e = this.w
                  , t = 0
                  , i = 0
                  , s = 0
                  , a = e.globals.yAxisScale.length > 1 ? 10 : 0
                  , r = new Re(this.dCtx.ctx)
                  , n = function(o, l) {
                    var c = e.config.yaxis[l].floating
                      , d = 0;
                    o.width > 0 && !c ? (d = o.width + a,
                    e.globals.ignoreYAxisIndexes.indexOf(l) > -1 && (d = d - o.width - a)) : d = c || r.isYAxisHidden(l) ? 0 : 5,
                    e.config.yaxis[l].opposite ? s += d : i += d,
                    t += d
                };
                return e.globals.yLabelsCoords.map(function(o, l) {
                    n(o, l)
                }),
                e.globals.yTitleCoords.map(function(o, l) {
                    n(o, l)
                }),
                e.globals.isBarHorizontal && !e.config.yaxis[0].floating && (t = e.globals.yLabelsCoords[0].width + e.globals.yTitleCoords[0].width + 15),
                this.dCtx.yAxisWidthLeft = i,
                this.dCtx.yAxisWidthRight = s,
                t
            }
        }]),
        y
    }()
      , Dt = function() {
        function y(e) {
            W(this, y),
            this.w = e.w,
            this.dCtx = e
        }
        return V(y, [{
            key: "gridPadForColumnsInNumericAxis",
            value: function(e) {
                var t = this.w;
                if (t.globals.noData || t.globals.allSeriesCollapsed)
                    return 0;
                var i = function(c) {
                    return "bar" === c || "rangeBar" === c || "candlestick" === c || "boxPlot" === c
                }
                  , s = t.config.chart.type
                  , a = 0
                  , r = i(s) ? t.config.series.length : 1;
                if (t.globals.comboBarCount > 0 && (r = t.globals.comboBarCount),
                t.globals.collapsedSeries.forEach(function(c) {
                    i(c.type) && (r -= 1)
                }),
                t.config.chart.stacked && (r = 1),
                (i(s) || t.globals.comboBarCount > 0) && t.globals.isXNumeric && !t.globals.isBarHorizontal && r > 0) {
                    var n, o, l = Math.abs(t.globals.initialMaxX - t.globals.initialMinX);
                    l <= 3 && (l = t.globals.dataPoints),
                    n = l / e,
                    t.globals.minXDiff && t.globals.minXDiff / n > 0 && (o = t.globals.minXDiff / n),
                    o > e / 2 && (o /= 2),
                    (a = o / r * parseInt(t.config.plotOptions.bar.columnWidth, 10) / 100) < 1 && (a = 1),
                    t.globals.barPadForNumericAxis = a = a / (r > 1 ? 1 : 1.5) + 5
                }
                return a
            }
        }, {
            key: "gridPadFortitleSubtitle",
            value: function() {
                var e = this
                  , t = this.w
                  , i = t.globals
                  , s = this.dCtx.isSparkline || !t.globals.axisCharts ? 0 : 10;
                ["title", "subtitle"].forEach(function(n) {
                    s += void 0 !== t.config[n].text ? t.config[n].margin : e.dCtx.isSparkline || !t.globals.axisCharts ? 0 : 5
                }),
                !t.config.legend.show || "bottom" !== t.config.legend.position || t.config.legend.floating || t.globals.axisCharts || (s += 10);
                var a = this.dCtx.dimHelpers.getTitleSubtitleCoords("title")
                  , r = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
                i.gridHeight = i.gridHeight - a.height - r.height - s,
                i.translateY = i.translateY + a.height + r.height + s
            }
        }, {
            key: "setGridXPosForDualYAxis",
            value: function(e, t) {
                var i = this.w
                  , s = new Re(this.dCtx.ctx);
                i.config.yaxis.map(function(a, r) {
                    -1 !== i.globals.ignoreYAxisIndexes.indexOf(r) || a.floating || s.isYAxisHidden(r) || (a.opposite && (i.globals.translateX = i.globals.translateX - (t[r].width + e[r].width) - parseInt(i.config.yaxis[r].labels.style.fontSize, 10) / 1.2 - 12),
                    i.globals.translateX < 2 && (i.globals.translateX = 2))
                })
            }
        }]),
        y
    }()
      , xt = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w,
            this.lgRect = {},
            this.yAxisWidth = 0,
            this.yAxisWidthLeft = 0,
            this.yAxisWidthRight = 0,
            this.xAxisHeight = 0,
            this.isSparkline = this.w.config.chart.sparkline.enabled,
            this.dimHelpers = new ti(this),
            this.dimYAxis = new Ot(this),
            this.dimXAxis = new qt(this),
            this.dimGrid = new Dt(this),
            this.lgWidthForSideLegends = 0,
            this.gridPad = this.w.config.grid.padding,
            this.xPadRight = 0,
            this.xPadLeft = 0
        }
        return V(y, [{
            key: "plotCoords",
            value: function() {
                var e = this.w.globals;
                this.lgRect = this.dimHelpers.getLegendsRect(),
                e.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(),
                this.dimGrid.gridPadFortitleSubtitle(),
                e.gridHeight = e.gridHeight - this.gridPad.top - this.gridPad.bottom,
                e.gridWidth = e.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
                var t = this.dimGrid.gridPadForColumnsInNumericAxis(e.gridWidth);
                e.gridWidth = e.gridWidth - 2 * t,
                e.translateX = e.translateX + this.gridPad.left + this.xPadLeft + (t > 0 ? t + 4 : 0),
                e.translateY = e.translateY + this.gridPad.top
            }
        }, {
            key: "setDimensionsForAxisCharts",
            value: function() {
                var e = this
                  , t = this.w
                  , i = t.globals
                  , s = this.dimYAxis.getyAxisLabelsCoords()
                  , a = this.dimYAxis.getyAxisTitleCoords();
                t.globals.yLabelsCoords = [],
                t.globals.yTitleCoords = [],
                t.config.yaxis.map(function(g, p) {
                    t.globals.yLabelsCoords.push({
                        width: s[p].width,
                        index: p
                    }),
                    t.globals.yTitleCoords.push({
                        width: a[p].width,
                        index: p
                    })
                }),
                this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
                var r = this.dimXAxis.getxAxisLabelsCoords()
                  , n = this.dimXAxis.getxAxisTitleCoords();
                this.conditionalChecksForAxisCoords(r, n),
                i.translateXAxisY = t.globals.rotateXLabels ? this.xAxisHeight / 8 : -4,
                i.translateXAxisX = t.globals.rotateXLabels && t.globals.isXNumeric && t.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0,
                t.globals.isBarHorizontal && (i.rotateXLabels = !1,
                i.translateXAxisY = parseInt(t.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1),
                i.translateXAxisY = i.translateXAxisY + t.config.xaxis.labels.offsetY,
                i.translateXAxisX = i.translateXAxisX + t.config.xaxis.labels.offsetX;
                var o = this.yAxisWidth
                  , l = this.xAxisHeight;
                i.xAxisLabelsHeight = this.xAxisHeight - n.height,
                i.xAxisLabelsWidth = this.xAxisWidth,
                i.xAxisHeight = this.xAxisHeight;
                var c = 10;
                ("radar" === t.config.chart.type || this.isSparkline) && (o = 0,
                l = i.goldenPadding),
                this.isSparkline && (this.lgRect = {
                    height: 0,
                    width: 0
                }),
                (this.isSparkline || "treemap" === t.config.chart.type) && (o = 0,
                l = 0,
                c = 0),
                this.isSparkline || this.dimXAxis.additionalPaddingXLabels(r);
                var d = function() {
                    i.translateX = o,
                    i.gridHeight = i.svgHeight - e.lgRect.height - l - (e.isSparkline || "treemap" === t.config.chart.type ? 0 : t.globals.rotateXLabels ? 10 : 15),
                    i.gridWidth = i.svgWidth - o
                };
                switch ("top" === t.config.xaxis.position && (c = i.xAxisHeight - t.config.xaxis.axisTicks.height - 5),
                t.config.legend.position) {
                case "bottom":
                    i.translateY = c,
                    d();
                    break;
                case "top":
                    i.translateY = this.lgRect.height + c,
                    d();
                    break;
                case "left":
                    i.translateY = c,
                    i.translateX = this.lgRect.width + o,
                    i.gridHeight = i.svgHeight - l - 12,
                    i.gridWidth = i.svgWidth - this.lgRect.width - o;
                    break;
                case "right":
                    i.translateY = c,
                    i.translateX = o,
                    i.gridHeight = i.svgHeight - l - 12,
                    i.gridWidth = i.svgWidth - this.lgRect.width - o - 5;
                    break;
                default:
                    throw new Error("Legend position not supported")
                }
                this.dimGrid.setGridXPosForDualYAxis(a, s),
                new St(this.ctx).setYAxisXPosition(s, a)
            }
        }, {
            key: "setDimensionsForNonAxisCharts",
            value: function() {
                var e = this.w
                  , t = e.globals
                  , i = e.config
                  , s = 0;
                e.config.legend.show && !e.config.legend.floating && (s = 20);
                var a = "pie" === i.chart.type || "polarArea" === i.chart.type || "donut" === i.chart.type ? "pie" : "radialBar"
                  , r = i.plotOptions[a].offsetY
                  , n = i.plotOptions[a].offsetX;
                if (!i.legend.show || i.legend.floating)
                    return t.gridHeight = t.svgHeight - i.grid.padding.left + i.grid.padding.right,
                    t.gridWidth = t.gridHeight,
                    t.translateY = r,
                    void (t.translateX = n + (t.svgWidth - t.gridWidth) / 2);
                switch (i.legend.position) {
                case "bottom":
                    t.gridHeight = t.svgHeight - this.lgRect.height - t.goldenPadding,
                    t.gridWidth = t.svgWidth,
                    t.translateY = r - 10,
                    t.translateX = n + (t.svgWidth - t.gridWidth) / 2;
                    break;
                case "top":
                    t.gridHeight = t.svgHeight - this.lgRect.height - t.goldenPadding,
                    t.gridWidth = t.svgWidth,
                    t.translateY = this.lgRect.height + r + 10,
                    t.translateX = n + (t.svgWidth - t.gridWidth) / 2;
                    break;
                case "left":
                    t.gridWidth = t.svgWidth - this.lgRect.width - s,
                    t.gridHeight = "auto" !== i.chart.height ? t.svgHeight : t.gridWidth,
                    t.translateY = r,
                    t.translateX = n + this.lgRect.width + s;
                    break;
                case "right":
                    t.gridWidth = t.svgWidth - this.lgRect.width - s - 5,
                    t.gridHeight = "auto" !== i.chart.height ? t.svgHeight : t.gridWidth,
                    t.translateY = r,
                    t.translateX = n + 10;
                    break;
                default:
                    throw new Error("Legend position not supported")
                }
            }
        }, {
            key: "conditionalChecksForAxisCoords",
            value: function(e, t) {
                var i = this.w;
                this.xAxisHeight = (e.height + t.height) * (i.globals.isMultiLineX ? 1.2 : i.globals.LINE_HEIGHT_RATIO) + (i.globals.rotateXLabels ? 22 : 10) + (i.globals.rotateXLabels && "bottom" === i.config.legend.position ? 10 : 0),
                this.xAxisWidth = e.width,
                this.xAxisHeight - t.height > i.config.xaxis.labels.maxHeight && (this.xAxisHeight = i.config.xaxis.labels.maxHeight),
                i.config.xaxis.labels.minHeight && this.xAxisHeight < i.config.xaxis.labels.minHeight && (this.xAxisHeight = i.config.xaxis.labels.minHeight),
                i.config.xaxis.floating && (this.xAxisHeight = 0);
                var o = 0
                  , l = 0;
                i.config.yaxis.forEach(function(c) {
                    o += c.labels.minWidth,
                    l += c.labels.maxWidth
                }),
                this.yAxisWidth < o && (this.yAxisWidth = o),
                this.yAxisWidth > l && (this.yAxisWidth = l)
            }
        }]),
        y
    }()
      , Ct = function() {
        function y(e) {
            W(this, y),
            this.w = e.w,
            this.lgCtx = e
        }
        return V(y, [{
            key: "getLegendStyles",
            value: function() {
                var e = document.createElement("style");
                e.setAttribute("type", "text/css");
                var t = document.createTextNode("\t\n    \t\n      .apexcharts-legend {\t\n        display: flex;\t\n        overflow: auto;\t\n        padding: 0 10px;\t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {\t\n        flex-wrap: wrap\t\n      }\t\n      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\t\n        flex-direction: column;\t\n        bottom: 0;\t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\t\n        justify-content: flex-start;\t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {\t\n        justify-content: center;  \t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {\t\n        justify-content: flex-end;\t\n      }\t\n      .apexcharts-legend-series {\t\n        cursor: pointer;\t\n        line-height: normal;\t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom .apexcharts-legend-series, .apexcharts-legend.apx-legend-position-top .apexcharts-legend-series{\t\n        display: flex;\t\n        align-items: center;\t\n      }\t\n      .apexcharts-legend-text {\t\n        position: relative;\t\n        font-size: 14px;\t\n      }\t\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\t\n        pointer-events: none;\t\n      }\t\n      .apexcharts-legend-marker {\t\n        position: relative;\t\n        display: inline-block;\t\n        cursor: pointer;\t\n        margin-right: 3px;\t\n        border-style: solid;\n      }\t\n      \t\n      .apexcharts-legend.apexcharts-align-right .apexcharts-legend-series, .apexcharts-legend.apexcharts-align-left .apexcharts-legend-series{\t\n        display: inline-block;\t\n      }\t\n      .apexcharts-legend-series.apexcharts-no-click {\t\n        cursor: auto;\t\n      }\t\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\t\n        display: none !important;\t\n      }\t\n      .apexcharts-inactive-legend {\t\n        opacity: 0.45;\t\n      }");
                return e.appendChild(t),
                e
            }
        }, {
            key: "getLegendBBox",
            value: function() {
                var e = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect();
                return {
                    clwh: e.height,
                    clww: e.width
                }
            }
        }, {
            key: "appendToForeignObject",
            value: function() {
                var e = this.w.globals;
                e.dom.elLegendForeign = document.createElementNS(e.SVGNS, "foreignObject");
                var t = e.dom.elLegendForeign;
                t.setAttribute("x", 0),
                t.setAttribute("y", 0),
                t.setAttribute("width", e.svgWidth),
                t.setAttribute("height", e.svgHeight),
                e.dom.elLegendWrap.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"),
                t.appendChild(e.dom.elLegendWrap),
                t.appendChild(this.getLegendStyles()),
                e.dom.Paper.node.insertBefore(t, e.dom.elGraphical.node)
            }
        }, {
            key: "toggleDataSeries",
            value: function(e, t) {
                var i = this
                  , s = this.w;
                if (s.globals.axisCharts || "radialBar" === s.config.chart.type) {
                    s.globals.resized = !0;
                    var a = null
                      , r = null;
                    s.globals.risingSeries = [],
                    s.globals.axisCharts ? (a = s.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e, "']")),
                    r = parseInt(a.getAttribute("data:realIndex"), 10)) : (a = s.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(e + 1, "']")),
                    r = parseInt(a.getAttribute("rel"), 10) - 1),
                    t ? [{
                        cs: s.globals.collapsedSeries,
                        csi: s.globals.collapsedSeriesIndices
                    }, {
                        cs: s.globals.ancillaryCollapsedSeries,
                        csi: s.globals.ancillaryCollapsedSeriesIndices
                    }].forEach(function(c) {
                        i.riseCollapsedSeries(c.cs, c.csi, r)
                    }) : this.hideSeries({
                        seriesEl: a,
                        realIndex: r
                    })
                } else {
                    var n = s.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(e + 1, "'] path"))
                      , o = s.config.chart.type;
                    if ("pie" === o || "polarArea" === o || "donut" === o) {
                        var l = s.config.plotOptions.pie.donut.labels;
                        new D(this.lgCtx.ctx).pathMouseDown(n.members[0], null),
                        this.lgCtx.ctx.pie.printDataLabelsInner(n.members[0].node, l)
                    }
                    n.fire("click")
                }
            }
        }, {
            key: "hideSeries",
            value: function(e) {
                var t = e.seriesEl
                  , i = e.realIndex
                  , s = this.w
                  , a = M.clone(s.config.series);
                if (s.globals.axisCharts) {
                    var r = !1;
                    if (s.config.yaxis[i] && s.config.yaxis[i].show && s.config.yaxis[i].showAlways && (r = !0,
                    s.globals.ancillaryCollapsedSeriesIndices.indexOf(i) < 0 && (s.globals.ancillaryCollapsedSeries.push({
                        index: i,
                        data: a[i].data.slice(),
                        type: t.parentNode.className.baseVal.split("-")[1]
                    }),
                    s.globals.ancillaryCollapsedSeriesIndices.push(i))),
                    !r) {
                        s.globals.collapsedSeries.push({
                            index: i,
                            data: a[i].data.slice(),
                            type: t.parentNode.className.baseVal.split("-")[1]
                        }),
                        s.globals.collapsedSeriesIndices.push(i);
                        var n = s.globals.risingSeries.indexOf(i);
                        s.globals.risingSeries.splice(n, 1)
                    }
                } else
                    s.globals.collapsedSeries.push({
                        index: i,
                        data: a[i]
                    }),
                    s.globals.collapsedSeriesIndices.push(i);
                for (var o = t.childNodes, l = 0; l < o.length; l++)
                    o[l].classList.contains("apexcharts-series-markers-wrap") && (o[l].classList.contains("apexcharts-hide") ? o[l].classList.remove("apexcharts-hide") : o[l].classList.add("apexcharts-hide"));
                s.globals.allSeriesCollapsed = s.globals.collapsedSeries.length === s.config.series.length,
                a = this._getSeriesBasedOnCollapsedState(a),
                this.lgCtx.ctx.updateHelpers._updateSeries(a, s.config.chart.animations.dynamicAnimation.enabled)
            }
        }, {
            key: "riseCollapsedSeries",
            value: function(e, t, i) {
                var s = this.w
                  , a = M.clone(s.config.series);
                if (e.length > 0) {
                    for (var r = 0; r < e.length; r++)
                        e[r].index === i && (s.globals.axisCharts ? (a[i].data = e[r].data.slice(),
                        e.splice(r, 1),
                        t.splice(r, 1),
                        s.globals.risingSeries.push(i)) : (a[i] = e[r].data,
                        e.splice(r, 1),
                        t.splice(r, 1),
                        s.globals.risingSeries.push(i)));
                    a = this._getSeriesBasedOnCollapsedState(a),
                    this.lgCtx.ctx.updateHelpers._updateSeries(a, s.config.chart.animations.dynamicAnimation.enabled)
                }
            }
        }, {
            key: "_getSeriesBasedOnCollapsedState",
            value: function(e) {
                var t = this.w;
                return e.forEach(t.globals.axisCharts ? function(i, s) {
                    t.globals.collapsedSeriesIndices.indexOf(s) > -1 && (e[s].data = [])
                }
                : function(i, s) {
                    t.globals.collapsedSeriesIndices.indexOf(s) > -1 && (e[s] = 0)
                }
                ),
                e
            }
        }]),
        y
    }()
      , Oe = function() {
        function y(e, t) {
            W(this, y),
            this.ctx = e,
            this.w = e.w,
            this.onLegendClick = this.onLegendClick.bind(this),
            this.onLegendHovered = this.onLegendHovered.bind(this),
            this.isBarsDistributed = "bar" === this.w.config.chart.type && this.w.config.plotOptions.bar.distributed && 1 === this.w.config.series.length,
            this.legendHelpers = new Ct(this)
        }
        return V(y, [{
            key: "init",
            value: function() {
                var e = this.w
                  , t = e.globals
                  , i = e.config;
                if ((i.legend.showForSingleSeries && 1 === t.series.length || this.isBarsDistributed || t.series.length > 1 || !t.axisCharts) && i.legend.show) {
                    for (; t.dom.elLegendWrap.firstChild; )
                        t.dom.elLegendWrap.removeChild(t.dom.elLegendWrap.firstChild);
                    this.drawLegends(),
                    M.isIE11() ? document.getElementsByTagName("head")[0].appendChild(this.legendHelpers.getLegendStyles()) : this.legendHelpers.appendToForeignObject(),
                    "bottom" === i.legend.position || "top" === i.legend.position ? this.legendAlignHorizontal() : "right" !== i.legend.position && "left" !== i.legend.position || this.legendAlignVertical()
                }
            }
        }, {
            key: "drawLegends",
            value: function() {
                var e = this
                  , t = this.w
                  , i = t.config.legend.fontFamily
                  , s = t.globals.seriesNames
                  , a = t.globals.colors.slice();
                if ("heatmap" === t.config.chart.type) {
                    var r = t.config.plotOptions.heatmap.colorScale.ranges;
                    s = r.map(function(H) {
                        return H.name ? H.name : H.from + " - " + H.to
                    }),
                    a = r.map(function(H) {
                        return H.color
                    })
                } else
                    this.isBarsDistributed && (s = t.globals.labels.slice());
                t.config.legend.customLegendItems.length && (s = t.config.legend.customLegendItems);
                for (var n = t.globals.legendFormatter, o = t.config.legend.inverseOrder, l = o ? s.length - 1 : 0; o ? l >= 0 : l <= s.length - 1; o ? l-- : l++) {
                    var c = n(s[l], {
                        seriesIndex: l,
                        w: t
                    })
                      , d = !1
                      , g = !1;
                    if (t.globals.collapsedSeries.length > 0)
                        for (var p = 0; p < t.globals.collapsedSeries.length; p++)
                            t.globals.collapsedSeries[p].index === l && (d = !0);
                    if (t.globals.ancillaryCollapsedSeriesIndices.length > 0)
                        for (var m = 0; m < t.globals.ancillaryCollapsedSeriesIndices.length; m++)
                            t.globals.ancillaryCollapsedSeriesIndices[m] === l && (g = !0);
                    var x = document.createElement("span");
                    x.classList.add("apexcharts-legend-marker");
                    var v = t.config.legend.markers.offsetX
                      , k = t.config.legend.markers.offsetY
                      , S = t.config.legend.markers.height
                      , C = t.config.legend.markers.width
                      , h = t.config.legend.markers.strokeWidth
                      , u = t.config.legend.markers.strokeColor
                      , b = t.config.legend.markers.radius
                      , w = x.style;
                    w.background = a[l],
                    w.color = a[l],
                    w.setProperty("background", a[l], "important"),
                    t.config.legend.markers.fillColors && t.config.legend.markers.fillColors[l] && (w.background = t.config.legend.markers.fillColors[l]),
                    void 0 !== t.globals.seriesColors[l] && (w.background = t.globals.seriesColors[l],
                    w.color = t.globals.seriesColors[l]),
                    w.height = Array.isArray(S) ? parseFloat(S[l]) + "px" : parseFloat(S) + "px",
                    w.width = Array.isArray(C) ? parseFloat(C[l]) + "px" : parseFloat(C) + "px",
                    w.left = (Array.isArray(v) ? parseFloat(v[l]) : parseFloat(v)) + "px",
                    w.top = (Array.isArray(k) ? parseFloat(k[l]) : parseFloat(k)) + "px",
                    w.borderWidth = Array.isArray(h) ? h[l] : h,
                    w.borderColor = Array.isArray(u) ? u[l] : u,
                    w.borderRadius = Array.isArray(b) ? parseFloat(b[l]) + "px" : parseFloat(b) + "px",
                    t.config.legend.markers.customHTML && (Array.isArray(t.config.legend.markers.customHTML) ? t.config.legend.markers.customHTML[l] && (x.innerHTML = t.config.legend.markers.customHTML[l]()) : x.innerHTML = t.config.legend.markers.customHTML()),
                    D.setAttrs(x, {
                        rel: l + 1,
                        "data:collapsed": d || g
                    }),
                    (d || g) && x.classList.add("apexcharts-inactive-legend");
                    var _ = document.createElement("div")
                      , X = document.createElement("span");
                    X.classList.add("apexcharts-legend-text"),
                    X.innerHTML = Array.isArray(c) ? c.join(" ") : c;
                    var I = t.config.legend.labels.useSeriesColors ? t.globals.colors[l] : t.config.legend.labels.colors;
                    I || (I = t.config.chart.foreColor),
                    X.style.color = I,
                    X.style.fontSize = parseFloat(t.config.legend.fontSize) + "px",
                    X.style.fontWeight = t.config.legend.fontWeight,
                    X.style.fontFamily = i || t.config.chart.fontFamily,
                    D.setAttrs(X, {
                        rel: l + 1,
                        i: l,
                        "data:default-text": encodeURIComponent(c),
                        "data:collapsed": d || g
                    }),
                    _.appendChild(x),
                    _.appendChild(X);
                    var R = new xe(this.ctx);
                    t.config.legend.showForZeroSeries || 0 === R.getSeriesTotalByIndex(l) && R.seriesHaveSameValues(l) && !R.isSeriesNull(l) && -1 === t.globals.collapsedSeriesIndices.indexOf(l) && -1 === t.globals.ancillaryCollapsedSeriesIndices.indexOf(l) && _.classList.add("apexcharts-hidden-zero-series"),
                    t.config.legend.showForNullSeries || R.isSeriesNull(l) && -1 === t.globals.collapsedSeriesIndices.indexOf(l) && -1 === t.globals.ancillaryCollapsedSeriesIndices.indexOf(l) && _.classList.add("apexcharts-hidden-null-series"),
                    t.globals.dom.elLegendWrap.appendChild(_),
                    t.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(t.config.legend.horizontalAlign)),
                    t.globals.dom.elLegendWrap.classList.add("apx-legend-position-" + t.config.legend.position),
                    _.classList.add("apexcharts-legend-series"),
                    _.style.margin = "".concat(t.config.legend.itemMargin.vertical, "px ").concat(t.config.legend.itemMargin.horizontal, "px"),
                    t.globals.dom.elLegendWrap.style.width = t.config.legend.width ? t.config.legend.width + "px" : "",
                    t.globals.dom.elLegendWrap.style.height = t.config.legend.height ? t.config.legend.height + "px" : "",
                    D.setAttrs(_, {
                        rel: l + 1,
                        seriesName: M.escapeString(s[l]),
                        "data:collapsed": d || g
                    }),
                    (d || g) && _.classList.add("apexcharts-inactive-legend"),
                    t.config.legend.onItemClick.toggleDataSeries || _.classList.add("apexcharts-no-click")
                }
                t.globals.dom.elWrap.addEventListener("click", e.onLegendClick, !0),
                t.config.legend.onItemHover.highlightDataSeries && 0 === t.config.legend.customLegendItems.length && (t.globals.dom.elWrap.addEventListener("mousemove", e.onLegendHovered, !0),
                t.globals.dom.elWrap.addEventListener("mouseout", e.onLegendHovered, !0))
            }
        }, {
            key: "setLegendWrapXY",
            value: function(e, t) {
                var i = this.w
                  , s = i.globals.dom.baseEl.querySelector(".apexcharts-legend")
                  , a = s.getBoundingClientRect()
                  , r = 0
                  , n = 0;
                if ("bottom" === i.config.legend.position)
                    n += i.globals.svgHeight - a.height / 2;
                else if ("top" === i.config.legend.position) {
                    var o = new xt(this.ctx)
                      , l = o.dimHelpers.getTitleSubtitleCoords("title").height
                      , c = o.dimHelpers.getTitleSubtitleCoords("subtitle").height;
                    n = n + (l > 0 ? l - 10 : 0) + (c > 0 ? c - 10 : 0)
                }
                s.style.position = "absolute",
                n = n + t + i.config.legend.offsetY,
                s.style.left = (r = r + e + i.config.legend.offsetX) + "px",
                s.style.top = n + "px",
                "bottom" === i.config.legend.position ? (s.style.top = "auto",
                s.style.bottom = 5 - i.config.legend.offsetY + "px") : "right" === i.config.legend.position && (s.style.left = "auto",
                s.style.right = 25 + i.config.legend.offsetX + "px"),
                ["width", "height"].forEach(function(d) {
                    s.style[d] && (s.style[d] = parseInt(i.config.legend[d], 10) + "px")
                })
            }
        }, {
            key: "legendAlignHorizontal",
            value: function() {
                var e = this.w;
                e.globals.dom.baseEl.querySelector(".apexcharts-legend").style.right = 0;
                var t = this.legendHelpers.getLegendBBox()
                  , i = new xt(this.ctx)
                  , s = i.dimHelpers.getTitleSubtitleCoords("title")
                  , a = i.dimHelpers.getTitleSubtitleCoords("subtitle")
                  , r = 0;
                "bottom" === e.config.legend.position ? r = -t.clwh / 1.8 : "top" === e.config.legend.position && (r = s.height + a.height + e.config.title.margin + e.config.subtitle.margin - 10),
                this.setLegendWrapXY(20, r)
            }
        }, {
            key: "legendAlignVertical",
            value: function() {
                var e = this.w
                  , t = this.legendHelpers.getLegendBBox()
                  , i = 0;
                "left" === e.config.legend.position && (i = 20),
                "right" === e.config.legend.position && (i = e.globals.svgWidth - t.clww - 10),
                this.setLegendWrapXY(i, 20)
            }
        }, {
            key: "onLegendHovered",
            value: function(e) {
                var t = this.w
                  , i = e.target.classList.contains("apexcharts-legend-text") || e.target.classList.contains("apexcharts-legend-marker");
                if ("heatmap" === t.config.chart.type || this.isBarsDistributed) {
                    if (i) {
                        var s = parseInt(e.target.getAttribute("rel"), 10) - 1;
                        this.ctx.events.fireEvent("legendHover", [this.ctx, s, this.w]),
                        new ve(this.ctx).highlightRangeInSeries(e, e.target)
                    }
                } else
                    !e.target.classList.contains("apexcharts-inactive-legend") && i && new ve(this.ctx).toggleSeriesOnHover(e, e.target)
            }
        }, {
            key: "onLegendClick",
            value: function(e) {
                var t = this.w;
                if (!t.config.legend.customLegendItems.length && (e.target.classList.contains("apexcharts-legend-text") || e.target.classList.contains("apexcharts-legend-marker"))) {
                    var i = parseInt(e.target.getAttribute("rel"), 10) - 1
                      , s = "true" === e.target.getAttribute("data:collapsed")
                      , a = this.w.config.chart.events.legendClick;
                    "function" == typeof a && a(this.ctx, i, this.w),
                    this.ctx.events.fireEvent("legendClick", [this.ctx, i, this.w]);
                    var r = this.w.config.legend.markers.onClick;
                    "function" == typeof r && e.target.classList.contains("apexcharts-legend-marker") && (r(this.ctx, i, this.w),
                    this.ctx.events.fireEvent("legendMarkerClick", [this.ctx, i, this.w])),
                    "treemap" !== t.config.chart.type && "heatmap" !== t.config.chart.type && !this.isBarsDistributed && t.config.legend.onItemClick.toggleDataSeries && this.legendHelpers.toggleDataSeries(i, s)
                }
            }
        }]),
        y
    }()
      , Yt = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w;
            var t = this.w;
            this.ev = this.w.config.chart.events,
            this.selectedClass = "apexcharts-selected",
            this.localeValues = this.w.globals.locale.toolbar,
            this.minX = t.globals.minX,
            this.maxX = t.globals.maxX
        }
        return V(y, [{
            key: "createToolbar",
            value: function() {
                var e = this
                  , t = this.w
                  , i = function() {
                    return document.createElement("div")
                }
                  , s = i();
                if (s.setAttribute("class", "apexcharts-toolbar"),
                s.style.top = t.config.chart.toolbar.offsetY + "px",
                s.style.right = 3 - t.config.chart.toolbar.offsetX + "px",
                t.globals.dom.elWrap.appendChild(s),
                this.elZoom = i(),
                this.elZoomIn = i(),
                this.elZoomOut = i(),
                this.elPan = i(),
                this.elSelection = i(),
                this.elZoomReset = i(),
                this.elMenuIcon = i(),
                this.elMenu = i(),
                this.elCustomIcons = [],
                this.t = t.config.chart.toolbar.tools,
                Array.isArray(this.t.customIcons))
                    for (var a = 0; a < this.t.customIcons.length; a++)
                        this.elCustomIcons.push(i());
                var r = []
                  , n = function(d, g, p) {
                    var m = d.toLowerCase();
                    e.t[m] && t.config.chart.zoom.enabled && r.push({
                        el: g,
                        icon: "string" == typeof e.t[m] ? e.t[m] : p,
                        title: e.localeValues[d],
                        class: "apexcharts-".concat(m, "-icon")
                    })
                };
                n("zoomIn", this.elZoomIn, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n'),
                n("zoomOut", this.elZoomOut, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n');
                var o = function(d) {
                    e.t[d] && t.config.chart[d].enabled && r.push({
                        el: "zoom" === d ? e.elZoom : e.elSelection,
                        icon: "string" == typeof e.t[d] ? e.t[d] : "zoom" === d ? '<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n    <path d="M0 0h24v24H0V0z" fill="none"/>\n    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>\n</svg>' : '<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>\n</svg>',
                        title: e.localeValues["zoom" === d ? "selectionZoom" : "selection"],
                        class: t.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-".concat(d, "-icon")
                    })
                };
                o("zoom"),
                o("selection"),
                this.t.pan && t.config.chart.zoom.enabled && r.push({
                    el: this.elPan,
                    icon: "string" == typeof this.t.pan ? this.t.pan : '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <defs>\n        <path d="M0 0h24v24H0z" id="a"/>\n    </defs>\n    <clipPath id="b">\n        <use overflow="visible" xlink:href="#a"/>\n    </clipPath>\n    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>\n</svg>',
                    title: this.localeValues.pan,
                    class: t.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon"
                }),
                n("reset", this.elZoomReset, '<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>'),
                this.t.download && r.push({
                    el: this.elMenuIcon,
                    icon: "string" == typeof this.t.download ? this.t.download : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>',
                    title: this.localeValues.menu,
                    class: "apexcharts-menu-icon"
                });
                for (var l = 0; l < this.elCustomIcons.length; l++)
                    r.push({
                        el: this.elCustomIcons[l],
                        icon: this.t.customIcons[l].icon,
                        title: this.t.customIcons[l].title,
                        index: this.t.customIcons[l].index,
                        class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[l].class
                    });
                r.forEach(function(d, g) {
                    d.index && M.moveIndexInArray(r, g, d.index)
                });
                for (var c = 0; c < r.length; c++)
                    D.setAttrs(r[c].el, {
                        class: r[c].class,
                        title: r[c].title
                    }),
                    r[c].el.innerHTML = r[c].icon,
                    s.appendChild(r[c].el);
                this._createHamburgerMenu(s),
                t.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : t.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : t.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass),
                this.addToolbarEventListeners()
            }
        }, {
            key: "_createHamburgerMenu",
            value: function(e) {
                this.elMenuItems = [],
                e.appendChild(this.elMenu),
                D.setAttrs(this.elMenu, {
                    class: "apexcharts-menu"
                });
                var t = [{
                    name: "exportSVG",
                    title: this.localeValues.exportToSVG
                }, {
                    name: "exportPNG",
                    title: this.localeValues.exportToPNG
                }, {
                    name: "exportCSV",
                    title: this.localeValues.exportToCSV
                }];
                this.w.globals.allSeriesHasEqualX || t.splice(2, 1);
                for (var i = 0; i < t.length; i++)
                    this.elMenuItems.push(document.createElement("div")),
                    this.elMenuItems[i].innerHTML = t[i].title,
                    D.setAttrs(this.elMenuItems[i], {
                        class: "apexcharts-menu-item ".concat(t[i].name),
                        title: t[i].title
                    }),
                    this.elMenu.appendChild(this.elMenuItems[i])
            }
        }, {
            key: "addToolbarEventListeners",
            value: function() {
                var e = this;
                this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)),
                this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")),
                this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")),
                this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)),
                this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)),
                this.elPan.addEventListener("click", this.togglePanning.bind(this)),
                this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)),
                this.elMenuItems.forEach(function(i) {
                    i.classList.contains("exportSVG") ? i.addEventListener("click", e.handleDownload.bind(e, "svg")) : i.classList.contains("exportPNG") ? i.addEventListener("click", e.handleDownload.bind(e, "png")) : i.classList.contains("exportCSV") && i.addEventListener("click", e.handleDownload.bind(e, "csv"))
                });
                for (var t = 0; t < this.t.customIcons.length; t++)
                    this.elCustomIcons[t].addEventListener("click", this.t.customIcons[t].click.bind(this, this.ctx, this.ctx.w))
            }
        }, {
            key: "toggleZoomSelection",
            value: function(e) {
                this.ctx.getSyncedCharts().forEach(function(t) {
                    t.ctx.toolbar.toggleOtherControls();
                    var i = "selection" === e ? t.ctx.toolbar.elSelection : t.ctx.toolbar.elZoom
                      , s = "selection" === e ? "selectionEnabled" : "zoomEnabled";
                    t.w.globals[s] = !t.w.globals[s],
                    i.classList.contains(t.ctx.toolbar.selectedClass) ? i.classList.remove(t.ctx.toolbar.selectedClass) : i.classList.add(t.ctx.toolbar.selectedClass)
                })
            }
        }, {
            key: "getToolbarIconsReference",
            value: function() {
                var e = this.w;
                this.elZoom || (this.elZoom = e.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")),
                this.elPan || (this.elPan = e.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")),
                this.elSelection || (this.elSelection = e.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"))
            }
        }, {
            key: "enableZoomPanFromToolbar",
            value: function(e) {
                this.toggleOtherControls(),
                "pan" === e ? this.w.globals.panEnabled = !0 : this.w.globals.zoomEnabled = !0;
                var t = "pan" === e ? this.elPan : this.elZoom
                  , i = "pan" === e ? this.elZoom : this.elPan;
                t && t.classList.add(this.selectedClass),
                i && i.classList.remove(this.selectedClass)
            }
        }, {
            key: "togglePanning",
            value: function() {
                this.ctx.getSyncedCharts().forEach(function(e) {
                    e.ctx.toolbar.toggleOtherControls(),
                    e.w.globals.panEnabled = !e.w.globals.panEnabled,
                    e.ctx.toolbar.elPan.classList.contains(e.ctx.toolbar.selectedClass) ? e.ctx.toolbar.elPan.classList.remove(e.ctx.toolbar.selectedClass) : e.ctx.toolbar.elPan.classList.add(e.ctx.toolbar.selectedClass)
                })
            }
        }, {
            key: "toggleOtherControls",
            value: function() {
                var e = this
                  , t = this.w;
                t.globals.panEnabled = !1,
                t.globals.zoomEnabled = !1,
                t.globals.selectionEnabled = !1,
                this.getToolbarIconsReference(),
                [this.elPan, this.elSelection, this.elZoom].forEach(function(i) {
                    i && i.classList.remove(e.selectedClass)
                })
            }
        }, {
            key: "handleZoomIn",
            value: function() {
                var e = this.w;
                e.globals.isRangeBar && (this.minX = e.globals.minY,
                this.maxX = e.globals.maxY);
                var t = (this.minX + this.maxX) / 2
                  , a = this._getNewMinXMaxX((this.minX + t) / 2, (this.maxX + t) / 2);
                e.globals.disableZoomIn || this.zoomUpdateOptions(a.minX, a.maxX)
            }
        }, {
            key: "handleZoomOut",
            value: function() {
                var e = this.w;
                if (e.globals.isRangeBar && (this.minX = e.globals.minY,
                this.maxX = e.globals.maxY),
                !("datetime" === e.config.xaxis.type && new Date(this.minX).getUTCFullYear() < 1e3)) {
                    var t = (this.minX + this.maxX) / 2
                      , a = this._getNewMinXMaxX(this.minX - (t - this.minX), this.maxX - (t - this.maxX));
                    e.globals.disableZoomOut || this.zoomUpdateOptions(a.minX, a.maxX)
                }
            }
        }, {
            key: "_getNewMinXMaxX",
            value: function(e, t) {
                var i = this.w.config.xaxis.convertedCatToNumeric;
                return {
                    minX: i ? Math.floor(e) : e,
                    maxX: i ? Math.floor(t) : t
                }
            }
        }, {
            key: "zoomUpdateOptions",
            value: function(e, t) {
                var i = this.w;
                if (void 0 !== e || void 0 !== t) {
                    if (!(i.config.xaxis.convertedCatToNumeric && (e < 1 && (e = 1,
                    t = i.globals.dataPoints),
                    t - e < 2))) {
                        var s = {
                            min: e,
                            max: t
                        }
                          , a = this.getBeforeZoomRange(s);
                        a && (s = a.xaxis);
                        var r = {
                            xaxis: s
                        }
                          , n = M.clone(i.globals.initialConfig.yaxis);
                        i.config.chart.zoom.autoScaleYaxis && (n = new Be(this.ctx).autoScaleY(this.ctx, n, {
                            xaxis: s
                        })),
                        i.config.chart.group || (r.yaxis = n),
                        this.w.globals.zoomed = !0,
                        this.ctx.updateHelpers._updateOptions(r, !1, this.w.config.chart.animations.dynamicAnimation.enabled),
                        this.zoomCallback(s, n)
                    }
                } else
                    this.handleZoomReset()
            }
        }, {
            key: "zoomCallback",
            value: function(e, t) {
                "function" == typeof this.ev.zoomed && this.ev.zoomed(this.ctx, {
                    xaxis: e,
                    yaxis: t
                })
            }
        }, {
            key: "getBeforeZoomRange",
            value: function(e, t) {
                var i = null;
                return "function" == typeof this.ev.beforeZoom && (i = this.ev.beforeZoom(this, {
                    xaxis: e,
                    yaxis: t
                })),
                i
            }
        }, {
            key: "toggleMenu",
            value: function() {
                var e = this;
                window.setTimeout(function() {
                    e.elMenu.classList.contains("apexcharts-menu-open") ? e.elMenu.classList.remove("apexcharts-menu-open") : e.elMenu.classList.add("apexcharts-menu-open")
                }, 0)
            }
        }, {
            key: "handleDownload",
            value: function(e) {
                var t = this.w
                  , i = new fe(this.ctx);
                switch (e) {
                case "svg":
                    i.exportToSVG(this.ctx);
                    break;
                case "png":
                    i.exportToPng(this.ctx);
                    break;
                case "csv":
                    i.exportToCSV({
                        series: t.config.series,
                        columnDelimiter: t.config.chart.toolbar.export.csv.columnDelimiter
                    })
                }
            }
        }, {
            key: "handleZoomReset",
            value: function(e) {
                this.ctx.getSyncedCharts().forEach(function(t) {
                    var i = t.w;
                    if (i.globals.lastXAxis.min = void 0,
                    i.globals.lastXAxis.max = void 0,
                    t.updateHelpers.revertDefaultAxisMinMax(),
                    "function" == typeof i.config.chart.events.beforeResetZoom) {
                        var s = i.config.chart.events.beforeResetZoom(t, i);
                        s && t.updateHelpers.revertDefaultAxisMinMax(s)
                    }
                    "function" == typeof i.config.chart.events.zoomed && t.ctx.toolbar.zoomCallback({
                        min: i.config.xaxis.min,
                        max: i.config.xaxis.max
                    }),
                    i.globals.zoomed = !1;
                    var a = t.ctx.series.emptyCollapsedSeries(M.clone(i.globals.initialSeries));
                    t.updateHelpers._updateSeries(a, i.config.chart.animations.dynamicAnimation.enabled)
                })
            }
        }, {
            key: "destroy",
            value: function() {
                this.elZoom = null,
                this.elZoomIn = null,
                this.elZoomOut = null,
                this.elPan = null,
                this.elSelection = null,
                this.elZoomReset = null,
                this.elMenuIcon = null
            }
        }]),
        y
    }()
      , gt = function(y) {
        Fe(t, y);
        var e = Te(t);
        function t(i) {
            var s;
            return W(this, t),
            (s = e.call(this, i)).ctx = i,
            s.w = i.w,
            s.dragged = !1,
            s.graphics = new D(s.ctx),
            s.eventList = ["mousedown", "mouseleave", "mousemove", "touchstart", "touchmove", "mouseup", "touchend"],
            s.clientX = 0,
            s.clientY = 0,
            s.startX = 0,
            s.endX = 0,
            s.dragX = 0,
            s.startY = 0,
            s.endY = 0,
            s.dragY = 0,
            s.moveDirection = "none",
            s
        }
        return V(t, [{
            key: "init",
            value: function(i) {
                var s = this
                  , a = i.xyRatios
                  , r = this.w
                  , n = this;
                this.xyRatios = a,
                this.zoomRect = this.graphics.drawRect(0, 0, 0, 0),
                this.selectionRect = this.graphics.drawRect(0, 0, 0, 0),
                this.gridRect = r.globals.dom.baseEl.querySelector(".apexcharts-grid"),
                this.zoomRect.node.classList.add("apexcharts-zoom-rect"),
                this.selectionRect.node.classList.add("apexcharts-selection-rect"),
                r.globals.dom.elGraphical.add(this.zoomRect),
                r.globals.dom.elGraphical.add(this.selectionRect),
                this.slDraggableRect = "x" === r.config.chart.selection.type ? this.selectionRect.draggable({
                    minX: 0,
                    minY: 0,
                    maxX: r.globals.gridWidth,
                    maxY: r.globals.gridHeight
                }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : "y" === r.config.chart.selection.type ? this.selectionRect.draggable({
                    minX: 0,
                    maxX: r.globals.gridWidth
                }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : this.selectionRect.draggable().on("dragmove", this.selectionDragging.bind(this, "dragging")),
                this.preselectedSelection(),
                this.hoverArea = r.globals.dom.baseEl.querySelector("".concat(r.globals.chartClass, " .apexcharts-svg")),
                this.hoverArea.classList.add("apexcharts-zoomable"),
                this.eventList.forEach(function(o) {
                    s.hoverArea.addEventListener(o, n.svgMouseEvents.bind(n, a), {
                        capture: !1,
                        passive: !0
                    })
                })
            }
        }, {
            key: "destroy",
            value: function() {
                this.slDraggableRect && (this.slDraggableRect.draggable(!1),
                this.slDraggableRect.off(),
                this.selectionRect.off()),
                this.selectionRect = null,
                this.zoomRect = null,
                this.gridRect = null
            }
        }, {
            key: "svgMouseEvents",
            value: function(i, s) {
                var a = this.w
                  , r = this
                  , n = this.ctx.toolbar
                  , o = a.globals.zoomEnabled ? a.config.chart.zoom.type : a.config.chart.selection.type
                  , l = a.config.chart.toolbar.autoSelected;
                if (s.shiftKey ? (this.shiftWasPressed = !0,
                n.enableZoomPanFromToolbar("pan" === l ? "zoom" : "pan")) : this.shiftWasPressed && (n.enableZoomPanFromToolbar(l),
                this.shiftWasPressed = !1),
                s.target) {
                    var c, d = s.target.classList;
                    if (s.target.parentNode && null !== s.target.parentNode && (c = s.target.parentNode.classList),
                    !(d.contains("apexcharts-selection-rect") || d.contains("apexcharts-legend-marker") || d.contains("apexcharts-legend-text") || c && c.contains("apexcharts-toolbar"))) {
                        if (r.clientX = "touchmove" === s.type || "touchstart" === s.type ? s.touches[0].clientX : "touchend" === s.type ? s.changedTouches[0].clientX : s.clientX,
                        r.clientY = "touchmove" === s.type || "touchstart" === s.type ? s.touches[0].clientY : "touchend" === s.type ? s.changedTouches[0].clientY : s.clientY,
                        "mousedown" === s.type && 1 === s.which) {
                            var g = r.gridRect.getBoundingClientRect();
                            r.startX = r.clientX - g.left,
                            r.startY = r.clientY - g.top,
                            r.dragged = !1,
                            r.w.globals.mousedown = !0
                        }
                        if (("mousemove" === s.type && 1 === s.which || "touchmove" === s.type) && (r.dragged = !0,
                        a.globals.panEnabled ? (a.globals.selection = null,
                        r.w.globals.mousedown && r.panDragging({
                            context: r,
                            zoomtype: o,
                            xyRatios: i
                        })) : (r.w.globals.mousedown && a.globals.zoomEnabled || r.w.globals.mousedown && a.globals.selectionEnabled) && (r.selection = r.selectionDrawing({
                            context: r,
                            zoomtype: o
                        }))),
                        "mouseup" === s.type || "touchend" === s.type || "mouseleave" === s.type) {
                            var p = r.gridRect.getBoundingClientRect();
                            r.w.globals.mousedown && (r.endX = r.clientX - p.left,
                            r.endY = r.clientY - p.top,
                            r.dragX = Math.abs(r.endX - r.startX),
                            r.dragY = Math.abs(r.endY - r.startY),
                            (a.globals.zoomEnabled || a.globals.selectionEnabled) && r.selectionDrawn({
                                context: r,
                                zoomtype: o
                            }),
                            a.globals.panEnabled && a.config.xaxis.convertedCatToNumeric && r.delayedPanScrolled()),
                            a.globals.zoomEnabled && r.hideSelectionRect(this.selectionRect),
                            r.dragged = !1,
                            r.w.globals.mousedown = !1
                        }
                        this.makeSelectionRectDraggable()
                    }
                }
            }
        }, {
            key: "makeSelectionRectDraggable",
            value: function() {
                var i = this.w;
                if (this.selectionRect) {
                    var s = this.selectionRect.node.getBoundingClientRect();
                    s.width > 0 && s.height > 0 && this.slDraggableRect.selectize({
                        points: "l, r",
                        pointSize: 8,
                        pointType: "rect"
                    }).resize({
                        constraint: {
                            minX: 0,
                            minY: 0,
                            maxX: i.globals.gridWidth,
                            maxY: i.globals.gridHeight
                        }
                    }).on("resizing", this.selectionDragging.bind(this, "resizing"))
                }
            }
        }, {
            key: "preselectedSelection",
            value: function() {
                var i = this.w
                  , s = this.xyRatios;
                if (!i.globals.zoomEnabled)
                    if (null != i.globals.selection)
                        this.drawSelectionRect(i.globals.selection);
                    else if (void 0 !== i.config.chart.selection.xaxis.min && void 0 !== i.config.chart.selection.xaxis.max) {
                        var a = (i.config.chart.selection.xaxis.min - i.globals.minX) / s.xRatio;
                        this.drawSelectionRect({
                            x: a,
                            y: 0,
                            width: i.globals.gridWidth - (i.globals.maxX - i.config.chart.selection.xaxis.max) / s.xRatio - a,
                            height: i.globals.gridHeight,
                            translateX: 0,
                            translateY: 0,
                            selectionEnabled: !0
                        }),
                        this.makeSelectionRectDraggable(),
                        "function" == typeof i.config.chart.events.selection && i.config.chart.events.selection(this.ctx, {
                            xaxis: {
                                min: i.config.chart.selection.xaxis.min,
                                max: i.config.chart.selection.xaxis.max
                            },
                            yaxis: {}
                        })
                    }
            }
        }, {
            key: "drawSelectionRect",
            value: function(i) {
                var s = i.x
                  , a = i.y
                  , r = i.width
                  , n = i.height
                  , o = i.translateX
                  , c = i.translateY
                  , g = this.w
                  , p = this.zoomRect
                  , m = this.selectionRect;
                if (this.dragged || null !== g.globals.selection) {
                    var x = {
                        transform: "translate(" + (void 0 === o ? 0 : o) + ", " + (void 0 === c ? 0 : c) + ")"
                    };
                    g.globals.zoomEnabled && this.dragged && (r < 0 && (r = 1),
                    p.attr({
                        x: s,
                        y: a,
                        width: r,
                        height: n,
                        fill: g.config.chart.zoom.zoomedArea.fill.color,
                        "fill-opacity": g.config.chart.zoom.zoomedArea.fill.opacity,
                        stroke: g.config.chart.zoom.zoomedArea.stroke.color,
                        "stroke-width": g.config.chart.zoom.zoomedArea.stroke.width,
                        "stroke-opacity": g.config.chart.zoom.zoomedArea.stroke.opacity
                    }),
                    D.setAttrs(p.node, x)),
                    g.globals.selectionEnabled && (m.attr({
                        x: s,
                        y: a,
                        width: r > 0 ? r : 0,
                        height: n > 0 ? n : 0,
                        fill: g.config.chart.selection.fill.color,
                        "fill-opacity": g.config.chart.selection.fill.opacity,
                        stroke: g.config.chart.selection.stroke.color,
                        "stroke-width": g.config.chart.selection.stroke.width,
                        "stroke-dasharray": g.config.chart.selection.stroke.dashArray,
                        "stroke-opacity": g.config.chart.selection.stroke.opacity
                    }),
                    D.setAttrs(m.node, x))
                }
            }
        }, {
            key: "hideSelectionRect",
            value: function(i) {
                i && i.attr({
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                })
            }
        }, {
            key: "selectionDrawing",
            value: function(i) {
                var x, a = i.zoomtype, r = this.w, n = i.context, o = this.gridRect.getBoundingClientRect(), l = n.startX - 1, c = n.startY, d = !1, g = !1, p = n.clientX - o.left - l, m = n.clientY - o.top - c;
                return Math.abs(p + l) > r.globals.gridWidth ? p = r.globals.gridWidth - l : n.clientX - o.left < 0 && (p = l),
                l > n.clientX - o.left && (d = !0,
                p = Math.abs(p)),
                c > n.clientY - o.top && (g = !0,
                m = Math.abs(m)),
                n.drawSelectionRect(x = "x" === a ? {
                    x: d ? l - p : l,
                    y: 0,
                    width: p,
                    height: r.globals.gridHeight
                } : "y" === a ? {
                    x: 0,
                    y: g ? c - m : c,
                    width: r.globals.gridWidth,
                    height: m
                } : {
                    x: d ? l - p : l,
                    y: g ? c - m : c,
                    width: p,
                    height: m
                }),
                n.selectionDragging("resizing"),
                x
            }
        }, {
            key: "selectionDragging",
            value: function(i, s) {
                var a = this
                  , r = this.w
                  , n = this.xyRatios
                  , o = this.selectionRect
                  , l = 0;
                "resizing" === i && (l = 30);
                var c = function(g) {
                    return parseFloat(o.node.getAttribute(g))
                }
                  , d = {
                    x: c("x"),
                    y: c("y"),
                    width: c("width"),
                    height: c("height")
                };
                r.globals.selection = d,
                "function" == typeof r.config.chart.events.selection && r.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer),
                this.w.globals.selectionResizeTimer = window.setTimeout(function() {
                    var g = a.gridRect.getBoundingClientRect()
                      , p = o.node.getBoundingClientRect()
                      , m = {
                        xaxis: {
                            min: r.globals.xAxisScale.niceMin + (p.left - g.left) * n.xRatio,
                            max: r.globals.xAxisScale.niceMin + (p.right - g.left) * n.xRatio
                        },
                        yaxis: {
                            min: r.globals.yAxisScale[0].niceMin + (g.bottom - p.bottom) * n.yRatio[0],
                            max: r.globals.yAxisScale[0].niceMax - (p.top - g.top) * n.yRatio[0]
                        }
                    };
                    r.config.chart.events.selection(a.ctx, m),
                    r.config.chart.brush.enabled && void 0 !== r.config.chart.events.brushScrolled && r.config.chart.events.brushScrolled(a.ctx, m)
                }, l))
            }
        }, {
            key: "selectionDrawn",
            value: function(i) {
                var a = i.zoomtype
                  , r = this.w
                  , n = i.context
                  , o = this.xyRatios
                  , l = this.ctx.toolbar;
                if (n.startX > n.endX) {
                    var c = n.startX;
                    n.startX = n.endX,
                    n.endX = c
                }
                if (n.startY > n.endY) {
                    var d = n.startY;
                    n.startY = n.endY,
                    n.endY = d
                }
                var g = void 0
                  , p = void 0;
                r.globals.isRangeBar ? (g = r.globals.yAxisScale[0].niceMin + n.startX * o.invertedYRatio,
                p = r.globals.yAxisScale[0].niceMin + n.endX * o.invertedYRatio) : (g = r.globals.xAxisScale.niceMin + n.startX * o.xRatio,
                p = r.globals.xAxisScale.niceMin + n.endX * o.xRatio);
                var m = []
                  , x = [];
                if (r.config.yaxis.forEach(function(w, _) {
                    m.push(r.globals.yAxisScale[_].niceMax - o.yRatio[_] * n.startY),
                    x.push(r.globals.yAxisScale[_].niceMax - o.yRatio[_] * n.endY)
                }),
                n.dragged && (n.dragX > 10 || n.dragY > 10) && g !== p)
                    if (r.globals.zoomEnabled) {
                        var v = M.clone(r.globals.initialConfig.yaxis)
                          , k = M.clone(r.globals.initialConfig.xaxis);
                        if (r.globals.zoomed = !0,
                        r.config.xaxis.convertedCatToNumeric && (g = Math.floor(g),
                        p = Math.floor(p),
                        g < 1 && (g = 1,
                        p = r.globals.dataPoints),
                        p - g < 2 && (p = g + 1)),
                        "xy" !== a && "x" !== a || (k = {
                            min: g,
                            max: p
                        }),
                        "xy" !== a && "y" !== a || v.forEach(function(w, _) {
                            v[_].min = x[_],
                            v[_].max = m[_]
                        }),
                        r.config.chart.zoom.autoScaleYaxis) {
                            var S = new Be(n.ctx);
                            v = S.autoScaleY(n.ctx, v, {
                                xaxis: k
                            })
                        }
                        if (l) {
                            var C = l.getBeforeZoomRange(k, v);
                            C && (k = C.xaxis ? C.xaxis : k,
                            v = C.yaxis ? C.yaxis : v)
                        }
                        var h = {
                            xaxis: k
                        };
                        r.config.chart.group || (h.yaxis = v),
                        n.ctx.updateHelpers._updateOptions(h, !1, n.w.config.chart.animations.dynamicAnimation.enabled),
                        "function" == typeof r.config.chart.events.zoomed && l.zoomCallback(k, v)
                    } else if (r.globals.selectionEnabled) {
                        var u, b = null;
                        u = {
                            min: g,
                            max: p
                        },
                        "xy" !== a && "y" !== a || (b = M.clone(r.config.yaxis)).forEach(function(w, _) {
                            b[_].min = x[_],
                            b[_].max = m[_]
                        }),
                        r.globals.selection = n.selection,
                        "function" == typeof r.config.chart.events.selection && r.config.chart.events.selection(n.ctx, {
                            xaxis: u,
                            yaxis: b
                        })
                    }
            }
        }, {
            key: "panDragging",
            value: function(i) {
                var a = this.w
                  , r = i.context;
                if (void 0 !== a.globals.lastClientPosition.x) {
                    var n = a.globals.lastClientPosition.x - r.clientX
                      , o = a.globals.lastClientPosition.y - r.clientY;
                    Math.abs(n) > Math.abs(o) && n > 0 ? this.moveDirection = "left" : Math.abs(n) > Math.abs(o) && n < 0 ? this.moveDirection = "right" : Math.abs(o) > Math.abs(n) && o > 0 ? this.moveDirection = "up" : Math.abs(o) > Math.abs(n) && o < 0 && (this.moveDirection = "down")
                }
                a.globals.lastClientPosition = {
                    x: r.clientX,
                    y: r.clientY
                },
                a.config.xaxis.convertedCatToNumeric || r.panScrolled(a.globals.isRangeBar ? a.globals.minY : a.globals.minX, a.globals.isRangeBar ? a.globals.maxY : a.globals.maxX)
            }
        }, {
            key: "delayedPanScrolled",
            value: function() {
                var i = this.w
                  , s = i.globals.minX
                  , a = i.globals.maxX
                  , r = (i.globals.maxX - i.globals.minX) / 2;
                "left" === this.moveDirection ? (s = i.globals.minX + r,
                a = i.globals.maxX + r) : "right" === this.moveDirection && (s = i.globals.minX - r,
                a = i.globals.maxX - r),
                s = Math.floor(s),
                a = Math.floor(a),
                this.updateScrolledChart({
                    xaxis: {
                        min: s,
                        max: a
                    }
                }, s, a)
            }
        }, {
            key: "panScrolled",
            value: function(i, s) {
                var a = this.w
                  , r = this.xyRatios
                  , n = M.clone(a.globals.initialConfig.yaxis)
                  , o = r.xRatio
                  , l = a.globals.minX
                  , c = a.globals.maxX;
                a.globals.isRangeBar && (o = r.invertedYRatio,
                l = a.globals.minY,
                c = a.globals.maxY),
                "left" === this.moveDirection ? (i = l + a.globals.gridWidth / 15 * o,
                s = c + a.globals.gridWidth / 15 * o) : "right" === this.moveDirection && (i = l - a.globals.gridWidth / 15 * o,
                s = c - a.globals.gridWidth / 15 * o),
                a.globals.isRangeBar || (i < a.globals.initialMinX || s > a.globals.initialMaxX) && (i = l,
                s = c);
                var d = {
                    min: i,
                    max: s
                };
                a.config.chart.zoom.autoScaleYaxis && (n = new Be(this.ctx).autoScaleY(this.ctx, n, {
                    xaxis: d
                }));
                var g = {
                    xaxis: {
                        min: i,
                        max: s
                    }
                };
                a.config.chart.group || (g.yaxis = n),
                this.updateScrolledChart(g, i, s)
            }
        }, {
            key: "updateScrolledChart",
            value: function(i, s, a) {
                var r = this.w;
                this.ctx.updateHelpers._updateOptions(i, !1, !1),
                "function" == typeof r.config.chart.events.scrolled && r.config.chart.events.scrolled(this.ctx, {
                    xaxis: {
                        min: s,
                        max: a
                    }
                })
            }
        }]),
        t
    }(Yt)
      , st = function() {
        function y(e) {
            W(this, y),
            this.w = e.w,
            this.ttCtx = e,
            this.ctx = e.ctx
        }
        return V(y, [{
            key: "getNearestValues",
            value: function(e) {
                var t = e.hoverArea
                  , s = e.clientX
                  , a = e.clientY
                  , r = this.w
                  , n = e.elGrid.getBoundingClientRect()
                  , o = n.width
                  , l = n.height
                  , c = o / (r.globals.dataPoints - 1)
                  , d = l / r.globals.dataPoints
                  , g = this.hasBars();
                !r.globals.comboCharts && !g || r.config.xaxis.convertedCatToNumeric || (c = o / r.globals.dataPoints);
                var p = s - n.left - r.globals.barPadForNumericAxis
                  , m = a - n.top;
                p < 0 || m < 0 || p > o || m > l ? (t.classList.remove("hovering-zoom"),
                t.classList.remove("hovering-pan")) : r.globals.zoomEnabled ? (t.classList.remove("hovering-pan"),
                t.classList.add("hovering-zoom")) : r.globals.panEnabled && (t.classList.remove("hovering-zoom"),
                t.classList.add("hovering-pan"));
                var x = Math.round(p / c)
                  , v = Math.floor(m / d);
                g && !r.config.xaxis.convertedCatToNumeric && (x = Math.ceil(p / c),
                x -= 1);
                for (var k, S = null, C = null, h = [], u = 0; u < r.globals.seriesXvalues.length; u++)
                    h.push([r.globals.seriesXvalues[u][0] - 1e-6].concat(r.globals.seriesXvalues[u]));
                if (h = h.map(function(X) {
                    return X.filter(function(I) {
                        return I
                    })
                }),
                k = r.globals.seriesYvalues.map(function(X) {
                    return X.filter(function(I) {
                        return M.isNumber(I)
                    })
                }),
                r.globals.isXNumeric) {
                    var b = this.ttCtx.getElGrid().getBoundingClientRect()
                      , w = p * (b.width / o);
                    S = (C = this.closestInMultiArray(w, m * (b.height / l), h, k)).index,
                    x = C.j,
                    null !== S && (x = (C = this.closestInArray(w, h = r.globals.seriesXvalues[S])).index)
                }
                return r.globals.capturedSeriesIndex = null === S ? -1 : S,
                (!x || x < 1) && (x = 0),
                r.globals.capturedDataPointIndex = r.globals.isBarHorizontal ? v : x,
                {
                    capturedSeries: S,
                    j: r.globals.isBarHorizontal ? v : x,
                    hoverX: p,
                    hoverY: m
                }
            }
        }, {
            key: "closestInMultiArray",
            value: function(e, t, i, s) {
                var r = 0
                  , n = null
                  , o = -1;
                this.w.globals.series.length > 1 ? r = this.getFirstActiveXArray(i) : n = 0;
                var l = s[r][0]
                  , d = Math.abs(e - i[r][0])
                  , g = Math.abs(t - l)
                  , p = g + d;
                return s.map(function(m, x) {
                    m.map(function(v, k) {
                        var S = Math.abs(t - s[x][k])
                          , C = Math.abs(e - i[x][k])
                          , h = C + S;
                        h < p && (p = h,
                        d = C,
                        g = S,
                        n = x,
                        o = k)
                    })
                }),
                {
                    index: n,
                    j: o
                }
            }
        }, {
            key: "getFirstActiveXArray",
            value: function(e) {
                for (var t = this.w, i = 0, s = e.map(function(r, n) {
                    return r.length > 0 ? n : -1
                }), a = 0; a < s.length; a++)
                    if (-1 !== s[a] && -1 === t.globals.collapsedSeriesIndices.indexOf(a) && -1 === t.globals.ancillaryCollapsedSeriesIndices.indexOf(a)) {
                        i = s[a];
                        break
                    }
                return i
            }
        }, {
            key: "closestInArray",
            value: function(e, t) {
                for (var s = null, a = Math.abs(e - t[0]), r = 0; r < t.length; r++) {
                    var n = Math.abs(e - t[r]);
                    n < a && (a = n,
                    s = r)
                }
                return {
                    index: s
                }
            }
        }, {
            key: "isXoverlap",
            value: function(e) {
                var t = []
                  , i = this.w.globals.seriesX.filter(function(a) {
                    return void 0 !== a[0]
                });
                if (i.length > 0)
                    for (var s = 0; s < i.length - 1; s++)
                        void 0 !== i[s][e] && void 0 !== i[s + 1][e] && i[s][e] !== i[s + 1][e] && t.push("unEqual");
                return 0 === t.length
            }
        }, {
            key: "isInitialSeriesSameLen",
            value: function() {
                for (var e = !0, t = this.w.globals.initialSeries, i = 0; i < t.length - 1; i++)
                    if (t[i].data.length !== t[i + 1].data.length) {
                        e = !1;
                        break
                    }
                return e
            }
        }, {
            key: "getBarsHeight",
            value: function(e) {
                return pe(e).reduce(function(t, i) {
                    return t + i.getBBox().height
                }, 0)
            }
        }, {
            key: "getElMarkers",
            value: function() {
                return this.w.globals.dom.baseEl.querySelectorAll(" .apexcharts-series-markers")
            }
        }, {
            key: "getAllMarkers",
            value: function() {
                var e = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");
                (e = pe(e)).sort(function(i, s) {
                    return Number(s.getAttribute("data:realIndex")) < Number(i.getAttribute("data:realIndex")) ? 0 : -1
                });
                var t = [];
                return e.forEach(function(i) {
                    t.push(i.querySelector(".apexcharts-marker"))
                }),
                t
            }
        }, {
            key: "hasMarkers",
            value: function() {
                return this.getElMarkers().length > 0
            }
        }, {
            key: "getElBars",
            value: function() {
                return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series")
            }
        }, {
            key: "hasBars",
            value: function() {
                return this.getElBars().length > 0
            }
        }, {
            key: "getHoverMarkerSize",
            value: function(e) {
                var t = this.w
                  , i = t.config.markers.hover.size;
                return void 0 === i && (i = t.globals.markers.size[e] + t.config.markers.hover.sizeOffset),
                i
            }
        }, {
            key: "toggleAllTooltipSeriesGroups",
            value: function(e) {
                var t = this.w
                  , i = this.ttCtx;
                0 === i.allTooltipSeriesGroups.length && (i.allTooltipSeriesGroups = t.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));
                for (var s = i.allTooltipSeriesGroups, a = 0; a < s.length; a++)
                    "enable" === e ? (s[a].classList.add("apexcharts-active"),
                    s[a].style.display = t.config.tooltip.items.display) : (s[a].classList.remove("apexcharts-active"),
                    s[a].style.display = "none")
            }
        }]),
        y
    }()
      , at = function() {
        function y(e) {
            W(this, y),
            this.w = e.w,
            this.ctx = e.ctx,
            this.ttCtx = e,
            this.tooltipUtil = new st(e)
        }
        return V(y, [{
            key: "drawSeriesTexts",
            value: function(e) {
                var t = e.shared
                  , i = void 0 === t || t
                  , s = e.ttItems
                  , a = e.i
                  , r = void 0 === a ? 0 : a
                  , n = e.j
                  , o = void 0 === n ? null : n
                  , d = e.e
                  , g = this.w;
                void 0 !== g.config.tooltip.custom ? this.handleCustomTooltip({
                    i: r,
                    j: o,
                    y1: e.y1,
                    y2: e.y2,
                    w: g
                }) : this.toggleActiveInactiveSeries(i);
                var p = this.getValuesToPrint({
                    i: r,
                    j: o
                });
                this.printLabels({
                    i: r,
                    j: o,
                    values: p,
                    ttItems: s,
                    shared: i,
                    e: d
                });
                var m = this.ttCtx.getElTooltip();
                this.ttCtx.tooltipRect.ttWidth = m.getBoundingClientRect().width,
                this.ttCtx.tooltipRect.ttHeight = m.getBoundingClientRect().height
            }
        }, {
            key: "printLabels",
            value: function(e) {
                var t, i = this, s = e.i, a = e.j, r = e.values, n = e.ttItems, o = e.shared, l = e.e, c = this.w, d = [], g = function(u) {
                    return c.globals.seriesGoals[u] && c.globals.seriesGoals[u][a] && Array.isArray(c.globals.seriesGoals[u][a])
                }, p = r.xVal, m = r.zVal, x = r.xAxisTTVal, v = "", k = c.globals.colors[s];
                null !== a && c.config.plotOptions.bar.distributed && (k = c.globals.colors[a]);
                for (var S = function(u, b) {
                    var w = i.getFormatters(s);
                    v = i.getSeriesName({
                        fn: w.yLbTitleFormatter,
                        index: s,
                        seriesIndex: s,
                        j: a
                    }),
                    "treemap" === c.config.chart.type && (v = w.yLbTitleFormatter(String(c.config.series[s].data[a].x), {
                        series: c.globals.series,
                        seriesIndex: s,
                        dataPointIndex: a,
                        w: c
                    }));
                    var _ = c.config.tooltip.inverseOrder ? b : u;
                    if (c.globals.axisCharts) {
                        var X = function(I) {
                            return w.yLbFormatter(c.globals.series[I][a], {
                                series: c.globals.series,
                                seriesIndex: I,
                                dataPointIndex: a,
                                w: c
                            })
                        };
                        o ? (w = i.getFormatters(_),
                        v = i.getSeriesName({
                            fn: w.yLbTitleFormatter,
                            index: _,
                            seriesIndex: s,
                            j: a
                        }),
                        k = c.globals.colors[_],
                        t = X(_),
                        g(_) && (d = c.globals.seriesGoals[_][a].map(function(I) {
                            return {
                                attrs: I,
                                val: w.yLbFormatter(I.value, {
                                    seriesIndex: _,
                                    dataPointIndex: a,
                                    w: c
                                })
                            }
                        }))) : (l && l.target && l.target.getAttribute("fill") && (k = l.target.getAttribute("fill")),
                        t = X(s),
                        g(s) && Array.isArray(c.globals.seriesGoals[s][a]) && (d = c.globals.seriesGoals[s][a].map(function(I) {
                            return {
                                attrs: I,
                                val: w.yLbFormatter(I.value, {
                                    seriesIndex: s,
                                    dataPointIndex: a,
                                    w: c
                                })
                            }
                        })))
                    }
                    null === a && (t = w.yLbFormatter(c.globals.series[s], Z(Z({}, c), {}, {
                        seriesIndex: s,
                        dataPointIndex: s
                    }))),
                    i.DOMHandling({
                        i: s,
                        t: _,
                        j: a,
                        ttItems: n,
                        values: {
                            val: t,
                            goalVals: d,
                            xVal: p,
                            xAxisTTVal: x,
                            zVal: m
                        },
                        seriesName: v,
                        shared: o,
                        pColor: k
                    })
                }, C = 0, h = c.globals.series.length - 1; C < c.globals.series.length; C++,
                h--)
                    S(C, h)
            }
        }, {
            key: "getFormatters",
            value: function(e) {
                var t, i = this.w, s = i.globals.yLabelFormatters[e];
                return void 0 !== i.globals.ttVal ? Array.isArray(i.globals.ttVal) ? (s = i.globals.ttVal[e] && i.globals.ttVal[e].formatter,
                t = i.globals.ttVal[e] && i.globals.ttVal[e].title && i.globals.ttVal[e].title.formatter) : (s = i.globals.ttVal.formatter,
                "function" == typeof i.globals.ttVal.title.formatter && (t = i.globals.ttVal.title.formatter)) : t = i.config.tooltip.y.title.formatter,
                "function" != typeof s && (s = i.globals.yLabelFormatters[0] ? i.globals.yLabelFormatters[0] : function(a) {
                    return a
                }
                ),
                "function" != typeof t && (t = function(a) {
                    return a
                }
                ),
                {
                    yLbFormatter: s,
                    yLbTitleFormatter: t
                }
            }
        }, {
            key: "getSeriesName",
            value: function(e) {
                var s = e.seriesIndex
                  , a = e.j
                  , r = this.w;
                return (0,
                e.fn)(String(r.globals.seriesNames[e.index]), {
                    series: r.globals.series,
                    seriesIndex: s,
                    dataPointIndex: a,
                    w: r
                })
            }
        }, {
            key: "DOMHandling",
            value: function(e) {
                var t = e.t
                  , i = e.j
                  , s = e.ttItems
                  , a = e.values
                  , r = e.seriesName
                  , n = e.shared
                  , o = e.pColor
                  , l = this.w
                  , c = this.ttCtx
                  , d = a.val
                  , g = a.goalVals
                  , p = a.xVal
                  , m = a.xAxisTTVal
                  , x = a.zVal
                  , v = null;
                v = s[t].children,
                l.config.tooltip.fillSeriesColor && (s[t].style.backgroundColor = o,
                v[0].style.display = "none"),
                c.showTooltipTitle && (null === c.tooltipTitle && (c.tooltipTitle = l.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")),
                c.tooltipTitle.innerHTML = p),
                c.isXAxisTooltipEnabled && (c.xaxisTooltipText.innerHTML = "" !== m ? m : p);
                var k = s[t].querySelector(".apexcharts-tooltip-text-y-label");
                k && (k.innerHTML = r || "");
                var S = s[t].querySelector(".apexcharts-tooltip-text-y-value");
                S && (S.innerHTML = void 0 !== d ? d : ""),
                v[0] && v[0].classList.contains("apexcharts-tooltip-marker") && (l.config.tooltip.marker.fillColors && Array.isArray(l.config.tooltip.marker.fillColors) && (o = l.config.tooltip.marker.fillColors[t]),
                v[0].style.backgroundColor = o),
                l.config.tooltip.marker.show || (v[0].style.display = "none");
                var C = s[t].querySelector(".apexcharts-tooltip-text-goals-label")
                  , h = s[t].querySelector(".apexcharts-tooltip-text-goals-value");
                if (g.length && l.globals.seriesGoals[t]) {
                    var u = function() {
                        var b = "<div >"
                          , w = "<div>";
                        g.forEach(function(_, X) {
                            b += ' <div style="display: flex"><span class="apexcharts-tooltip-marker" style="background-color: '.concat(_.attrs.strokeColor, '; height: 3px; border-radius: 0; top: 5px;"></span> ').concat(_.attrs.name, "</div>"),
                            w += "<div>".concat(_.val, "</div>")
                        }),
                        C.innerHTML = b + "</div>",
                        h.innerHTML = w + "</div>"
                    };
                    n ? l.globals.seriesGoals[t][i] && Array.isArray(l.globals.seriesGoals[t][i]) ? u() : (C.innerHTML = "",
                    h.innerHTML = "") : u()
                } else
                    C.innerHTML = "",
                    h.innerHTML = "";
                null !== x && (s[t].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = l.config.tooltip.z.title,
                s[t].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = void 0 !== x ? x : ""),
                n && v[0] && (v[0].parentNode.style.display = null == d || l.globals.ancillaryCollapsedSeriesIndices.indexOf(t) > -1 || l.globals.collapsedSeriesIndices.indexOf(t) > -1 ? "none" : l.config.tooltip.items.display)
            }
        }, {
            key: "toggleActiveInactiveSeries",
            value: function(e) {
                var t = this.w;
                if (e)
                    this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");
                else {
                    this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
                    var i = t.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group");
                    i && (i.classList.add("apexcharts-active"),
                    i.style.display = t.config.tooltip.items.display)
                }
            }
        }, {
            key: "getValuesToPrint",
            value: function(e) {
                var t = e.i
                  , i = e.j
                  , s = this.w
                  , a = this.ctx.series.filteredSeriesX()
                  , r = ""
                  , n = ""
                  , o = null
                  , l = null
                  , c = {
                    series: s.globals.series,
                    seriesIndex: t,
                    dataPointIndex: i,
                    w: s
                }
                  , d = s.globals.ttZFormatter;
                null === i ? l = s.globals.series[t] : s.globals.isXNumeric && "treemap" !== s.config.chart.type ? (r = a[t][i],
                0 === a[t].length && (r = a[this.tooltipUtil.getFirstActiveXArray(a)][i])) : r = void 0 !== s.globals.labels[i] ? s.globals.labels[i] : "";
                var g = r;
                return r = s.globals.isXNumeric && "datetime" === s.config.xaxis.type ? new ze(this.ctx).xLabelFormat(s.globals.ttKeyFormatter, g, g, {
                    i: void 0,
                    dateFormatter: new ge(this.ctx).formatDate,
                    w: this.w
                }) : s.globals.isBarHorizontal ? s.globals.yLabelFormatters[0](g, c) : s.globals.xLabelFormatter(g, c),
                void 0 !== s.config.tooltip.x.formatter && (r = s.globals.ttKeyFormatter(g, c)),
                s.globals.seriesZ.length > 0 && s.globals.seriesZ[t].length > 0 && (o = d(s.globals.seriesZ[t][i], s)),
                n = "function" == typeof s.config.xaxis.tooltip.formatter ? s.globals.xaxisTooltipFormatter(g, c) : r,
                {
                    val: Array.isArray(l) ? l.join(" ") : l,
                    xVal: Array.isArray(r) ? r.join(" ") : r,
                    xAxisTTVal: Array.isArray(n) ? n.join(" ") : n,
                    zVal: o
                }
            }
        }, {
            key: "handleCustomTooltip",
            value: function(e) {
                var t = e.i
                  , i = e.j
                  , s = e.y1
                  , a = e.y2
                  , r = e.w
                  , n = this.ttCtx.getElTooltip()
                  , o = r.config.tooltip.custom;
                Array.isArray(o) && o[t] && (o = o[t]),
                n.innerHTML = o({
                    ctx: this.ctx,
                    series: r.globals.series,
                    seriesIndex: t,
                    dataPointIndex: i,
                    y1: s,
                    y2: a,
                    w: r
                })
            }
        }]),
        y
    }()
      , $e = function() {
        function y(e) {
            W(this, y),
            this.ttCtx = e,
            this.ctx = e.ctx,
            this.w = e.w
        }
        return V(y, [{
            key: "moveXCrosshairs",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
                  , i = this.ttCtx
                  , s = this.w
                  , a = i.getElXCrosshairs()
                  , r = e - i.xcrosshairsWidth / 2
                  , n = s.globals.labels.slice().length;
                if (null !== t && (r = s.globals.gridWidth / n * t),
                null === a || s.globals.isBarHorizontal || (a.setAttribute("x", r),
                a.setAttribute("x1", r),
                a.setAttribute("x2", r),
                a.setAttribute("y2", s.globals.gridHeight),
                a.classList.add("apexcharts-active")),
                r < 0 && (r = 0),
                r > s.globals.gridWidth && (r = s.globals.gridWidth),
                i.isXAxisTooltipEnabled) {
                    var o = r;
                    "tickWidth" !== s.config.xaxis.crosshairs.width && "barWidth" !== s.config.xaxis.crosshairs.width || (o = r + i.xcrosshairsWidth / 2),
                    this.moveXAxisTooltip(o)
                }
            }
        }, {
            key: "moveYCrosshairs",
            value: function(e) {
                var t = this.ttCtx;
                null !== t.ycrosshairs && D.setAttrs(t.ycrosshairs, {
                    y1: e,
                    y2: e
                }),
                null !== t.ycrosshairsHidden && D.setAttrs(t.ycrosshairsHidden, {
                    y1: e,
                    y2: e
                })
            }
        }, {
            key: "moveXAxisTooltip",
            value: function(e) {
                var t = this.w
                  , i = this.ttCtx;
                if (null !== i.xaxisTooltip && 0 !== i.xcrosshairsWidth) {
                    i.xaxisTooltip.classList.add("apexcharts-active");
                    var a, s = i.xaxisOffY + t.config.xaxis.tooltip.offsetY + t.globals.translateY + 1 + t.config.xaxis.offsetY;
                    e -= i.xaxisTooltip.getBoundingClientRect().width / 2,
                    isNaN(e) || (e += t.globals.translateX,
                    a = new D(this.ctx).getTextRects(i.xaxisTooltipText.innerHTML),
                    i.xaxisTooltipText.style.minWidth = a.width + "px",
                    i.xaxisTooltip.style.left = e + "px",
                    i.xaxisTooltip.style.top = s + "px")
                }
            }
        }, {
            key: "moveYAxisTooltip",
            value: function(e) {
                var t = this.w
                  , i = this.ttCtx;
                null === i.yaxisTTEls && (i.yaxisTTEls = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
                var s = parseInt(i.ycrosshairsHidden.getAttribute("y1"), 10)
                  , a = t.globals.translateY + s
                  , r = i.yaxisTTEls[e].getBoundingClientRect().height
                  , n = t.globals.translateYAxisX[e] - 2;
                t.config.yaxis[e].opposite && (n -= 26),
                a -= r / 2,
                -1 === t.globals.ignoreYAxisIndexes.indexOf(e) ? (i.yaxisTTEls[e].classList.add("apexcharts-active"),
                i.yaxisTTEls[e].style.top = a + "px",
                i.yaxisTTEls[e].style.left = n + t.config.yaxis[e].tooltip.offsetX + "px") : i.yaxisTTEls[e].classList.remove("apexcharts-active")
            }
        }, {
            key: "moveTooltip",
            value: function(e, t) {
                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
                  , s = this.w
                  , a = this.ttCtx
                  , r = a.getElTooltip()
                  , n = a.tooltipRect
                  , o = null !== i ? parseFloat(i) : 1
                  , l = parseFloat(e) + o + 5
                  , c = parseFloat(t) + o / 2;
                if (l > s.globals.gridWidth / 2 && (l = l - n.ttWidth - o - 15),
                l > s.globals.gridWidth - n.ttWidth - 10 && (l = s.globals.gridWidth - n.ttWidth),
                l < -20 && (l = -20),
                s.config.tooltip.followCursor) {
                    var d = a.getElGrid()
                      , g = d.getBoundingClientRect();
                    c = a.e.clientY + s.globals.translateY - g.top - n.ttHeight / 2
                } else
                    s.globals.isBarHorizontal || (n.ttHeight / 2 + c > s.globals.gridHeight && (c = s.globals.gridHeight - n.ttHeight + s.globals.translateY),
                    c < 0 && (c = 0));
                isNaN(l) || (r.style.left = (l += s.globals.translateX) + "px",
                r.style.top = c + "px")
            }
        }, {
            key: "moveMarkers",
            value: function(e, t) {
                var i = this.w
                  , s = this.ttCtx;
                if (i.globals.markers.size[e] > 0)
                    for (var a = i.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(e, "'] .apexcharts-marker")), r = 0; r < a.length; r++)
                        parseInt(a[r].getAttribute("rel"), 10) === t && (s.marker.resetPointsSize(),
                        s.marker.enlargeCurrentPoint(t, a[r]));
                else
                    s.marker.resetPointsSize(),
                    this.moveDynamicPointOnHover(t, e)
            }
        }, {
            key: "moveDynamicPointOnHover",
            value: function(e, t) {
                var i, s, a = this.w, r = this.ttCtx, n = a.globals.pointsArray, o = r.tooltipUtil.getHoverMarkerSize(t), l = a.config.series[t].type;
                if (!l || "column" !== l && "candlestick" !== l && "boxPlot" !== l) {
                    i = n[t][e][0],
                    s = n[t][e][1] ? n[t][e][1] : 0;
                    var c = a.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t, "'] .apexcharts-series-markers circle"));
                    c && s < a.globals.gridHeight && s > 0 && (c.setAttribute("r", o),
                    c.setAttribute("cx", i),
                    c.setAttribute("cy", s)),
                    this.moveXCrosshairs(i),
                    r.fixedTooltip || this.moveTooltip(i, s, o)
                }
            }
        }, {
            key: "moveDynamicPointsOnHover",
            value: function(e) {
                var t, i = this.ttCtx, s = i.w, a = 0, r = 0, n = s.globals.pointsArray;
                t = new ve(this.ctx).getActiveConfigSeriesIndex(!0);
                var o = i.tooltipUtil.getHoverMarkerSize(t);
                n[t] && (a = n[t][e][0],
                r = n[t][e][1]);
                var l = i.tooltipUtil.getAllMarkers();
                if (null !== l)
                    for (var c = 0; c < s.globals.series.length; c++) {
                        var d = n[c];
                        if (s.globals.comboCharts && void 0 === d && l.splice(c, 0, null),
                        d && d.length) {
                            var g = n[c][e][1];
                            l[c].setAttribute("cx", a),
                            null !== g && !isNaN(g) && g < s.globals.gridHeight + o && g + o > 0 ? (l[c] && l[c].setAttribute("r", o),
                            l[c] && l[c].setAttribute("cy", g)) : l[c] && l[c].setAttribute("r", 0)
                        }
                    }
                this.moveXCrosshairs(a),
                i.fixedTooltip || this.moveTooltip(a, r || s.globals.gridHeight, o)
            }
        }, {
            key: "moveStickyTooltipOverBars",
            value: function(e) {
                var t = this.w
                  , i = this.ttCtx
                  , s = t.globals.columnSeries ? t.globals.columnSeries.length : t.globals.series.length
                  , a = s >= 2 && s % 2 == 0 ? Math.floor(s / 2) : Math.floor(s / 2) + 1;
                t.globals.isBarHorizontal && (a = new ve(this.ctx).getActiveConfigSeriesIndex(!1, "desc") + 1);
                var r = t.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(a, "'] path[j='").concat(e, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(a, "'] path[j='").concat(e, "'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(a, "'] path[j='").concat(e, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(a, "'] path[j='").concat(e, "']"))
                  , n = r ? parseFloat(r.getAttribute("cx")) : 0
                  , o = r ? parseFloat(r.getAttribute("cy")) : 0
                  , l = r ? parseFloat(r.getAttribute("barWidth")) : 0
                  , c = r ? parseFloat(r.getAttribute("barHeight")) : 0
                  , d = i.getElGrid().getBoundingClientRect()
                  , g = r.classList.contains("apexcharts-candlestick-area") || r.classList.contains("apexcharts-boxPlot-area");
                t.globals.isXNumeric ? (r && !g && (n -= s % 2 != 0 ? l / 2 : 0),
                r && g && t.globals.comboCharts && (n -= l / 2)) : t.globals.isBarHorizontal || (n = i.xAxisTicksPositions[e - 1] + i.dataPointsDividedWidth / 2,
                isNaN(n) && (n = i.xAxisTicksPositions[e] - i.dataPointsDividedWidth / 2)),
                t.globals.isBarHorizontal ? o += c / 3 : o = i.e.clientY - d.top - i.tooltipRect.ttHeight / 2,
                t.globals.isBarHorizontal || this.moveXCrosshairs(n),
                i.fixedTooltip || this.moveTooltip(n, o || t.globals.gridHeight)
            }
        }]),
        y
    }()
      , Zt = function() {
        function y(e) {
            W(this, y),
            this.w = e.w,
            this.ttCtx = e,
            this.ctx = e.ctx,
            this.tooltipPosition = new $e(e)
        }
        return V(y, [{
            key: "drawDynamicPoints",
            value: function() {
                var e = this.w
                  , t = new D(this.ctx)
                  , i = new Ae(this.ctx)
                  , s = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
                s = pe(s),
                e.config.chart.stacked && s.sort(function(d, g) {
                    return parseFloat(d.getAttribute("data:realIndex")) - parseFloat(g.getAttribute("data:realIndex"))
                });
                for (var a = 0; a < s.length; a++) {
                    var r = s[a].querySelector(".apexcharts-series-markers-wrap");
                    if (null !== r) {
                        var n = void 0
                          , o = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
                        "line" !== e.config.chart.type && "area" !== e.config.chart.type || e.globals.comboCharts || e.config.tooltip.intersect || (o += " no-pointer-events");
                        var l = i.getMarkerConfig({
                            cssClass: o,
                            seriesIndex: Number(r.getAttribute("data:realIndex"))
                        });
                        (n = t.drawMarker(0, 0, l)).node.setAttribute("default-marker-size", 0);
                        var c = document.createElementNS(e.globals.SVGNS, "g");
                        c.classList.add("apexcharts-series-markers"),
                        c.appendChild(n.node),
                        r.appendChild(c)
                    }
                }
            }
        }, {
            key: "enlargeCurrentPoint",
            value: function(e, t) {
                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
                  , s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null
                  , a = this.w;
                "bubble" !== a.config.chart.type && this.newPointSize(e, t);
                var r = t.getAttribute("cx")
                  , n = t.getAttribute("cy");
                if (null !== i && null !== s && (r = i,
                n = s),
                this.tooltipPosition.moveXCrosshairs(r),
                !this.fixedTooltip) {
                    if ("radar" === a.config.chart.type) {
                        var o = this.ttCtx.getElGrid()
                          , l = o.getBoundingClientRect();
                        r = this.ttCtx.e.clientX - l.left
                    }
                    this.tooltipPosition.moveTooltip(r, n, a.config.markers.hover.size)
                }
            }
        }, {
            key: "enlargePoints",
            value: function(e) {
                for (var t = this.w, i = this, s = this.ttCtx, a = e, r = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), n = t.config.markers.hover.size, o = 0; o < r.length; o++) {
                    var l = r[o].getAttribute("rel")
                      , c = r[o].getAttribute("index");
                    if (void 0 === n && (n = t.globals.markers.size[c] + t.config.markers.hover.sizeOffset),
                    a === parseInt(l, 10)) {
                        i.newPointSize(a, r[o]);
                        var d = r[o].getAttribute("cx")
                          , g = r[o].getAttribute("cy");
                        i.tooltipPosition.moveXCrosshairs(d),
                        s.fixedTooltip || i.tooltipPosition.moveTooltip(d, g, n)
                    } else
                        i.oldPointSize(r[o])
                }
            }
        }, {
            key: "newPointSize",
            value: function(e, t) {
                var i = this.w
                  , s = i.config.markers.hover.size
                  , a = 0 === e ? t.parentNode.firstChild : t.parentNode.lastChild;
                if ("0" !== a.getAttribute("default-marker-size")) {
                    var r = parseInt(a.getAttribute("index"), 10);
                    void 0 === s && (s = i.globals.markers.size[r] + i.config.markers.hover.sizeOffset),
                    s < 0 && (s = 0),
                    a.setAttribute("r", s)
                }
            }
        }, {
            key: "oldPointSize",
            value: function(e) {
                var t = parseFloat(e.getAttribute("default-marker-size"));
                e.setAttribute("r", t)
            }
        }, {
            key: "resetPointsSize",
            value: function() {
                for (var e = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), t = 0; t < e.length; t++) {
                    var i = parseFloat(e[t].getAttribute("default-marker-size"));
                    M.isNumber(i) && i >= 0 ? e[t].setAttribute("r", i) : e[t].setAttribute("r", 0)
                }
            }
        }]),
        y
    }()
      , _t = function() {
        function y(e) {
            W(this, y),
            this.w = e.w,
            this.ttCtx = e
        }
        return V(y, [{
            key: "getAttr",
            value: function(e, t) {
                return parseFloat(e.target.getAttribute(t))
            }
        }, {
            key: "handleHeatTreeTooltip",
            value: function(e) {
                var t = e.e
                  , i = e.opt
                  , s = e.x
                  , a = e.y
                  , n = this.ttCtx
                  , o = this.w;
                if (t.target.classList.contains("apexcharts-".concat(e.type, "-rect"))) {
                    var l = this.getAttr(t, "i")
                      , c = this.getAttr(t, "j")
                      , d = this.getAttr(t, "cx")
                      , g = this.getAttr(t, "cy")
                      , p = this.getAttr(t, "width")
                      , m = this.getAttr(t, "height");
                    if (n.tooltipLabels.drawSeriesTexts({
                        ttItems: i.ttItems,
                        i: l,
                        j: c,
                        shared: !1,
                        e: t
                    }),
                    o.globals.capturedSeriesIndex = l,
                    o.globals.capturedDataPointIndex = c,
                    s = d + n.tooltipRect.ttWidth / 2 + p,
                    a = g + n.tooltipRect.ttHeight / 2 - m / 2,
                    n.tooltipPosition.moveXCrosshairs(d + p / 2),
                    s > o.globals.gridWidth / 2 && (s = d - n.tooltipRect.ttWidth / 2 + p),
                    n.w.config.tooltip.followCursor) {
                        var x = o.globals.dom.elWrap.getBoundingClientRect();
                        s = o.globals.clientX - x.left - (s > o.globals.gridWidth / 2 ? n.tooltipRect.ttWidth : 0),
                        a = o.globals.clientY - x.top
                    }
                }
                return {
                    x: s,
                    y: a
                }
            }
        }, {
            key: "handleMarkerTooltip",
            value: function(e) {
                var t, i, s = e.e, a = e.opt, r = e.x, n = e.y, o = this.w, l = this.ttCtx;
                if (s.target.classList.contains("apexcharts-marker")) {
                    var c = parseInt(a.paths.getAttribute("cx"), 10)
                      , d = parseInt(a.paths.getAttribute("cy"), 10)
                      , g = parseFloat(a.paths.getAttribute("val"));
                    if (i = parseInt(a.paths.getAttribute("rel"), 10),
                    t = parseInt(a.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1,
                    l.intersect) {
                        var p = M.findAncestor(a.paths, "apexcharts-series");
                        p && (t = parseInt(p.getAttribute("data:realIndex"), 10))
                    }
                    if (l.tooltipLabels.drawSeriesTexts({
                        ttItems: a.ttItems,
                        i: t,
                        j: i,
                        shared: !l.showOnIntersect && o.config.tooltip.shared,
                        e: s
                    }),
                    "mouseup" === s.type && l.markerClick(s, t, i),
                    o.globals.capturedSeriesIndex = t,
                    o.globals.capturedDataPointIndex = i,
                    r = c,
                    n = d + o.globals.translateY - 1.4 * l.tooltipRect.ttHeight,
                    l.w.config.tooltip.followCursor) {
                        var m = l.getElGrid().getBoundingClientRect();
                        n = l.e.clientY + o.globals.translateY - m.top
                    }
                    g < 0 && (n = d),
                    l.marker.enlargeCurrentPoint(i, a.paths, r, n)
                }
                return {
                    x: r,
                    y: n
                }
            }
        }, {
            key: "handleBarTooltip",
            value: function(e) {
                var t, i, s = e.e, a = e.opt, r = this.w, n = this.ttCtx, o = n.getElTooltip(), l = 0, c = 0, d = 0, g = this.getBarTooltipXY({
                    e: s,
                    opt: a
                }), p = g.barHeight, m = g.j;
                r.globals.capturedSeriesIndex = t = g.i,
                r.globals.capturedDataPointIndex = m,
                r.globals.isBarHorizontal && n.tooltipUtil.hasBars() || !r.config.tooltip.shared ? (c = g.x,
                d = g.y,
                i = Array.isArray(r.config.stroke.width) ? r.config.stroke.width[t] : r.config.stroke.width,
                l = c) : r.globals.comboCharts || r.config.tooltip.shared || (l /= 2),
                isNaN(d) ? d = r.globals.svgHeight - n.tooltipRect.ttHeight : d < 0 && (d = 0);
                var x = parseInt(a.paths.parentNode.getAttribute("data:realIndex"), 10)
                  , v = r.globals.isMultipleYAxis ? r.config.yaxis[x] && r.config.yaxis[x].reversed : r.config.yaxis[0].reversed;
                if (c + n.tooltipRect.ttWidth > r.globals.gridWidth && !v ? c -= n.tooltipRect.ttWidth : c < 0 && (c = 0),
                n.w.config.tooltip.followCursor) {
                    var k = n.getElGrid().getBoundingClientRect();
                    d = n.e.clientY - k.top
                }
                null === n.tooltip && (n.tooltip = r.globals.dom.baseEl.querySelector(".apexcharts-tooltip")),
                r.config.tooltip.shared || n.tooltipPosition.moveXCrosshairs(r.globals.comboBarCount > 0 ? l + i / 2 : l),
                !n.fixedTooltip && (!r.config.tooltip.shared || r.globals.isBarHorizontal && n.tooltipUtil.hasBars()) && (v && (c -= n.tooltipRect.ttWidth) < 0 && (c = 0),
                !v || r.globals.isBarHorizontal && n.tooltipUtil.hasBars() || (d = d + p - 2 * (r.globals.series[t][m] < 0 ? p : 0)),
                n.tooltipRect.ttHeight + d > r.globals.gridHeight ? d = r.globals.gridHeight - n.tooltipRect.ttHeight + r.globals.translateY : (d = d + r.globals.translateY - n.tooltipRect.ttHeight / 2) < 0 && (d = 0),
                o.style.left = c + r.globals.translateX + "px",
                o.style.top = d + "px")
            }
        }, {
            key: "getBarTooltipXY",
            value: function(e) {
                var t = e.e
                  , i = e.opt
                  , s = this.w
                  , a = null
                  , r = this.ttCtx
                  , n = 0
                  , o = 0
                  , l = 0
                  , c = 0
                  , d = 0
                  , g = t.target.classList;
                if (g.contains("apexcharts-bar-area") || g.contains("apexcharts-candlestick-area") || g.contains("apexcharts-boxPlot-area") || g.contains("apexcharts-rangebar-area")) {
                    var p = t.target
                      , m = p.getBoundingClientRect()
                      , x = i.elGrid.getBoundingClientRect()
                      , v = m.height;
                    d = m.height;
                    var k = m.width
                      , S = parseInt(p.getAttribute("cx"), 10)
                      , C = parseInt(p.getAttribute("cy"), 10);
                    c = parseFloat(p.getAttribute("barWidth"));
                    var h = "touchmove" === t.type ? t.touches[0].clientX : t.clientX;
                    a = parseInt(p.getAttribute("j"), 10),
                    n = parseInt(p.parentNode.getAttribute("rel"), 10) - 1;
                    var u = p.getAttribute("data-range-y1")
                      , b = p.getAttribute("data-range-y2");
                    s.globals.comboCharts && (n = parseInt(p.parentNode.getAttribute("data:realIndex"), 10)),
                    r.tooltipLabels.drawSeriesTexts({
                        ttItems: i.ttItems,
                        i: n,
                        j: a,
                        y1: u ? parseInt(u, 10) : null,
                        y2: b ? parseInt(b, 10) : null,
                        shared: !r.showOnIntersect && s.config.tooltip.shared,
                        e: t
                    }),
                    s.config.tooltip.followCursor ? s.globals.isBarHorizontal ? (o = h - x.left + 15,
                    l = C - r.dataPointsDividedHeight + v / 2 - r.tooltipRect.ttHeight / 2) : (o = s.globals.isXNumeric ? S - k / 2 : S - r.dataPointsDividedWidth + k / 2,
                    l = t.clientY - x.top - r.tooltipRect.ttHeight / 2 - 15) : s.globals.isBarHorizontal ? ((o = S) < r.xyRatios.baseLineInvertedY && (o = S - r.tooltipRect.ttWidth),
                    l = C - r.dataPointsDividedHeight + v / 2 - r.tooltipRect.ttHeight / 2) : (o = s.globals.isXNumeric ? S - k / 2 : S - r.dataPointsDividedWidth + k / 2,
                    l = C)
                }
                return {
                    x: o,
                    y: l,
                    barHeight: d,
                    barWidth: c,
                    i: n,
                    j: a
                }
            }
        }]),
        y
    }()
      , Qt = function() {
        function y(e) {
            W(this, y),
            this.w = e.w,
            this.ttCtx = e
        }
        return V(y, [{
            key: "drawXaxisTooltip",
            value: function() {
                var e = this.w
                  , t = this.ttCtx
                  , i = "bottom" === e.config.xaxis.position;
                t.xaxisOffY = i ? e.globals.gridHeight + 1 : -e.globals.xAxisHeight - e.config.xaxis.axisTicks.height + 3;
                var s = i ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top"
                  , a = e.globals.dom.elWrap;
                t.isXAxisTooltipEnabled && null === e.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") && (t.xaxisTooltip = document.createElement("div"),
                t.xaxisTooltip.setAttribute("class", s + " apexcharts-theme-" + e.config.tooltip.theme),
                a.appendChild(t.xaxisTooltip),
                t.xaxisTooltipText = document.createElement("div"),
                t.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"),
                t.xaxisTooltipText.style.fontFamily = e.config.xaxis.tooltip.style.fontFamily || e.config.chart.fontFamily,
                t.xaxisTooltipText.style.fontSize = e.config.xaxis.tooltip.style.fontSize,
                t.xaxisTooltip.appendChild(t.xaxisTooltipText))
            }
        }, {
            key: "drawYaxisTooltip",
            value: function() {
                for (var e = this.w, t = this.ttCtx, i = function(a) {
                    var r = e.config.yaxis[a].opposite || e.config.yaxis[a].crosshairs.opposite;
                    t.yaxisOffX = r ? e.globals.gridWidth + 1 : 1;
                    var n = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(a, r ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left");
                    e.globals.yAxisSameScaleIndices.map(function(l, c) {
                        l.map(function(d, g) {
                            g === a && (n += e.config.yaxis[g].show ? " " : " apexcharts-yaxistooltip-hidden")
                        })
                    });
                    var o = e.globals.dom.elWrap;
                    null === e.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(a)) && (t.yaxisTooltip = document.createElement("div"),
                    t.yaxisTooltip.setAttribute("class", n + " apexcharts-theme-" + e.config.tooltip.theme),
                    o.appendChild(t.yaxisTooltip),
                    0 === a && (t.yaxisTooltipText = []),
                    t.yaxisTooltipText[a] = document.createElement("div"),
                    t.yaxisTooltipText[a].classList.add("apexcharts-yaxistooltip-text"),
                    t.yaxisTooltip.appendChild(t.yaxisTooltipText[a]))
                }, s = 0; s < e.config.yaxis.length; s++)
                    i(s)
            }
        }, {
            key: "setXCrosshairWidth",
            value: function() {
                var e = this.w
                  , t = this.ttCtx
                  , i = t.getElXCrosshairs();
                if (t.xcrosshairsWidth = parseInt(e.config.xaxis.crosshairs.width, 10),
                e.globals.comboCharts) {
                    var s = e.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
                    if (null !== s && "barWidth" === e.config.xaxis.crosshairs.width) {
                        var a = parseFloat(s.getAttribute("barWidth"));
                        t.xcrosshairsWidth = a
                    } else
                        "tickWidth" === e.config.xaxis.crosshairs.width && (t.xcrosshairsWidth = e.globals.gridWidth / e.globals.labels.length)
                } else if ("tickWidth" === e.config.xaxis.crosshairs.width)
                    t.xcrosshairsWidth = e.globals.gridWidth / e.globals.labels.length;
                else if ("barWidth" === e.config.xaxis.crosshairs.width) {
                    var o = e.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
                    if (null !== o) {
                        var l = parseFloat(o.getAttribute("barWidth"));
                        t.xcrosshairsWidth = l
                    } else
                        t.xcrosshairsWidth = 1
                }
                e.globals.isBarHorizontal && (t.xcrosshairsWidth = 0),
                null !== i && t.xcrosshairsWidth > 0 && i.setAttribute("width", t.xcrosshairsWidth)
            }
        }, {
            key: "handleYCrosshair",
            value: function() {
                var e = this.w
                  , t = this.ttCtx;
                t.ycrosshairs = e.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"),
                t.ycrosshairsHidden = e.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden")
            }
        }, {
            key: "drawYaxisTooltipText",
            value: function(e, t, i) {
                var s = this.ttCtx
                  , a = this.w
                  , r = a.globals.yLabelFormatters[e];
                if (s.yaxisTooltips[e]) {
                    var n = s.getElGrid().getBoundingClientRect()
                      , c = a.globals.minYArr[e] + (a.globals.maxYArr[e] - a.globals.minYArr[e] - (t - n.top) * i.yRatio[e]);
                    s.tooltipPosition.moveYCrosshairs(t - n.top),
                    s.yaxisTooltipText[e].innerHTML = r(c),
                    s.tooltipPosition.moveYAxisTooltip(e)
                }
            }
        }]),
        y
    }()
      , Kt = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w;
            var t = this.w;
            this.tConfig = t.config.tooltip,
            this.tooltipUtil = new st(this),
            this.tooltipLabels = new at(this),
            this.tooltipPosition = new $e(this),
            this.marker = new Zt(this),
            this.intersect = new _t(this),
            this.axesTooltip = new Qt(this),
            this.showOnIntersect = this.tConfig.intersect,
            this.showTooltipTitle = this.tConfig.x.show,
            this.fixedTooltip = this.tConfig.fixed.enabled,
            this.xaxisTooltip = null,
            this.yaxisTTEls = null,
            this.isBarShared = !t.globals.isBarHorizontal && this.tConfig.shared,
            this.lastHoverTime = Date.now()
        }
        return V(y, [{
            key: "getElTooltip",
            value: function(e) {
                return e || (e = this),
                e.w.globals.dom.baseEl ? e.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip") : null
            }
        }, {
            key: "getElXCrosshairs",
            value: function() {
                return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs")
            }
        }, {
            key: "getElGrid",
            value: function() {
                return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid")
            }
        }, {
            key: "drawTooltip",
            value: function(e) {
                var t = this.w;
                this.xyRatios = e,
                this.isXAxisTooltipEnabled = t.config.xaxis.tooltip.enabled && t.globals.axisCharts,
                this.yaxisTooltips = t.config.yaxis.map(function(r, n) {
                    return !!(r.show && r.tooltip.enabled && t.globals.axisCharts)
                }),
                this.allTooltipSeriesGroups = [],
                t.globals.axisCharts || (this.showTooltipTitle = !1);
                var i = document.createElement("div");
                if (i.classList.add("apexcharts-tooltip"),
                i.classList.add("apexcharts-theme-".concat(this.tConfig.theme)),
                t.globals.dom.elWrap.appendChild(i),
                t.globals.axisCharts) {
                    this.axesTooltip.drawXaxisTooltip(),
                    this.axesTooltip.drawYaxisTooltip(),
                    this.axesTooltip.setXCrosshairWidth(),
                    this.axesTooltip.handleYCrosshair();
                    var s = new Xe(this.ctx);
                    this.xAxisTicksPositions = s.getXAxisTicksPositions()
                }
                if (!t.globals.comboCharts && !this.tConfig.intersect && "rangeBar" !== t.config.chart.type || this.tConfig.shared || (this.showOnIntersect = !0),
                0 !== t.config.markers.size && 0 !== t.globals.markers.largestSize || this.marker.drawDynamicPoints(this),
                t.globals.collapsedSeries.length !== t.globals.series.length) {
                    this.dataPointsDividedHeight = t.globals.gridHeight / t.globals.dataPoints,
                    this.dataPointsDividedWidth = t.globals.gridWidth / t.globals.dataPoints,
                    this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"),
                    this.tooltipTitle.classList.add("apexcharts-tooltip-title"),
                    this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || t.config.chart.fontFamily,
                    this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize,
                    i.appendChild(this.tooltipTitle));
                    var a = t.globals.series.length;
                    (t.globals.xyCharts || t.globals.comboCharts) && this.tConfig.shared && (a = this.showOnIntersect ? 1 : t.globals.series.length),
                    this.legendLabels = t.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"),
                    this.ttItems = this.createTTElements(a),
                    this.addSVGEvents()
                }
            }
        }, {
            key: "createTTElements",
            value: function(e) {
                for (var t = this, i = this.w, s = [], a = this.getElTooltip(), r = function(o) {
                    var l = document.createElement("div");
                    l.classList.add("apexcharts-tooltip-series-group"),
                    l.style.order = i.config.tooltip.inverseOrder ? e - o : o + 1,
                    t.tConfig.shared && t.tConfig.enabledOnSeries && Array.isArray(t.tConfig.enabledOnSeries) && t.tConfig.enabledOnSeries.indexOf(o) < 0 && l.classList.add("apexcharts-tooltip-series-group-hidden");
                    var c = document.createElement("span");
                    c.classList.add("apexcharts-tooltip-marker"),
                    c.style.backgroundColor = i.globals.colors[o],
                    l.appendChild(c);
                    var d = document.createElement("div");
                    d.classList.add("apexcharts-tooltip-text"),
                    d.style.fontFamily = t.tConfig.style.fontFamily || i.config.chart.fontFamily,
                    d.style.fontSize = t.tConfig.style.fontSize,
                    ["y", "goals", "z"].forEach(function(g) {
                        var p = document.createElement("div");
                        p.classList.add("apexcharts-tooltip-".concat(g, "-group"));
                        var m = document.createElement("span");
                        m.classList.add("apexcharts-tooltip-text-".concat(g, "-label")),
                        p.appendChild(m);
                        var x = document.createElement("span");
                        x.classList.add("apexcharts-tooltip-text-".concat(g, "-value")),
                        p.appendChild(x),
                        d.appendChild(p)
                    }),
                    l.appendChild(d),
                    a.appendChild(l),
                    s.push(l)
                }, n = 0; n < e; n++)
                    r(n);
                return s
            }
        }, {
            key: "addSVGEvents",
            value: function() {
                var e = this.w
                  , t = e.config.chart.type
                  , i = this.getElTooltip()
                  , s = !("bar" !== t && "candlestick" !== t && "boxPlot" !== t && "rangeBar" !== t)
                  , a = "area" === t || "line" === t || "scatter" === t || "bubble" === t || "radar" === t
                  , r = e.globals.dom.Paper.node
                  , n = this.getElGrid();
                n && (this.seriesBound = n.getBoundingClientRect());
                var o, l = [], c = [], d = {
                    hoverArea: r,
                    elGrid: n,
                    tooltipEl: i,
                    tooltipY: l,
                    tooltipX: c,
                    ttItems: this.ttItems
                };
                if (e.globals.axisCharts && (a ? o = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : s ? o = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area") : "heatmap" !== t && "treemap" !== t || (o = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")),
                o && o.length))
                    for (var g = 0; g < o.length; g++)
                        l.push(o[g].getAttribute("cy")),
                        c.push(o[g].getAttribute("cx"));
                if (e.globals.xyCharts && !this.showOnIntersect || e.globals.comboCharts && !this.showOnIntersect || s && this.tooltipUtil.hasBars() && this.tConfig.shared)
                    this.addPathsEventListeners([r], d);
                else if (s && !e.globals.comboCharts || a && this.showOnIntersect)
                    this.addDatapointEventsListeners(d);
                else if (!e.globals.axisCharts || "heatmap" === t || "treemap" === t) {
                    var p = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
                    this.addPathsEventListeners(p, d)
                }
                if (this.showOnIntersect) {
                    var m = e.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");
                    m.length > 0 && this.addPathsEventListeners(m, d),
                    this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(d)
                }
            }
        }, {
            key: "drawFixedTooltipRect",
            value: function() {
                var e = this.w
                  , t = this.getElTooltip()
                  , i = t.getBoundingClientRect()
                  , s = i.width + 10
                  , a = i.height + 10
                  , r = this.tConfig.fixed.offsetX
                  , n = this.tConfig.fixed.offsetY
                  , o = this.tConfig.fixed.position.toLowerCase();
                return o.indexOf("right") > -1 && (r = r + e.globals.svgWidth - s + 10),
                o.indexOf("bottom") > -1 && (n = n + e.globals.svgHeight - a - 10),
                t.style.left = r + "px",
                t.style.top = n + "px",
                {
                    x: r,
                    y: n,
                    ttWidth: s,
                    ttHeight: a
                }
            }
        }, {
            key: "addDatapointEventsListeners",
            value: function(e) {
                var t = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area");
                this.addPathsEventListeners(t, e)
            }
        }, {
            key: "addPathsEventListeners",
            value: function(e, t) {
                for (var i = this, s = function(r) {
                    var n = {
                        paths: e[r],
                        tooltipEl: t.tooltipEl,
                        tooltipY: t.tooltipY,
                        tooltipX: t.tooltipX,
                        elGrid: t.elGrid,
                        hoverArea: t.hoverArea,
                        ttItems: t.ttItems
                    };
                    ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map(function(o) {
                        return e[r].addEventListener(o, i.onSeriesHover.bind(i, n), {
                            capture: !1,
                            passive: !0
                        })
                    })
                }, a = 0; a < e.length; a++)
                    s(a)
            }
        }, {
            key: "onSeriesHover",
            value: function(e, t) {
                var i = this
                  , s = Date.now() - this.lastHoverTime;
                s >= 100 ? this.seriesHover(e, t) : (clearTimeout(this.seriesHoverTimeout),
                this.seriesHoverTimeout = setTimeout(function() {
                    i.seriesHover(e, t)
                }, 100 - s))
            }
        }, {
            key: "seriesHover",
            value: function(e, t) {
                var i = this;
                this.lastHoverTime = Date.now();
                var s = []
                  , a = this.w;
                a.config.chart.group && (s = this.ctx.getGroupedCharts()),
                a.globals.axisCharts && (a.globals.minX === -1 / 0 && a.globals.maxX === 1 / 0 || 0 === a.globals.dataPoints) || (s.length ? s.forEach(function(r) {
                    var n = i.getElTooltip(r);
                    r.w.globals.minX === i.w.globals.minX && r.w.globals.maxX === i.w.globals.maxX && r.w.globals.tooltip.seriesHoverByContext({
                        chartCtx: r,
                        ttCtx: r.w.globals.tooltip,
                        opt: {
                            paths: e.paths,
                            tooltipEl: n,
                            tooltipY: e.tooltipY,
                            tooltipX: e.tooltipX,
                            elGrid: e.elGrid,
                            hoverArea: e.hoverArea,
                            ttItems: r.w.globals.tooltip.ttItems
                        },
                        e: t
                    })
                }) : this.seriesHoverByContext({
                    chartCtx: this.ctx,
                    ttCtx: this.w.globals.tooltip,
                    opt: e,
                    e: t
                }))
            }
        }, {
            key: "seriesHoverByContext",
            value: function(e) {
                var t = e.chartCtx
                  , i = e.ttCtx
                  , s = e.opt
                  , a = e.e
                  , r = t.w
                  , n = this.getElTooltip();
                n && (i.tooltipRect = {
                    x: 0,
                    y: 0,
                    ttWidth: n.getBoundingClientRect().width,
                    ttHeight: n.getBoundingClientRect().height
                },
                i.e = a,
                i.tooltipUtil.hasBars() && !r.globals.comboCharts && !i.isBarShared && this.tConfig.onDatasetHover.highlightDataSeries && new ve(t).toggleSeriesOnHover(a, a.target.parentNode),
                i.fixedTooltip && i.drawFixedTooltipRect(),
                r.globals.axisCharts ? i.axisChartsTooltips({
                    e: a,
                    opt: s,
                    tooltipRect: i.tooltipRect
                }) : i.nonAxisChartsTooltips({
                    e: a,
                    opt: s,
                    tooltipRect: i.tooltipRect
                }))
            }
        }, {
            key: "axisChartsTooltips",
            value: function(e) {
                var t, i, s = e.e, a = e.opt, r = this.w, n = a.elGrid.getBoundingClientRect(), o = "touchmove" === s.type ? s.touches[0].clientX : s.clientX, l = "touchmove" === s.type ? s.touches[0].clientY : s.clientY;
                if (this.clientY = l,
                this.clientX = o,
                r.globals.capturedSeriesIndex = -1,
                r.globals.capturedDataPointIndex = -1,
                l < n.top || l > n.top + n.height)
                    this.handleMouseOut(a);
                else {
                    if (Array.isArray(this.tConfig.enabledOnSeries) && !r.config.tooltip.shared) {
                        var c = parseInt(a.paths.getAttribute("index"), 10);
                        if (this.tConfig.enabledOnSeries.indexOf(c) < 0)
                            return void this.handleMouseOut(a)
                    }
                    var d = this.getElTooltip()
                      , g = this.getElXCrosshairs()
                      , p = r.globals.xyCharts || "bar" === r.config.chart.type && !r.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || r.globals.comboCharts && this.tooltipUtil.hasBars();
                    if ("mousemove" === s.type || "touchmove" === s.type || "mouseup" === s.type) {
                        if (r.globals.collapsedSeries.length + r.globals.ancillaryCollapsedSeries.length === r.globals.series.length)
                            return;
                        null !== g && g.classList.add("apexcharts-active");
                        var m = this.yaxisTooltips.filter(function(k) {
                            return !0 === k
                        });
                        if (null !== this.ycrosshairs && m.length && this.ycrosshairs.classList.add("apexcharts-active"),
                        p && !this.showOnIntersect)
                            this.handleStickyTooltip(s, o, l, a);
                        else if ("heatmap" === r.config.chart.type || "treemap" === r.config.chart.type) {
                            var x = this.intersect.handleHeatTreeTooltip({
                                e: s,
                                opt: a,
                                x: t,
                                y: i,
                                type: r.config.chart.type
                            });
                            i = x.y,
                            d.style.left = (t = x.x) + "px",
                            d.style.top = i + "px"
                        } else
                            this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({
                                e: s,
                                opt: a
                            }),
                            this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({
                                e: s,
                                opt: a,
                                x: t,
                                y: i
                            });
                        if (this.yaxisTooltips.length)
                            for (var v = 0; v < r.config.yaxis.length; v++)
                                this.axesTooltip.drawYaxisTooltipText(v, l, this.xyRatios);
                        a.tooltipEl.classList.add("apexcharts-active")
                    } else
                        "mouseout" !== s.type && "touchend" !== s.type || this.handleMouseOut(a)
                }
            }
        }, {
            key: "nonAxisChartsTooltips",
            value: function(e) {
                var t = e.e
                  , i = e.opt
                  , s = e.tooltipRect
                  , a = this.w
                  , r = i.paths.getAttribute("rel")
                  , n = this.getElTooltip()
                  , o = a.globals.dom.elWrap.getBoundingClientRect();
                if ("mousemove" === t.type || "touchmove" === t.type) {
                    n.classList.add("apexcharts-active"),
                    this.tooltipLabels.drawSeriesTexts({
                        ttItems: i.ttItems,
                        i: parseInt(r, 10) - 1,
                        shared: !1
                    });
                    var c = a.globals.clientY - o.top - s.ttHeight - 10;
                    if (n.style.left = a.globals.clientX - o.left - s.ttWidth / 2 + "px",
                    n.style.top = c + "px",
                    a.config.legend.tooltipHoverFormatter) {
                        var d = r - 1
                          , g = (0,
                        a.config.legend.tooltipHoverFormatter)(this.legendLabels[d].getAttribute("data:default-text"), {
                            seriesIndex: d,
                            dataPointIndex: d,
                            w: a
                        });
                        this.legendLabels[d].innerHTML = g
                    }
                } else
                    "mouseout" !== t.type && "touchend" !== t.type || (n.classList.remove("apexcharts-active"),
                    a.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(p) {
                        var m = p.getAttribute("data:default-text");
                        p.innerHTML = decodeURIComponent(m)
                    }))
            }
        }, {
            key: "handleStickyTooltip",
            value: function(e, t, i, s) {
                var a = this.w
                  , r = this.tooltipUtil.getNearestValues({
                    context: this,
                    hoverArea: s.hoverArea,
                    elGrid: s.elGrid,
                    clientX: t,
                    clientY: i
                })
                  , n = r.j
                  , o = r.capturedSeries
                  , l = s.elGrid.getBoundingClientRect();
                r.hoverX < 0 || r.hoverX > l.width ? this.handleMouseOut(s) : null !== o ? this.handleStickyCapturedSeries(e, o, s, n) : (this.tooltipUtil.isXoverlap(n) || a.globals.isBarHorizontal) && this.create(e, this, 0, n, s.ttItems)
            }
        }, {
            key: "handleStickyCapturedSeries",
            value: function(e, t, i, s) {
                var a = this.w;
                this.tConfig.shared || null !== a.globals.series[t][s] ? void 0 !== a.globals.series[t][s] ? this.tConfig.shared && this.tooltipUtil.isXoverlap(s) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(e, this, t, s, i.ttItems) : this.create(e, this, t, s, i.ttItems, !1) : this.tooltipUtil.isXoverlap(s) && this.create(e, this, 0, s, i.ttItems) : this.handleMouseOut(i)
            }
        }, {
            key: "deactivateHoverFilter",
            value: function() {
                for (var e = this.w, t = new D(this.ctx), i = e.globals.dom.Paper.select(".apexcharts-bar-area"), s = 0; s < i.length; s++)
                    t.pathMouseLeave(i[s])
            }
        }, {
            key: "handleMouseOut",
            value: function(e) {
                var t = this.w
                  , i = this.getElXCrosshairs();
                if (e.tooltipEl.classList.remove("apexcharts-active"),
                this.deactivateHoverFilter(),
                "bubble" !== t.config.chart.type && this.marker.resetPointsSize(),
                null !== i && i.classList.remove("apexcharts-active"),
                null !== this.ycrosshairs && this.ycrosshairs.classList.remove("apexcharts-active"),
                this.isXAxisTooltipEnabled && this.xaxisTooltip.classList.remove("apexcharts-active"),
                this.yaxisTooltips.length) {
                    null === this.yaxisTTEls && (this.yaxisTTEls = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
                    for (var s = 0; s < this.yaxisTTEls.length; s++)
                        this.yaxisTTEls[s].classList.remove("apexcharts-active")
                }
                t.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(a) {
                    var r = a.getAttribute("data:default-text");
                    a.innerHTML = decodeURIComponent(r)
                })
            }
        }, {
            key: "markerClick",
            value: function(e, t, i) {
                var s = this.w;
                "function" == typeof s.config.chart.events.markerClick && s.config.chart.events.markerClick(e, this.ctx, {
                    seriesIndex: t,
                    dataPointIndex: i,
                    w: s
                }),
                this.ctx.events.fireEvent("markerClick", [e, this.ctx, {
                    seriesIndex: t,
                    dataPointIndex: i,
                    w: s
                }])
            }
        }, {
            key: "create",
            value: function(e, t, i, s, a) {
                var r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null
                  , n = this.w
                  , o = t;
                "mouseup" === e.type && this.markerClick(e, i, s),
                null === r && (r = this.tConfig.shared);
                var l = this.tooltipUtil.hasMarkers()
                  , c = this.tooltipUtil.getElBars();
                if (n.config.legend.tooltipHoverFormatter) {
                    var d = n.config.legend.tooltipHoverFormatter
                      , g = Array.from(this.legendLabels);
                    g.forEach(function(u) {
                        var b = u.getAttribute("data:default-text");
                        u.innerHTML = decodeURIComponent(b)
                    });
                    for (var p = 0; p < g.length; p++) {
                        var m = g[p]
                          , x = parseInt(m.getAttribute("i"), 10)
                          , v = decodeURIComponent(m.getAttribute("data:default-text"))
                          , k = d(v, {
                            seriesIndex: r ? x : i,
                            dataPointIndex: s,
                            w: n
                        });
                        if (r)
                            m.innerHTML = n.globals.collapsedSeriesIndices.indexOf(x) < 0 ? k : v;
                        else if (m.innerHTML = x === i ? k : v,
                        i === x)
                            break
                    }
                }
                if (r) {
                    if (o.tooltipLabels.drawSeriesTexts({
                        ttItems: a,
                        i,
                        j: s,
                        shared: !this.showOnIntersect && this.tConfig.shared
                    }),
                    l && (n.globals.markers.largestSize > 0 ? o.marker.enlargePoints(s) : o.tooltipPosition.moveDynamicPointsOnHover(s)),
                    this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(c),
                    this.barSeriesHeight > 0)) {
                        var S = new D(this.ctx)
                          , C = n.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(s, "']"));
                        this.deactivateHoverFilter(),
                        this.tooltipPosition.moveStickyTooltipOverBars(s);
                        for (var h = 0; h < C.length; h++)
                            S.pathMouseEnter(C[h])
                    }
                } else
                    o.tooltipLabels.drawSeriesTexts({
                        shared: !1,
                        ttItems: a,
                        i,
                        j: s
                    }),
                    this.tooltipUtil.hasBars() && o.tooltipPosition.moveStickyTooltipOverBars(s),
                    l && o.tooltipPosition.moveMarkers(i, s)
            }
        }]),
        y
    }()
      , Ft = function(y) {
        Fe(t, y);
        var e = Te(t);
        function t() {
            return W(this, t),
            e.apply(this, arguments)
        }
        return V(t, [{
            key: "draw",
            value: function(i, s) {
                var a = this
                  , r = this.w;
                this.graphics = new D(this.ctx),
                this.bar = new Je(this.ctx,this.xyRatios);
                var n = new xe(this.ctx,r);
                i = n.getLogSeries(i),
                this.yRatio = n.getLogYRatios(this.yRatio),
                this.barHelpers.initVariables(i),
                "100%" === r.config.chart.stackType && (i = r.globals.seriesPercent.slice()),
                this.series = i,
                this.totalItems = 0,
                this.prevY = [],
                this.prevX = [],
                this.prevYF = [],
                this.prevXF = [],
                this.prevYVal = [],
                this.prevXVal = [],
                this.xArrj = [],
                this.xArrjF = [],
                this.xArrjVal = [],
                this.yArrj = [],
                this.yArrjF = [],
                this.yArrjVal = [];
                for (var o = 0; o < i.length; o++)
                    i[o].length > 0 && (this.totalItems += i[o].length);
                for (var l = this.graphics.group({
                    class: "apexcharts-bar-series apexcharts-plot-series"
                }), c = 0, d = 0, g = function(x, v) {
                    var k = void 0
                      , S = void 0
                      , C = void 0
                      , h = void 0
                      , u = []
                      , b = []
                      , w = r.globals.comboCharts ? s[x] : x;
                    a.yRatio.length > 1 && (a.yaxisIndex = w),
                    a.isReversed = r.config.yaxis[a.yaxisIndex] && r.config.yaxis[a.yaxisIndex].reversed;
                    var _ = a.graphics.group({
                        class: "apexcharts-series",
                        seriesName: M.escapeString(r.globals.seriesNames[w]),
                        rel: x + 1,
                        "data:realIndex": w
                    });
                    a.ctx.series.addCollapsedClassToSeries(_, w);
                    var X = a.graphics.group({
                        class: "apexcharts-datalabels",
                        "data:realIndex": w
                    })
                      , I = 0
                      , R = 0
                      , H = a.initialPositions(c, d, k, S, C, h);
                    d = H.y,
                    I = H.barHeight,
                    S = H.yDivision,
                    h = H.zeroW,
                    c = H.x,
                    R = H.barWidth,
                    k = H.xDivision,
                    C = H.zeroH,
                    a.yArrj = [],
                    a.yArrjF = [],
                    a.yArrjVal = [],
                    a.xArrj = [],
                    a.xArrjF = [],
                    a.xArrjVal = [],
                    1 === a.prevY.length && a.prevY[0].every(function(Le) {
                        return isNaN(Le)
                    }) && (a.prevY[0] = a.prevY[0].map(function(Le) {
                        return C
                    }),
                    a.prevYF[0] = a.prevYF[0].map(function(Le) {
                        return 0
                    }));
                    for (var G = 0; G < r.globals.dataPoints; G++) {
                        var ie = a.barHelpers.getStrokeWidth(x, G, w)
                          , ne = {
                            indexes: {
                                i: x,
                                j: G,
                                realIndex: w,
                                bc: v
                            },
                            strokeWidth: ie,
                            x: c,
                            y: d,
                            elSeries: _
                        }
                          , oe = null;
                        a.isHorizontal ? (oe = a.drawStackedBarPaths(Z(Z({}, ne), {}, {
                            zeroW: h,
                            barHeight: I,
                            yDivision: S
                        })),
                        R = a.series[x][G] / a.invertedYRatio) : (oe = a.drawStackedColumnPaths(Z(Z({}, ne), {}, {
                            xDivision: k,
                            barWidth: R,
                            zeroH: C
                        })),
                        I = a.series[x][G] / a.yRatio[a.yaxisIndex]),
                        d = oe.y,
                        u.push(c = oe.x),
                        b.push(d);
                        var ye = a.barHelpers.getPathFillColor(i, x, G, w);
                        _ = a.renderSeries({
                            realIndex: w,
                            pathFill: ye,
                            j: G,
                            i: x,
                            pathFrom: oe.pathFrom,
                            pathTo: oe.pathTo,
                            strokeWidth: ie,
                            elSeries: _,
                            x: c,
                            y: d,
                            series: i,
                            barHeight: I,
                            barWidth: R,
                            elDataLabelsWrap: X,
                            type: "bar",
                            visibleSeries: 0
                        })
                    }
                    r.globals.seriesXvalues[w] = u,
                    r.globals.seriesYvalues[w] = b,
                    a.prevY.push(a.yArrj),
                    a.prevYF.push(a.yArrjF),
                    a.prevYVal.push(a.yArrjVal),
                    a.prevX.push(a.xArrj),
                    a.prevXF.push(a.xArrjF),
                    a.prevXVal.push(a.xArrjVal),
                    l.add(_)
                }, p = 0, m = 0; p < i.length; p++,
                m++)
                    g(p, m);
                return l
            }
        }, {
            key: "initialPositions",
            value: function(i, s, a, r, n, o) {
                var l, c, d = this.w;
                return this.isHorizontal ? (l = (l = r = d.globals.gridHeight / d.globals.dataPoints) * parseInt(d.config.plotOptions.bar.barHeight, 10) / 100,
                o = this.baseLineInvertedY + d.globals.padHorizontal + (this.isReversed ? d.globals.gridWidth : 0) - (this.isReversed ? 2 * this.baseLineInvertedY : 0),
                s = (r - l) / 2) : (c = a = d.globals.gridWidth / d.globals.dataPoints,
                c = d.globals.isXNumeric && d.globals.dataPoints > 1 ? (a = d.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : c * parseInt(d.config.plotOptions.bar.columnWidth, 10) / 100,
                n = this.baseLineY[this.yaxisIndex] + (this.isReversed ? d.globals.gridHeight : 0) - (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0),
                i = d.globals.padHorizontal + (a - c) / 2),
                {
                    x: i,
                    y: s,
                    yDivision: r,
                    xDivision: a,
                    barHeight: l,
                    barWidth: c,
                    zeroH: n,
                    zeroW: o
                }
            }
        }, {
            key: "drawStackedBarPaths",
            value: function(i) {
                for (var s, l, a = i.indexes, r = i.barHeight, n = i.strokeWidth, o = i.zeroW, c = i.y, d = i.yDivision, g = i.elSeries, p = this.w, m = c, x = a.i, v = a.j, k = 0, S = 0; S < this.prevXF.length; S++)
                    k += this.prevXF[S][v];
                if (x > 0) {
                    var C = o;
                    this.prevXVal[x - 1][v] < 0 ? C = this.series[x][v] >= 0 ? this.prevX[x - 1][v] + k - 2 * (this.isReversed ? k : 0) : this.prevX[x - 1][v] : this.prevXVal[x - 1][v] >= 0 && (C = this.series[x][v] >= 0 ? this.prevX[x - 1][v] : this.prevX[x - 1][v] - k + 2 * (this.isReversed ? k : 0)),
                    s = C
                } else
                    s = o;
                var h = this.barHelpers.getBarpaths({
                    barYPosition: m,
                    barHeight: r,
                    x1: s,
                    x2: l = null === this.series[x][v] ? s : s + this.series[x][v] / this.invertedYRatio - 2 * (this.isReversed ? this.series[x][v] / this.invertedYRatio : 0),
                    strokeWidth: n,
                    series: this.series,
                    realIndex: a.realIndex,
                    i: x,
                    j: v,
                    w: p
                });
                return this.barHelpers.barBackground({
                    j: v,
                    i: x,
                    y1: m,
                    y2: r,
                    elSeries: g
                }),
                {
                    pathTo: h.pathTo,
                    pathFrom: h.pathFrom,
                    x: l,
                    y: c += d
                }
            }
        }, {
            key: "drawStackedColumnPaths",
            value: function(i) {
                var r, s = i.indexes, a = i.x, n = i.xDivision, o = i.barWidth, l = i.zeroH, c = i.elSeries, d = this.w, g = s.i, p = s.j, m = s.bc;
                if (d.globals.isXNumeric) {
                    var x = d.globals.seriesX[g][p];
                    x || (x = 0),
                    a = (x - d.globals.minX) / this.xRatio - o / 2
                }
                for (var v, k = a, S = 0, C = 0; C < this.prevYF.length; C++)
                    S += isNaN(this.prevYF[C][p]) ? 0 : this.prevYF[C][p];
                if (g > 0 && !d.globals.isXNumeric || g > 0 && d.globals.isXNumeric && d.globals.seriesX[g - 1][p] === d.globals.seriesX[g][p]) {
                    var h, u, b = Math.min(this.yRatio.length + 1, g + 1);
                    if (void 0 !== this.prevY[g - 1])
                        for (var w = 1; w < b; w++)
                            if (!isNaN(this.prevY[g - w][p])) {
                                u = this.prevY[g - w][p];
                                break
                            }
                    for (var _ = 1; _ < b; _++) {
                        if (this.prevYVal[g - _][p] < 0) {
                            h = this.series[g][p] >= 0 ? u - S + 2 * (this.isReversed ? S : 0) : u;
                            break
                        }
                        if (this.prevYVal[g - _][p] >= 0) {
                            h = this.series[g][p] >= 0 ? u : u + S - 2 * (this.isReversed ? S : 0);
                            break
                        }
                    }
                    void 0 === h && (h = d.globals.gridHeight),
                    v = this.prevYF[0].every(function(I) {
                        return 0 === I
                    }) && this.prevYF.slice(1, g).every(function(I) {
                        return I.every(function(R) {
                            return isNaN(R)
                        })
                    }) ? d.globals.gridHeight - l : h
                } else
                    v = d.globals.gridHeight - l;
                var X = this.barHelpers.getColumnPaths({
                    barXPosition: k,
                    barWidth: o,
                    y1: v,
                    y2: r = v - this.series[g][p] / this.yRatio[this.yaxisIndex] + 2 * (this.isReversed ? this.series[g][p] / this.yRatio[this.yaxisIndex] : 0),
                    yRatio: this.yRatio[this.yaxisIndex],
                    strokeWidth: this.strokeWidth,
                    series: this.series,
                    realIndex: s.realIndex,
                    i: g,
                    j: p,
                    w: d
                });
                return this.barHelpers.barBackground({
                    bc: m,
                    j: p,
                    i: g,
                    x1: k,
                    x2: o,
                    elSeries: c
                }),
                a += n,
                {
                    pathTo: X.pathTo,
                    pathFrom: X.pathFrom,
                    x: d.globals.isXNumeric ? a - n : a,
                    y: r
                }
            }
        }]),
        t
    }(Je)
      , Nt = function(y) {
        Fe(t, y);
        var e = Te(t);
        function t() {
            return W(this, t),
            e.apply(this, arguments)
        }
        return V(t, [{
            key: "draw",
            value: function(i, s) {
                var a = this
                  , r = this.w
                  , n = new D(this.ctx)
                  , o = new ue(this.ctx);
                this.candlestickOptions = this.w.config.plotOptions.candlestick,
                this.boxOptions = this.w.config.plotOptions.boxPlot,
                this.isHorizontal = r.config.plotOptions.bar.horizontal;
                var l = new xe(this.ctx,r);
                i = l.getLogSeries(i),
                this.series = i,
                this.yRatio = l.getLogYRatios(this.yRatio),
                this.barHelpers.initVariables(i);
                for (var c = n.group({
                    class: "apexcharts-".concat(r.config.chart.type, "-series apexcharts-plot-series")
                }), d = function(p) {
                    a.isBoxPlot = "boxPlot" === r.config.chart.type || "boxPlot" === r.config.series[p].type;
                    var m, x, v, k, _, X, S = void 0, C = void 0, h = [], u = [], b = r.globals.comboCharts ? s[p] : p, w = n.group({
                        class: "apexcharts-series",
                        seriesName: M.escapeString(r.globals.seriesNames[b]),
                        rel: p + 1,
                        "data:realIndex": b
                    });
                    a.ctx.series.addCollapsedClassToSeries(w, b),
                    i[p].length > 0 && (a.visibleI = a.visibleI + 1),
                    a.yRatio.length > 1 && (a.yaxisIndex = b);
                    var I = a.barHelpers.initialPositions();
                    C = I.y,
                    _ = I.barHeight,
                    x = I.yDivision,
                    k = I.zeroW,
                    m = I.xDivision,
                    v = I.zeroH,
                    u.push((S = I.x) + (X = I.barWidth) / 2);
                    for (var R = n.group({
                        class: "apexcharts-datalabels",
                        "data:realIndex": b
                    }), H = function(ie) {
                        var ne = a.barHelpers.getStrokeWidth(p, ie, b)
                          , oe = null
                          , ye = {
                            indexes: {
                                i: p,
                                j: ie,
                                realIndex: b
                            },
                            x: S,
                            y: C,
                            strokeWidth: ne,
                            elSeries: w
                        };
                        oe = a.isHorizontal ? a.drawHorizontalBoxPaths(Z(Z({}, ye), {}, {
                            yDivision: x,
                            barHeight: _,
                            zeroW: k
                        })) : a.drawVerticalBoxPaths(Z(Z({}, ye), {}, {
                            xDivision: m,
                            barWidth: X,
                            zeroH: v
                        })),
                        C = oe.y,
                        S = oe.x,
                        ie > 0 && u.push(S + X / 2),
                        h.push(C),
                        oe.pathTo.forEach(function(Le, De) {
                            var qe = !a.isBoxPlot && a.candlestickOptions.wick.useFillColor ? oe.color[De] : r.globals.stroke.colors[p]
                              , et = o.fillPath({
                                seriesNumber: b,
                                dataPointIndex: ie,
                                color: oe.color[De],
                                value: i[p][ie]
                            });
                            a.renderSeries({
                                realIndex: b,
                                pathFill: et,
                                lineFill: qe,
                                j: ie,
                                i: p,
                                pathFrom: oe.pathFrom,
                                pathTo: Le,
                                strokeWidth: ne,
                                elSeries: w,
                                x: S,
                                y: C,
                                series: i,
                                barHeight: _,
                                barWidth: X,
                                elDataLabelsWrap: R,
                                visibleSeries: a.visibleI,
                                type: r.config.chart.type
                            })
                        })
                    }, G = 0; G < r.globals.dataPoints; G++)
                        H(G);
                    r.globals.seriesXvalues[b] = u,
                    r.globals.seriesYvalues[b] = h,
                    c.add(w)
                }, g = 0; g < i.length; g++)
                    d(g);
                return c
            }
        }, {
            key: "drawVerticalBoxPaths",
            value: function(i) {
                var s = i.indexes
                  , a = i.x
                  , r = i.xDivision
                  , n = i.barWidth
                  , o = i.zeroH
                  , l = i.strokeWidth
                  , c = this.w
                  , d = new D(this.ctx)
                  , g = s.i
                  , p = s.j
                  , m = !0
                  , x = c.config.plotOptions.candlestick.colors.upward
                  , v = c.config.plotOptions.candlestick.colors.downward
                  , k = "";
                this.isBoxPlot && (k = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
                var S = this.yRatio[this.yaxisIndex]
                  , C = s.realIndex
                  , h = this.getOHLCValue(C, p)
                  , u = o
                  , b = o;
                h.o > h.c && (m = !1);
                var w = Math.min(h.o, h.c)
                  , _ = Math.max(h.o, h.c)
                  , X = h.m;
                c.globals.isXNumeric && (a = (c.globals.seriesX[C][p] - c.globals.minX) / this.xRatio - n / 2);
                var I = a + n * this.visibleI;
                null == this.series[g][p] ? (w = o,
                _ = o) : (w = o - w / S,
                _ = o - _ / S,
                u = o - h.h / S,
                b = o - h.l / S,
                X = o - h.m / S);
                var R = d.move(I, o)
                  , H = d.move(I + n / 2, w);
                return c.globals.previousPaths.length > 0 && (H = this.getPreviousPath(C, p, !0)),
                R = this.isBoxPlot ? [d.move(I, w) + d.line(I + n / 2, w) + d.line(I + n / 2, u) + d.line(I + n / 4, u) + d.line(I + n - n / 4, u) + d.line(I + n / 2, u) + d.line(I + n / 2, w) + d.line(I + n, w) + d.line(I + n, X) + d.line(I, X) + d.line(I, w + l / 2), d.move(I, X) + d.line(I + n, X) + d.line(I + n, _) + d.line(I + n / 2, _) + d.line(I + n / 2, b) + d.line(I + n - n / 4, b) + d.line(I + n / 4, b) + d.line(I + n / 2, b) + d.line(I + n / 2, _) + d.line(I, _) + d.line(I, X) + "z"] : [d.move(I, _) + d.line(I + n / 2, _) + d.line(I + n / 2, u) + d.line(I + n / 2, _) + d.line(I + n, _) + d.line(I + n, w) + d.line(I + n / 2, w) + d.line(I + n / 2, b) + d.line(I + n / 2, w) + d.line(I, w) + d.line(I, _ - l / 2)],
                H += d.move(I, w),
                c.globals.isXNumeric || (a += r),
                {
                    pathTo: R,
                    pathFrom: H,
                    x: a,
                    y: _,
                    barXPosition: I,
                    color: this.isBoxPlot ? k : m ? [x] : [v]
                }
            }
        }, {
            key: "drawHorizontalBoxPaths",
            value: function(i) {
                var s = i.indexes
                  , a = i.y
                  , r = i.yDivision
                  , n = i.barHeight
                  , o = i.zeroW
                  , l = i.strokeWidth
                  , c = this.w
                  , d = new D(this.ctx)
                  , g = s.i
                  , p = s.j
                  , m = this.boxOptions.colors.lower;
                this.isBoxPlot && (m = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
                var x = this.invertedYRatio
                  , v = s.realIndex
                  , k = this.getOHLCValue(v, p)
                  , S = o
                  , C = o
                  , h = Math.min(k.o, k.c)
                  , u = Math.max(k.o, k.c)
                  , b = k.m;
                c.globals.isXNumeric && (a = (c.globals.seriesX[v][p] - c.globals.minX) / this.invertedXRatio - n / 2);
                var w = a + n * this.visibleI;
                null == this.series[g][p] ? (h = o,
                u = o) : (h = o + h / x,
                u = o + u / x,
                S = o + k.h / x,
                C = o + k.l / x,
                b = o + k.m / x);
                var _ = d.move(o, w)
                  , X = d.move(h, w + n / 2);
                return c.globals.previousPaths.length > 0 && (X = this.getPreviousPath(v, p, !0)),
                _ = [d.move(h, w) + d.line(h, w + n / 2) + d.line(S, w + n / 2) + d.line(S, w + n / 2 - n / 4) + d.line(S, w + n / 2 + n / 4) + d.line(S, w + n / 2) + d.line(h, w + n / 2) + d.line(h, w + n) + d.line(b, w + n) + d.line(b, w) + d.line(h + l / 2, w), d.move(b, w) + d.line(b, w + n) + d.line(u, w + n) + d.line(u, w + n / 2) + d.line(C, w + n / 2) + d.line(C, w + n - n / 4) + d.line(C, w + n / 4) + d.line(C, w + n / 2) + d.line(u, w + n / 2) + d.line(u, w) + d.line(b, w) + "z"],
                X += d.move(h, w),
                c.globals.isXNumeric || (a += r),
                {
                    pathTo: _,
                    pathFrom: X,
                    x: u,
                    y: a,
                    barYPosition: w,
                    color: m
                }
            }
        }, {
            key: "getOHLCValue",
            value: function(i, s) {
                var a = this.w;
                return {
                    o: this.isBoxPlot ? a.globals.seriesCandleH[i][s] : a.globals.seriesCandleO[i][s],
                    h: this.isBoxPlot ? a.globals.seriesCandleO[i][s] : a.globals.seriesCandleH[i][s],
                    m: a.globals.seriesCandleM[i][s],
                    l: this.isBoxPlot ? a.globals.seriesCandleC[i][s] : a.globals.seriesCandleL[i][s],
                    c: this.isBoxPlot ? a.globals.seriesCandleL[i][s] : a.globals.seriesCandleC[i][s]
                }
            }
        }]),
        t
    }(Je)
      , Ht = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w
        }
        return V(y, [{
            key: "checkColorRange",
            value: function() {
                var e = this.w
                  , t = !1
                  , i = e.config.plotOptions[e.config.chart.type];
                return i.colorScale.ranges.length > 0 && i.colorScale.ranges.map(function(s, a) {
                    s.from <= 0 && (t = !0)
                }),
                t
            }
        }, {
            key: "getShadeColor",
            value: function(e, t, i, s) {
                var a = this.w
                  , r = 1
                  , n = a.config.plotOptions[e].shadeIntensity
                  , o = this.determineColor(e, t, i);
                a.globals.hasNegs || s ? r = a.config.plotOptions[e].reverseNegativeShade ? o.percent < 0 ? o.percent / 100 * (1.25 * n) : 1.25 * n * (1 - o.percent / 100) : o.percent <= 0 ? 1 - (1 + o.percent / 100) * n : (1 - o.percent / 100) * n : (r = 1 - o.percent / 100,
                "treemap" === e && (r = 1.25 * n * (1 - o.percent / 100)));
                var l = o.color
                  , c = new M;
                return a.config.plotOptions[e].enableShades && (l = M.hexToRgba(c.shadeColor("dark" === this.w.config.theme.mode ? -1 * r : r, o.color), a.config.fill.opacity)),
                {
                    color: l,
                    colorProps: o
                }
            }
        }, {
            key: "determineColor",
            value: function(e, t, i) {
                var s = this.w
                  , a = s.globals.series[t][i]
                  , r = s.config.plotOptions[e]
                  , n = r.colorScale.inverse ? i : t;
                r.distributed && "treemap" === s.config.chart.type && (n = i);
                var o = s.globals.colors[n]
                  , l = null
                  , c = Math.min.apply(Math, pe(s.globals.series[t]))
                  , d = Math.max.apply(Math, pe(s.globals.series[t]));
                r.distributed || "heatmap" !== e || (c = s.globals.minY,
                d = s.globals.maxY),
                void 0 !== r.colorScale.min && (c = r.colorScale.min < s.globals.minY ? r.colorScale.min : s.globals.minY,
                d = r.colorScale.max > s.globals.maxY ? r.colorScale.max : s.globals.maxY);
                var g = Math.abs(d) + Math.abs(c)
                  , p = 100 * a / (0 === g ? g - 1e-6 : g);
                return r.colorScale.ranges.length > 0 && r.colorScale.ranges.map(function(m, x) {
                    if (a >= m.from && a <= m.to) {
                        o = m.color,
                        l = m.foreColor ? m.foreColor : null,
                        c = m.from,
                        d = m.to;
                        var v = Math.abs(d) + Math.abs(c);
                        p = 100 * a / (0 === v ? v - 1e-6 : v)
                    }
                }),
                {
                    color: o,
                    foreColor: l,
                    percent: p
                }
            }
        }, {
            key: "calculateDataLabels",
            value: function(e) {
                var t = e.text
                  , i = e.x
                  , s = e.y
                  , a = e.i
                  , r = e.j
                  , n = e.colorProps
                  , o = e.fontSize
                  , l = this.w.config.dataLabels
                  , c = new D(this.ctx)
                  , d = new Ge(this.ctx)
                  , g = null;
                if (l.enabled) {
                    g = c.group({
                        class: "apexcharts-data-labels"
                    });
                    var m = l.offsetY
                      , x = i + l.offsetX
                      , v = s + parseFloat(l.style.fontSize) / 3 + m;
                    d.plotDataLabelsText({
                        x,
                        y: v,
                        text: t,
                        i: a,
                        j: r,
                        color: n.foreColor,
                        parent: g,
                        fontSize: o,
                        dataLabelsConfig: l
                    })
                }
                return g
            }
        }, {
            key: "addListeners",
            value: function(e) {
                var t = new D(this.ctx);
                e.node.addEventListener("mouseenter", t.pathMouseEnter.bind(this, e)),
                e.node.addEventListener("mouseleave", t.pathMouseLeave.bind(this, e)),
                e.node.addEventListener("mousedown", t.pathMouseDown.bind(this, e))
            }
        }]),
        y
    }()
      , ii = function() {
        function y(e, t) {
            W(this, y),
            this.ctx = e,
            this.w = e.w,
            this.xRatio = t.xRatio,
            this.yRatio = t.yRatio,
            this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation,
            this.helpers = new Ht(e),
            this.rectRadius = this.w.config.plotOptions.heatmap.radius,
            this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0
        }
        return V(y, [{
            key: "draw",
            value: function(e) {
                var t = this.w
                  , i = new D(this.ctx)
                  , s = i.group({
                    class: "apexcharts-heatmap"
                });
                s.attr("clip-path", "url(#gridRectMask".concat(t.globals.cuid, ")"));
                var a = t.globals.gridWidth / t.globals.dataPoints
                  , r = t.globals.gridHeight / t.globals.series.length
                  , n = 0
                  , o = !1;
                this.negRange = this.helpers.checkColorRange();
                var l = e.slice();
                t.config.yaxis[0].reversed && (o = !0,
                l.reverse());
                for (var c = o ? 0 : l.length - 1; o ? c < l.length : c >= 0; o ? c++ : c--) {
                    var d = i.group({
                        class: "apexcharts-series apexcharts-heatmap-series",
                        seriesName: M.escapeString(t.globals.seriesNames[c]),
                        rel: c + 1,
                        "data:realIndex": c
                    });
                    if (this.ctx.series.addCollapsedClassToSeries(d, c),
                    t.config.chart.dropShadow.enabled) {
                        var g = t.config.chart.dropShadow;
                        new me(this.ctx).dropShadow(d, g, c)
                    }
                    for (var p = 0, m = t.config.plotOptions.heatmap.shadeIntensity, x = 0; x < l[c].length; x++) {
                        var v = this.helpers.getShadeColor(t.config.chart.type, c, x, this.negRange)
                          , k = v.color
                          , S = v.colorProps;
                        "image" === t.config.fill.type && (k = new ue(this.ctx).fillPath({
                            seriesNumber: c,
                            dataPointIndex: x,
                            opacity: t.globals.hasNegs ? S.percent < 0 ? 1 - (1 + S.percent / 100) : m + S.percent / 100 : S.percent / 100,
                            patternID: M.randomId(),
                            width: t.config.fill.image.width ? t.config.fill.image.width : a,
                            height: t.config.fill.image.height ? t.config.fill.image.height : r
                        }));
                        var h = i.drawRect(p, n, a, r, this.rectRadius);
                        if (h.attr({
                            cx: p,
                            cy: n
                        }),
                        h.node.classList.add("apexcharts-heatmap-rect"),
                        d.add(h),
                        h.attr({
                            fill: k,
                            i: c,
                            index: c,
                            j: x,
                            val: l[c][x],
                            "stroke-width": this.strokeWidth,
                            stroke: t.config.plotOptions.heatmap.useFillColorAsStroke ? k : t.globals.stroke.colors[0],
                            color: k
                        }),
                        this.helpers.addListeners(h),
                        t.config.chart.animations.enabled && !t.globals.dataChanged) {
                            var u = 1;
                            t.globals.resized || (u = t.config.chart.animations.speed),
                            this.animateHeatMap(h, p, n, a, r, u)
                        }
                        if (t.globals.dataChanged) {
                            var b = 1;
                            if (this.dynamicAnim.enabled && t.globals.shouldAnimate) {
                                b = this.dynamicAnim.speed;
                                var w = t.globals.previousPaths[c] && t.globals.previousPaths[c][x] && t.globals.previousPaths[c][x].color;
                                w || (w = "rgba(255, 255, 255, 0)"),
                                this.animateHeatColor(h, M.isColorHex(w) ? w : M.rgb2hex(w), M.isColorHex(k) ? k : M.rgb2hex(k), b)
                            }
                        }
                        var _ = (0,
                        t.config.dataLabels.formatter)(t.globals.series[c][x], {
                            value: t.globals.series[c][x],
                            seriesIndex: c,
                            dataPointIndex: x,
                            w: t
                        })
                          , X = this.helpers.calculateDataLabels({
                            text: _,
                            x: p + a / 2,
                            y: n + r / 2,
                            i: c,
                            j: x,
                            colorProps: S,
                            series: l
                        });
                        null !== X && d.add(X),
                        p += a
                    }
                    n += r,
                    s.add(d)
                }
                var I = t.globals.yAxisScale[0].result.slice();
                return t.config.yaxis[0].reversed ? I.unshift("") : I.push(""),
                t.globals.yAxisScale[0].result = I,
                t.config.yaxis[0].labels.offsetY = -t.globals.gridHeight / t.globals.series.length / 2,
                s
            }
        }, {
            key: "animateHeatMap",
            value: function(e, t, i, s, a, r) {
                var n = new Ce(this.ctx);
                n.animateRect(e, {
                    x: t + s / 2,
                    y: i + a / 2,
                    width: 0,
                    height: 0
                }, {
                    x: t,
                    y: i,
                    width: s,
                    height: a
                }, r, function() {
                    n.animationCompleted(e)
                })
            }
        }, {
            key: "animateHeatColor",
            value: function(e, t, i, s) {
                e.attr({
                    fill: t
                }).animate(s).attr({
                    fill: i
                })
            }
        }]),
        y
    }()
      , E = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w
        }
        return V(y, [{
            key: "drawYAxisTexts",
            value: function(e, t, i, s) {
                var a = this.w
                  , r = a.config.yaxis[0]
                  , n = a.globals.yLabelFormatters[0];
                return new D(this.ctx).drawText({
                    x: e + r.labels.offsetX,
                    y: t + r.labels.offsetY,
                    text: n(s, i),
                    textAnchor: "middle",
                    fontSize: r.labels.style.fontSize,
                    fontFamily: r.labels.style.fontFamily,
                    foreColor: Array.isArray(r.labels.style.colors) ? r.labels.style.colors[i] : r.labels.style.colors
                })
            }
        }]),
        y
    }()
      , T = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w;
            var t = this.w;
            this.chartType = this.w.config.chart.type,
            this.initialAnim = this.w.config.chart.animations.enabled,
            this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled,
            this.animBeginArr = [0],
            this.animDur = 0,
            this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels,
            this.lineColorArr = void 0 !== t.globals.stroke.colors ? t.globals.stroke.colors : t.globals.colors,
            this.defaultSize = Math.min(t.globals.gridWidth, t.globals.gridHeight),
            this.centerY = this.defaultSize / 2,
            this.centerX = t.globals.gridWidth / 2,
            this.fullAngle = "radialBar" === t.config.chart.type ? 360 : Math.abs(t.config.plotOptions.pie.endAngle - t.config.plotOptions.pie.startAngle),
            this.initialAngle = t.config.plotOptions.pie.startAngle % this.fullAngle,
            t.globals.radialSize = this.defaultSize / 2.05 - t.config.stroke.width - (t.config.chart.sparkline.enabled ? 0 : t.config.chart.dropShadow.blur),
            this.donutSize = t.globals.radialSize * parseInt(t.config.plotOptions.pie.donut.size, 10) / 100,
            this.maxY = 0,
            this.sliceLabels = [],
            this.sliceSizes = [],
            this.prevSectorAngleArr = []
        }
        return V(y, [{
            key: "draw",
            value: function(e) {
                var t = this
                  , i = this.w
                  , s = new D(this.ctx);
                if (this.ret = s.group({
                    class: "apexcharts-pie"
                }),
                i.globals.noData)
                    return this.ret;
                for (var a = 0, r = 0; r < e.length; r++)
                    a += M.negToZero(e[r]);
                var n = []
                  , o = s.group();
                0 === a && (a = 1e-5),
                e.forEach(function(w) {
                    t.maxY = Math.max(t.maxY, w)
                }),
                i.config.yaxis[0].max && (this.maxY = i.config.yaxis[0].max),
                "back" === i.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(this.ret);
                for (var l = 0; l < e.length; l++) {
                    var c = this.fullAngle * M.negToZero(e[l]) / a;
                    n.push(c),
                    "polarArea" === this.chartType ? (n[l] = this.fullAngle / e.length,
                    this.sliceSizes.push(i.globals.radialSize * e[l] / this.maxY)) : this.sliceSizes.push(i.globals.radialSize)
                }
                if (i.globals.dataChanged) {
                    for (var d, g = 0, p = 0; p < i.globals.previousPaths.length; p++)
                        g += M.negToZero(i.globals.previousPaths[p]);
                    for (var m = 0; m < i.globals.previousPaths.length; m++)
                        d = this.fullAngle * M.negToZero(i.globals.previousPaths[m]) / g,
                        this.prevSectorAngleArr.push(d)
                }
                this.donutSize < 0 && (this.donutSize = 0);
                var x = i.config.plotOptions.pie.customScale
                  , S = i.globals.gridWidth / 2 - i.globals.gridWidth / 2 * x
                  , C = i.globals.gridHeight / 2 - i.globals.gridHeight / 2 * x;
                if ("donut" === this.chartType) {
                    var h = s.drawCircle(this.donutSize);
                    h.attr({
                        cx: this.centerX,
                        cy: this.centerY,
                        fill: i.config.plotOptions.pie.donut.background ? i.config.plotOptions.pie.donut.background : "transparent"
                    }),
                    o.add(h)
                }
                var u = this.drawArcs(n, e);
                if (this.sliceLabels.forEach(function(w) {
                    u.add(w)
                }),
                o.attr({
                    transform: "translate(".concat(S, ", ").concat(C, ") scale(").concat(x, ")")
                }),
                o.add(u),
                this.ret.add(o),
                this.donutDataLabels.show) {
                    var b = this.renderInnerDataLabels(this.donutDataLabels, {
                        hollowSize: this.donutSize,
                        centerX: this.centerX,
                        centerY: this.centerY,
                        opacity: this.donutDataLabels.show,
                        translateX: S,
                        translateY: C
                    });
                    this.ret.add(b)
                }
                return "front" === i.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(this.ret),
                this.ret
            }
        }, {
            key: "drawArcs",
            value: function(e, t) {
                var i = this.w
                  , s = new me(this.ctx)
                  , a = new D(this.ctx)
                  , r = new ue(this.ctx)
                  , n = a.group({
                    class: "apexcharts-slices"
                })
                  , o = this.initialAngle
                  , l = this.initialAngle
                  , c = this.initialAngle
                  , d = this.initialAngle;
                this.strokeWidth = i.config.stroke.show ? i.config.stroke.width : 0;
                for (var g = 0; g < e.length; g++) {
                    var p = a.group({
                        class: "apexcharts-series apexcharts-pie-series",
                        seriesName: M.escapeString(i.globals.seriesNames[g]),
                        rel: g + 1,
                        "data:realIndex": g
                    });
                    n.add(p),
                    c = (o = c) + e[g],
                    d = (l = d) + this.prevSectorAngleArr[g];
                    var m = c < o ? this.fullAngle + c - o : c - o
                      , x = r.fillPath({
                        seriesNumber: g,
                        size: this.sliceSizes[g],
                        value: t[g]
                    })
                      , v = this.getChangedPath(l, d)
                      , k = a.drawPath({
                        d: v,
                        stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[g] : this.lineColorArr,
                        strokeWidth: 0,
                        fill: x,
                        fillOpacity: i.config.fill.opacity,
                        classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(g)
                    });
                    k.attr({
                        index: 0,
                        j: g
                    }),
                    s.setSelectionFilter(k, 0, g),
                    i.config.chart.dropShadow.enabled && s.dropShadow(k, i.config.chart.dropShadow, g),
                    this.addListeners(k, this.donutDataLabels),
                    D.setAttrs(k.node, {
                        "data:angle": m,
                        "data:startAngle": o,
                        "data:strokeWidth": this.strokeWidth,
                        "data:value": t[g]
                    });
                    var C = {
                        x: 0,
                        y: 0
                    };
                    "pie" === this.chartType || "polarArea" === this.chartType ? C = M.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize / 1.25 + i.config.plotOptions.pie.dataLabels.offset, (o + m / 2) % this.fullAngle) : "donut" === this.chartType && (C = M.polarToCartesian(this.centerX, this.centerY, (i.globals.radialSize + this.donutSize) / 2 + i.config.plotOptions.pie.dataLabels.offset, (o + m / 2) % this.fullAngle)),
                    p.add(k);
                    var h = 0;
                    if (!this.initialAnim || i.globals.resized || i.globals.dataChanged ? this.animBeginArr.push(0) : (0 == (h = m / this.fullAngle * i.config.chart.animations.speed) && (h = 1),
                    this.animDur = h + this.animDur,
                    this.animBeginArr.push(this.animDur)),
                    this.animatePaths(k, this.dynamicAnim && i.globals.dataChanged ? {
                        size: this.sliceSizes[g],
                        endAngle: c,
                        startAngle: o,
                        prevStartAngle: l,
                        prevEndAngle: d,
                        animateStartingPos: !0,
                        i: g,
                        animBeginArr: this.animBeginArr,
                        shouldSetPrevPaths: !0,
                        dur: i.config.chart.animations.dynamicAnimation.speed
                    } : {
                        size: this.sliceSizes[g],
                        endAngle: c,
                        startAngle: o,
                        i: g,
                        totalItems: e.length - 1,
                        animBeginArr: this.animBeginArr,
                        dur: h
                    }),
                    i.config.plotOptions.pie.expandOnClick && "polarArea" !== this.chartType && k.click(this.pieClicked.bind(this, g)),
                    void 0 !== i.globals.selectedDataPoints[0] && i.globals.selectedDataPoints[0].indexOf(g) > -1 && this.pieClicked(g),
                    i.config.dataLabels.enabled) {
                        var u = C.x
                          , b = C.y
                          , w = 100 * m / this.fullAngle + "%";
                        if (0 !== m && i.config.plotOptions.pie.dataLabels.minAngleToShowLabel < e[g]) {
                            var _ = i.config.dataLabels.formatter;
                            void 0 !== _ && (w = _(i.globals.seriesPercent[g][0], {
                                seriesIndex: g,
                                w: i
                            }));
                            var X = i.globals.dataLabels.style.colors[g]
                              , I = a.group({
                                class: "apexcharts-datalabels"
                            })
                              , R = a.drawText({
                                x: u,
                                y: b,
                                text: w,
                                textAnchor: "middle",
                                fontSize: i.config.dataLabels.style.fontSize,
                                fontFamily: i.config.dataLabels.style.fontFamily,
                                fontWeight: i.config.dataLabels.style.fontWeight,
                                foreColor: X
                            });
                            I.add(R),
                            i.config.dataLabels.dropShadow.enabled && s.dropShadow(R, i.config.dataLabels.dropShadow),
                            R.node.classList.add("apexcharts-pie-label"),
                            i.config.chart.animations.animate && !1 === i.globals.resized && (R.node.classList.add("apexcharts-pie-label-delay"),
                            R.node.style.animationDelay = i.config.chart.animations.speed / 940 + "s"),
                            this.sliceLabels.push(I)
                        }
                    }
                }
                return n
            }
        }, {
            key: "addListeners",
            value: function(e, t) {
                var i = new D(this.ctx);
                e.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this, e)),
                e.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this, e)),
                e.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, e.node, t)),
                e.node.addEventListener("mousedown", i.pathMouseDown.bind(this, e)),
                this.donutDataLabels.total.showAlways || (e.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, e.node, t)),
                e.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, e.node, t)))
            }
        }, {
            key: "animatePaths",
            value: function(e, t) {
                var s = t.endAngle < t.startAngle ? this.fullAngle + t.endAngle - t.startAngle : t.endAngle - t.startAngle
                  , a = s
                  , r = t.startAngle
                  , n = t.startAngle;
                void 0 !== t.prevStartAngle && void 0 !== t.prevEndAngle && (r = t.prevEndAngle,
                a = t.prevEndAngle < t.prevStartAngle ? this.fullAngle + t.prevEndAngle - t.prevStartAngle : t.prevEndAngle - t.prevStartAngle),
                t.i === this.w.config.series.length - 1 && (s + n > this.fullAngle ? t.endAngle = t.endAngle - (s + n) : s + n < this.fullAngle && (t.endAngle = t.endAngle + (this.fullAngle - (s + n)))),
                s === this.fullAngle && (s = this.fullAngle - .01),
                this.animateArc(e, r, n, s, a, t)
            }
        }, {
            key: "animateArc",
            value: function(e, t, i, s, a, r) {
                var n, o = this, l = this.w, c = new Ce(this.ctx), d = r.size;
                (isNaN(t) || isNaN(a)) && (t = i,
                a = s,
                r.dur = 0);
                var g = s
                  , p = i
                  , m = t < i ? this.fullAngle + t - i : t - i;
                l.globals.dataChanged && r.shouldSetPrevPaths && r.prevEndAngle && (n = o.getPiePath({
                    me: o,
                    startAngle: r.prevStartAngle,
                    angle: r.prevEndAngle < r.prevStartAngle ? this.fullAngle + r.prevEndAngle - r.prevStartAngle : r.prevEndAngle - r.prevStartAngle,
                    size: d
                }),
                e.attr({
                    d: n
                })),
                0 !== r.dur ? e.animate(r.dur, l.globals.easing, r.animBeginArr[r.i]).afterAll(function() {
                    "pie" !== o.chartType && "donut" !== o.chartType && "polarArea" !== o.chartType || this.animate(l.config.chart.animations.dynamicAnimation.speed).attr({
                        "stroke-width": o.strokeWidth
                    }),
                    r.i === l.config.series.length - 1 && c.animationCompleted(e)
                }).during(function(x) {
                    g = m + (s - m) * x,
                    r.animateStartingPos && (g = a + (s - a) * x,
                    p = t - a + (i - (t - a)) * x),
                    n = o.getPiePath({
                        me: o,
                        startAngle: p,
                        angle: g,
                        size: d
                    }),
                    e.node.setAttribute("data:pathOrig", n),
                    e.attr({
                        d: n
                    })
                }) : (n = o.getPiePath({
                    me: o,
                    startAngle: p,
                    angle: s,
                    size: d
                }),
                r.isTrack || (l.globals.animationEnded = !0),
                e.node.setAttribute("data:pathOrig", n),
                e.attr({
                    d: n,
                    "stroke-width": o.strokeWidth
                }))
            }
        }, {
            key: "pieClicked",
            value: function(e) {
                var t, i = this.w, s = this, a = s.sliceSizes[e] + (i.config.plotOptions.pie.expandOnClick ? 4 : 0), r = i.globals.dom.Paper.select(".apexcharts-".concat(s.chartType.toLowerCase(), "-slice-").concat(e)).members[0];
                if ("true" !== r.attr("data:pieClicked")) {
                    var n = i.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");
                    Array.prototype.forEach.call(n, function(d) {
                        d.setAttribute("data:pieClicked", "false");
                        var g = d.getAttribute("data:pathOrig");
                        d.setAttribute("d", g)
                    }),
                    r.attr("data:pieClicked", "true");
                    var o = parseInt(r.attr("data:startAngle"), 10)
                      , l = parseInt(r.attr("data:angle"), 10);
                    t = s.getPiePath({
                        me: s,
                        startAngle: o,
                        angle: l,
                        size: a
                    }),
                    360 !== l && r.plot(t)
                } else {
                    r.attr({
                        "data:pieClicked": "false"
                    }),
                    this.revertDataLabelsInner(r.node, this.donutDataLabels);
                    var c = r.attr("data:pathOrig");
                    r.attr({
                        d: c
                    })
                }
            }
        }, {
            key: "getChangedPath",
            value: function(e, t) {
                var i = "";
                return this.dynamicAnim && this.w.globals.dataChanged && (i = this.getPiePath({
                    me: this,
                    startAngle: e,
                    angle: t - e,
                    size: this.size
                })),
                i
            }
        }, {
            key: "getPiePath",
            value: function(e) {
                var t = e.me
                  , i = e.startAngle
                  , s = e.angle
                  , a = e.size
                  , r = i
                  , n = Math.PI * (r - 90) / 180
                  , o = s + i;
                Math.ceil(o) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (o = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - .01),
                Math.ceil(o) > this.fullAngle && (o -= this.fullAngle);
                var l = Math.PI * (o - 90) / 180
                  , c = t.centerX + a * Math.cos(n)
                  , d = t.centerY + a * Math.sin(n)
                  , g = t.centerX + a * Math.cos(l)
                  , p = t.centerY + a * Math.sin(l)
                  , m = M.polarToCartesian(t.centerX, t.centerY, t.donutSize, o)
                  , x = M.polarToCartesian(t.centerX, t.centerY, t.donutSize, r)
                  , v = s > 180 ? 1 : 0
                  , k = ["M", c, d, "A", a, a, 0, v, 1, g, p];
                return "donut" === t.chartType ? [].concat(k, ["L", m.x, m.y, "A", t.donutSize, t.donutSize, 0, v, 0, x.x, x.y, "L", c, d, "z"]).join(" ") : "pie" === t.chartType || "polarArea" === t.chartType ? [].concat(k, ["L", t.centerX, t.centerY, "L", c, d]).join(" ") : [].concat(k).join(" ")
            }
        }, {
            key: "drawPolarElements",
            value: function(e) {
                var t = this.w
                  , i = new Be(this.ctx)
                  , s = new D(this.ctx)
                  , a = new E(this.ctx)
                  , r = s.group()
                  , n = s.group()
                  , o = i.niceScale(0, Math.ceil(this.maxY), t.config.yaxis[0].tickAmount, 0, !0)
                  , l = o.result.reverse()
                  , c = o.result.length;
                this.maxY = o.niceMax;
                for (var d = t.globals.radialSize, g = d / (c - 1), p = 0; p < c - 1; p++) {
                    var m = s.drawCircle(d);
                    if (m.attr({
                        cx: this.centerX,
                        cy: this.centerY,
                        fill: "none",
                        "stroke-width": t.config.plotOptions.polarArea.rings.strokeWidth,
                        stroke: t.config.plotOptions.polarArea.rings.strokeColor
                    }),
                    t.config.yaxis[0].show) {
                        var x = a.drawYAxisTexts(this.centerX, this.centerY - d + parseInt(t.config.yaxis[0].labels.style.fontSize, 10) / 2, p, l[p]);
                        n.add(x)
                    }
                    r.add(m),
                    d -= g
                }
                this.drawSpokes(e),
                e.add(r),
                e.add(n)
            }
        }, {
            key: "renderInnerDataLabels",
            value: function(e, t) {
                var i = this.w
                  , s = new D(this.ctx)
                  , a = s.group({
                    class: "apexcharts-datalabels-group",
                    transform: "translate(".concat(t.translateX ? t.translateX : 0, ", ").concat(t.translateY ? t.translateY : 0, ") scale(").concat(i.config.plotOptions.pie.customScale, ")")
                })
                  , r = e.total.show;
                a.node.style.opacity = t.opacity;
                var n, o, l = t.centerX, c = t.centerY;
                n = void 0 === e.name.color ? i.globals.colors[0] : e.name.color;
                var d = e.name.fontSize
                  , g = e.name.fontFamily
                  , p = e.name.fontWeight;
                o = void 0 === e.value.color ? i.config.chart.foreColor : e.value.color;
                var m = e.value.formatter
                  , x = ""
                  , v = "";
                if (r ? (n = e.total.color,
                d = e.total.fontSize,
                g = e.total.fontFamily,
                p = e.total.fontWeight,
                v = e.total.label,
                x = e.total.formatter(i)) : 1 === i.globals.series.length && (x = m(i.globals.series[0], i),
                v = i.globals.seriesNames[0]),
                v && (v = e.name.formatter(v, e.total.show, i)),
                e.name.show) {
                    var k = s.drawText({
                        x: l,
                        y: c + parseFloat(e.name.offsetY),
                        text: v,
                        textAnchor: "middle",
                        foreColor: n,
                        fontSize: d,
                        fontWeight: p,
                        fontFamily: g
                    });
                    k.node.classList.add("apexcharts-datalabel-label"),
                    a.add(k)
                }
                if (e.value.show) {
                    var S = e.name.show ? parseFloat(e.value.offsetY) + 16 : e.value.offsetY
                      , C = s.drawText({
                        x: l,
                        y: c + S,
                        text: x,
                        textAnchor: "middle",
                        foreColor: o,
                        fontWeight: e.value.fontWeight,
                        fontSize: e.value.fontSize,
                        fontFamily: e.value.fontFamily
                    });
                    C.node.classList.add("apexcharts-datalabel-value"),
                    a.add(C)
                }
                return a
            }
        }, {
            key: "printInnerLabels",
            value: function(e, t, i, s) {
                var a, r = this.w;
                s ? a = void 0 === e.name.color ? r.globals.colors[parseInt(s.parentNode.getAttribute("rel"), 10) - 1] : e.name.color : r.globals.series.length > 1 && e.total.show && (a = e.total.color);
                var n = r.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label")
                  , o = r.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
                i = (0,
                e.value.formatter)(i, r),
                s || "function" != typeof e.total.formatter || (i = e.total.formatter(r)),
                t = e.name.formatter(t, t === e.total.label, r),
                null !== n && (n.textContent = t),
                null !== o && (o.textContent = i),
                null !== n && (n.style.fill = a)
            }
        }, {
            key: "printDataLabelsInner",
            value: function(e, t) {
                var i = this.w
                  , s = e.getAttribute("data:value")
                  , a = i.globals.seriesNames[parseInt(e.parentNode.getAttribute("rel"), 10) - 1];
                i.globals.series.length > 1 && this.printInnerLabels(t, a, s, e);
                var r = i.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
                null !== r && (r.style.opacity = 1)
            }
        }, {
            key: "drawSpokes",
            value: function(e) {
                var t = this
                  , i = this.w
                  , s = new D(this.ctx)
                  , a = i.config.plotOptions.polarArea.spokes;
                if (0 !== a.strokeWidth) {
                    for (var r = [], n = 360 / i.globals.series.length, o = 0; o < i.globals.series.length; o++)
                        r.push(M.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize, i.config.plotOptions.pie.startAngle + n * o));
                    r.forEach(function(l, c) {
                        var d = s.drawLine(l.x, l.y, t.centerX, t.centerY, Array.isArray(a.connectorColors) ? a.connectorColors[c] : a.connectorColors);
                        e.add(d)
                    })
                }
            }
        }, {
            key: "revertDataLabelsInner",
            value: function(e, t, i) {
                var s = this
                  , a = this.w
                  , r = a.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group")
                  , n = !1
                  , o = a.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area")
                  , l = function(g) {
                    var p = g.makeSliceOut
                      , m = g.printLabel;
                    Array.prototype.forEach.call(o, function(x) {
                        "true" === x.getAttribute("data:pieClicked") && (p && (n = !0),
                        m && s.printDataLabelsInner(x, t))
                    })
                };
                if (l({
                    makeSliceOut: !0,
                    printLabel: !1
                }),
                t.total.show && a.globals.series.length > 1)
                    n && !t.total.showAlways ? l({
                        makeSliceOut: !1,
                        printLabel: !0
                    }) : this.printInnerLabels(t, t.total.label, t.total.formatter(a));
                else if (l({
                    makeSliceOut: !1,
                    printLabel: !0
                }),
                !n)
                    if (a.globals.selectedDataPoints.length && a.globals.series.length > 1)
                        if (a.globals.selectedDataPoints[0].length > 0) {
                            var c = a.globals.selectedDataPoints[0]
                              , d = a.globals.dom.baseEl.querySelector(".apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(c));
                            this.printDataLabelsInner(d, t)
                        } else
                            r && a.globals.selectedDataPoints.length && 0 === a.globals.selectedDataPoints[0].length && (r.style.opacity = 0);
                    else
                        r && a.globals.series.length > 1 && (r.style.opacity = 0)
            }
        }]),
        y
    }()
      , z = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w,
            this.chartType = this.w.config.chart.type,
            this.initialAnim = this.w.config.chart.animations.enabled,
            this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled,
            this.animDur = 0;
            var t = this.w;
            this.graphics = new D(this.ctx),
            this.lineColorArr = void 0 !== t.globals.stroke.colors ? t.globals.stroke.colors : t.globals.colors,
            this.defaultSize = t.globals.svgHeight < t.globals.svgWidth ? t.globals.gridHeight + 1.5 * t.globals.goldenPadding : t.globals.gridWidth,
            this.isLog = t.config.yaxis[0].logarithmic,
            this.coreUtils = new xe(this.ctx),
            this.maxValue = this.isLog ? this.coreUtils.getLogVal(t.globals.maxY, 0) : t.globals.maxY,
            this.minValue = this.isLog ? this.coreUtils.getLogVal(this.w.globals.minY, 0) : t.globals.minY,
            this.polygons = t.config.plotOptions.radar.polygons,
            this.strokeWidth = t.config.stroke.show ? t.config.stroke.width : 0,
            this.size = this.defaultSize / 2.1 - this.strokeWidth - t.config.chart.dropShadow.blur,
            t.config.xaxis.labels.show && (this.size = this.size - t.globals.xAxisLabelsWidth / 1.75),
            void 0 !== t.config.plotOptions.radar.size && (this.size = t.config.plotOptions.radar.size),
            this.dataRadiusOfPercent = [],
            this.dataRadius = [],
            this.angleArr = [],
            this.yaxisLabelsTextsPos = []
        }
        return V(y, [{
            key: "draw",
            value: function(e) {
                var t = this
                  , i = this.w
                  , s = new ue(this.ctx)
                  , a = []
                  , r = new Ge(this.ctx);
                e.length && (this.dataPointsLen = e[i.globals.maxValsInArrayIndex].length),
                this.disAngle = 2 * Math.PI / this.dataPointsLen;
                var c = i.globals.gridHeight / 2 + i.config.plotOptions.radar.offsetY
                  , d = this.graphics.group({
                    class: "apexcharts-radar-series apexcharts-plot-series",
                    transform: "translate(".concat(i.globals.gridWidth / 2 + i.config.plotOptions.radar.offsetX || 0, ", ").concat(c || 0, ")")
                })
                  , g = []
                  , p = null
                  , m = null;
                if (this.yaxisLabels = this.graphics.group({
                    class: "apexcharts-yaxis"
                }),
                e.forEach(function(v, k) {
                    var S = v.length === i.globals.dataPoints
                      , C = t.graphics.group().attr({
                        class: "apexcharts-series",
                        "data:longestSeries": S,
                        seriesName: M.escapeString(i.globals.seriesNames[k]),
                        rel: k + 1,
                        "data:realIndex": k
                    });
                    t.dataRadiusOfPercent[k] = [],
                    t.dataRadius[k] = [],
                    t.angleArr[k] = [],
                    v.forEach(function(G, ie) {
                        var ne = Math.abs(t.maxValue - t.minValue);
                        G += Math.abs(t.minValue),
                        t.isLog && (G = t.coreUtils.getLogVal(G, 0)),
                        t.dataRadiusOfPercent[k][ie] = G / ne,
                        t.dataRadius[k][ie] = t.dataRadiusOfPercent[k][ie] * t.size,
                        t.angleArr[k][ie] = ie * t.disAngle
                    }),
                    g = t.getDataPointsPos(t.dataRadius[k], t.angleArr[k]);
                    var h = t.createPaths(g, {
                        x: 0,
                        y: 0
                    });
                    p = t.graphics.group({
                        class: "apexcharts-series-markers-wrap apexcharts-element-hidden"
                    }),
                    m = t.graphics.group({
                        class: "apexcharts-datalabels",
                        "data:realIndex": k
                    }),
                    i.globals.delayedElements.push({
                        el: p.node,
                        index: k
                    });
                    var u = {
                        i: k,
                        realIndex: k,
                        animationDelay: k,
                        initialSpeed: i.config.chart.animations.speed,
                        dataChangeSpeed: i.config.chart.animations.dynamicAnimation.speed,
                        className: "apexcharts-radar",
                        shouldClipToGrid: !1,
                        bindEventsOnPaths: !1,
                        stroke: i.globals.stroke.colors[k],
                        strokeLineCap: i.config.stroke.lineCap
                    }
                      , b = null;
                    i.globals.previousPaths.length > 0 && (b = t.getPreviousPath(k));
                    for (var w = 0; w < h.linePathsTo.length; w++) {
                        var _ = t.graphics.renderPaths(Z(Z({}, u), {}, {
                            pathFrom: null === b ? h.linePathsFrom[w] : b,
                            pathTo: h.linePathsTo[w],
                            strokeWidth: Array.isArray(t.strokeWidth) ? t.strokeWidth[k] : t.strokeWidth,
                            fill: "none",
                            drawShadow: !1
                        }));
                        C.add(_);
                        var X = s.fillPath({
                            seriesNumber: k
                        })
                          , I = t.graphics.renderPaths(Z(Z({}, u), {}, {
                            pathFrom: null === b ? h.areaPathsFrom[w] : b,
                            pathTo: h.areaPathsTo[w],
                            strokeWidth: 0,
                            fill: X,
                            drawShadow: !1
                        }));
                        i.config.chart.dropShadow.enabled && new me(t.ctx).dropShadow(I, Object.assign({}, i.config.chart.dropShadow, {
                            noUserSpaceOnUse: !0
                        }), k),
                        C.add(I)
                    }
                    v.forEach(function(G, ie) {
                        var ne = new Ae(t.ctx).getMarkerConfig({
                            cssClass: "apexcharts-marker",
                            seriesIndex: k,
                            dataPointIndex: ie
                        })
                          , oe = t.graphics.drawMarker(g[ie].x, g[ie].y, ne);
                        oe.attr("rel", ie),
                        oe.attr("j", ie),
                        oe.attr("index", k),
                        oe.node.setAttribute("default-marker-size", ne.pSize);
                        var ye = t.graphics.group({
                            class: "apexcharts-series-markers"
                        });
                        ye && ye.add(oe),
                        p.add(ye),
                        C.add(p);
                        var Le = i.config.dataLabels;
                        if (Le.enabled) {
                            var De = Le.formatter(i.globals.series[k][ie], {
                                seriesIndex: k,
                                dataPointIndex: ie,
                                w: i
                            });
                            r.plotDataLabelsText({
                                x: g[ie].x,
                                y: g[ie].y,
                                text: De,
                                textAnchor: "middle",
                                i: k,
                                j: k,
                                parent: m,
                                offsetCorrection: !1,
                                dataLabelsConfig: Z({}, Le)
                            })
                        }
                        C.add(m)
                    }),
                    a.push(C)
                }),
                this.drawPolygons({
                    parent: d
                }),
                i.config.xaxis.labels.show) {
                    var x = this.drawXAxisTexts();
                    d.add(x)
                }
                return a.forEach(function(v) {
                    d.add(v)
                }),
                d.add(this.yaxisLabels),
                d
            }
        }, {
            key: "drawPolygons",
            value: function(e) {
                for (var t = this, i = this.w, s = e.parent, a = new E(this.ctx), r = i.globals.yAxisScale[0].result.reverse(), n = r.length, o = [], l = this.size / (n - 1), c = 0; c < n; c++)
                    o[c] = l * c;
                o.reverse();
                var d = []
                  , g = [];
                o.forEach(function(p, m) {
                    var x = M.getPolygonPos(p, t.dataPointsLen)
                      , v = "";
                    x.forEach(function(k, S) {
                        if (0 === m) {
                            var C = t.graphics.drawLine(k.x, k.y, 0, 0, Array.isArray(t.polygons.connectorColors) ? t.polygons.connectorColors[S] : t.polygons.connectorColors);
                            g.push(C)
                        }
                        0 === S && t.yaxisLabelsTextsPos.push({
                            x: k.x,
                            y: k.y
                        }),
                        v += k.x + "," + k.y + " "
                    }),
                    d.push(v)
                }),
                d.forEach(function(p, m) {
                    var x = t.polygons.strokeColors
                      , v = t.polygons.strokeWidth
                      , k = t.graphics.drawPolygon(p, Array.isArray(x) ? x[m] : x, Array.isArray(v) ? v[m] : v, i.globals.radarPolygons.fill.colors[m]);
                    s.add(k)
                }),
                g.forEach(function(p) {
                    s.add(p)
                }),
                i.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach(function(p, m) {
                    var x = a.drawYAxisTexts(p.x, p.y, m, r[m]);
                    t.yaxisLabels.add(x)
                })
            }
        }, {
            key: "drawXAxisTexts",
            value: function() {
                var e = this
                  , t = this.w
                  , i = t.config.xaxis.labels
                  , s = this.graphics.group({
                    class: "apexcharts-xaxis"
                })
                  , a = M.getPolygonPos(this.size, this.dataPointsLen);
                return t.globals.labels.forEach(function(r, n) {
                    var o = t.config.xaxis.labels.formatter
                      , l = new Ge(e.ctx);
                    if (a[n]) {
                        var c = e.getTextPos(a[n], e.size)
                          , d = o(r, {
                            seriesIndex: -1,
                            dataPointIndex: n,
                            w: t
                        });
                        l.plotDataLabelsText({
                            x: c.newX,
                            y: c.newY,
                            text: d,
                            textAnchor: c.textAnchor,
                            i: n,
                            j: n,
                            parent: s,
                            color: Array.isArray(i.style.colors) && i.style.colors[n] ? i.style.colors[n] : "#a8a8a8",
                            dataLabelsConfig: Z({
                                textAnchor: c.textAnchor,
                                dropShadow: {
                                    enabled: !1
                                }
                            }, i),
                            offsetCorrection: !1
                        })
                    }
                }),
                s
            }
        }, {
            key: "createPaths",
            value: function(e, t) {
                var i = this
                  , s = []
                  , a = []
                  , r = []
                  , n = [];
                if (e.length) {
                    a = [this.graphics.move(t.x, t.y)],
                    n = [this.graphics.move(t.x, t.y)];
                    var o = this.graphics.move(e[0].x, e[0].y)
                      , l = this.graphics.move(e[0].x, e[0].y);
                    e.forEach(function(c, d) {
                        o += i.graphics.line(c.x, c.y),
                        l += i.graphics.line(c.x, c.y),
                        d === e.length - 1 && (o += "Z",
                        l += "Z")
                    }),
                    s.push(o),
                    r.push(l)
                }
                return {
                    linePathsFrom: a,
                    linePathsTo: s,
                    areaPathsFrom: n,
                    areaPathsTo: r
                }
            }
        }, {
            key: "getTextPos",
            value: function(e, t) {
                var i = "middle"
                  , s = e.x
                  , a = e.y;
                return Math.abs(e.x) >= 10 ? e.x > 0 ? (i = "start",
                s += 10) : e.x < 0 && (i = "end",
                s -= 10) : i = "middle",
                Math.abs(e.y) >= t - 10 && (e.y < 0 ? a -= 10 : e.y > 0 && (a += 10)),
                {
                    textAnchor: i,
                    newX: s,
                    newY: a
                }
            }
        }, {
            key: "getPreviousPath",
            value: function(e) {
                for (var t = this.w, i = null, s = 0; s < t.globals.previousPaths.length; s++) {
                    var a = t.globals.previousPaths[s];
                    a.paths.length > 0 && parseInt(a.realIndex, 10) === parseInt(e, 10) && void 0 !== t.globals.previousPaths[s].paths[0] && (i = t.globals.previousPaths[s].paths[0].d)
                }
                return i
            }
        }, {
            key: "getDataPointsPos",
            value: function(e, t) {
                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.dataPointsLen;
                e = e || [],
                t = t || [];
                for (var s = [], a = 0; a < i; a++) {
                    var r = {};
                    r.x = e[a] * Math.sin(t[a]),
                    r.y = -e[a] * Math.cos(t[a]),
                    s.push(r)
                }
                return s
            }
        }]),
        y
    }()
      , O = function(y) {
        Fe(t, y);
        var e = Te(t);
        function t(i) {
            var s;
            W(this, t),
            (s = e.call(this, i)).ctx = i,
            s.w = i.w,
            s.animBeginArr = [0],
            s.animDur = 0;
            var a = s.w;
            return s.startAngle = a.config.plotOptions.radialBar.startAngle,
            s.endAngle = a.config.plotOptions.radialBar.endAngle,
            s.totalAngle = Math.abs(a.config.plotOptions.radialBar.endAngle - a.config.plotOptions.radialBar.startAngle),
            s.trackStartAngle = a.config.plotOptions.radialBar.track.startAngle,
            s.trackEndAngle = a.config.plotOptions.radialBar.track.endAngle,
            s.donutDataLabels = s.w.config.plotOptions.radialBar.dataLabels,
            s.radialDataLabels = s.donutDataLabels,
            s.trackStartAngle || (s.trackStartAngle = s.startAngle),
            s.trackEndAngle || (s.trackEndAngle = s.endAngle),
            360 === s.endAngle && (s.endAngle = 359.99),
            s.margin = parseInt(a.config.plotOptions.radialBar.track.margin, 10),
            s
        }
        return V(t, [{
            key: "draw",
            value: function(i) {
                var s = this.w
                  , a = new D(this.ctx)
                  , r = a.group({
                    class: "apexcharts-radialbar"
                });
                if (s.globals.noData)
                    return r;
                var n = a.group()
                  , o = this.defaultSize / 2
                  , l = s.globals.gridWidth / 2
                  , c = this.defaultSize / 2.05;
                s.config.chart.sparkline.enabled || (c = c - s.config.stroke.width - s.config.chart.dropShadow.blur);
                var d = s.globals.fill.colors;
                if (s.config.plotOptions.radialBar.track.show) {
                    var g = this.drawTracks({
                        size: c,
                        centerX: l,
                        centerY: o,
                        colorArr: d,
                        series: i
                    });
                    n.add(g)
                }
                var p = this.drawArcs({
                    size: c,
                    centerX: l,
                    centerY: o,
                    colorArr: d,
                    series: i
                })
                  , m = 360;
                s.config.plotOptions.radialBar.startAngle < 0 && (m = this.totalAngle);
                var x = (360 - m) / 360;
                if (s.globals.radialSize = c - c * x,
                this.radialDataLabels.value.show) {
                    var v = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
                    s.globals.radialSize += v * x
                }
                return n.add(p.g),
                "front" === s.config.plotOptions.radialBar.hollow.position && (p.g.add(p.elHollow),
                p.dataLabels && p.g.add(p.dataLabels)),
                r.add(n),
                r
            }
        }, {
            key: "drawTracks",
            value: function(i) {
                var s = this.w
                  , a = new D(this.ctx)
                  , r = a.group({
                    class: "apexcharts-tracks"
                })
                  , n = new me(this.ctx)
                  , o = new ue(this.ctx)
                  , l = this.getStrokeWidth(i);
                i.size = i.size - l / 2;
                for (var c = 0; c < i.series.length; c++) {
                    var d = a.group({
                        class: "apexcharts-radialbar-track apexcharts-track"
                    });
                    r.add(d),
                    d.attr({
                        rel: c + 1
                    }),
                    i.size = i.size - l - this.margin;
                    var g = s.config.plotOptions.radialBar.track
                      , p = o.fillPath({
                        seriesNumber: 0,
                        size: i.size,
                        fillColors: Array.isArray(g.background) ? g.background[c] : g.background,
                        solid: !0
                    })
                      , m = this.trackStartAngle
                      , x = this.trackEndAngle;
                    Math.abs(x) + Math.abs(m) >= 360 && (x = 360 - Math.abs(this.startAngle) - .1);
                    var v = a.drawPath({
                        d: "",
                        stroke: p,
                        strokeWidth: l * parseInt(g.strokeWidth, 10) / 100,
                        fill: "none",
                        strokeOpacity: g.opacity,
                        classes: "apexcharts-radialbar-area"
                    });
                    g.dropShadow.enabled && n.dropShadow(v, g.dropShadow),
                    d.add(v),
                    v.attr("id", "apexcharts-radialbarTrack-" + c),
                    this.animatePaths(v, {
                        centerX: i.centerX,
                        centerY: i.centerY,
                        endAngle: x,
                        startAngle: m,
                        size: i.size,
                        i: c,
                        totalItems: 2,
                        animBeginArr: 0,
                        dur: 0,
                        isTrack: !0,
                        easing: s.globals.easing
                    })
                }
                return r
            }
        }, {
            key: "drawArcs",
            value: function(i) {
                var s = this.w
                  , a = new D(this.ctx)
                  , r = new ue(this.ctx)
                  , n = new me(this.ctx)
                  , o = a.group()
                  , l = this.getStrokeWidth(i);
                i.size = i.size - l / 2;
                var c = s.config.plotOptions.radialBar.hollow.background
                  , d = i.size - l * i.series.length - this.margin * i.series.length - l * parseInt(s.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2
                  , g = d - s.config.plotOptions.radialBar.hollow.margin;
                void 0 !== s.config.plotOptions.radialBar.hollow.image && (c = this.drawHollowImage(i, o, d, c));
                var p = this.drawHollow({
                    size: g,
                    centerX: i.centerX,
                    centerY: i.centerY,
                    fill: c || "transparent"
                });
                s.config.plotOptions.radialBar.hollow.dropShadow.enabled && n.dropShadow(p, s.config.plotOptions.radialBar.hollow.dropShadow);
                var x = 1;
                !this.radialDataLabels.total.show && s.globals.series.length > 1 && (x = 0);
                var v = null;
                this.radialDataLabels.show && (v = this.renderInnerDataLabels(this.radialDataLabels, {
                    hollowSize: d,
                    centerX: i.centerX,
                    centerY: i.centerY,
                    opacity: x
                })),
                "back" === s.config.plotOptions.radialBar.hollow.position && (o.add(p),
                v && o.add(v));
                var k = !1;
                s.config.plotOptions.radialBar.inverseOrder && (k = !0);
                for (var S = k ? i.series.length - 1 : 0; k ? S >= 0 : S < i.series.length; k ? S-- : S++) {
                    var C = a.group({
                        class: "apexcharts-series apexcharts-radial-series",
                        seriesName: M.escapeString(s.globals.seriesNames[S])
                    });
                    o.add(C),
                    C.attr({
                        rel: S + 1,
                        "data:realIndex": S
                    }),
                    this.ctx.series.addCollapsedClassToSeries(C, S),
                    i.size = i.size - l - this.margin;
                    var h = r.fillPath({
                        seriesNumber: S,
                        size: i.size,
                        value: i.series[S]
                    })
                      , u = this.startAngle
                      , b = void 0
                      , w = M.negToZero(i.series[S] > 100 ? 100 : i.series[S]) / 100
                      , _ = Math.round(this.totalAngle * w) + this.startAngle
                      , X = void 0;
                    s.globals.dataChanged && (b = this.startAngle,
                    X = Math.round(this.totalAngle * M.negToZero(s.globals.previousPaths[S]) / 100) + b),
                    Math.abs(_) + Math.abs(u) >= 360 && (_ -= .01),
                    Math.abs(X) + Math.abs(b) >= 360 && (X -= .01);
                    var I = _ - u
                      , R = Array.isArray(s.config.stroke.dashArray) ? s.config.stroke.dashArray[S] : s.config.stroke.dashArray
                      , H = a.drawPath({
                        d: "",
                        stroke: h,
                        strokeWidth: l,
                        fill: "none",
                        fillOpacity: s.config.fill.opacity,
                        classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + S,
                        strokeDashArray: R
                    });
                    D.setAttrs(H.node, {
                        "data:angle": I,
                        "data:value": i.series[S]
                    }),
                    s.config.chart.dropShadow.enabled && n.dropShadow(H, s.config.chart.dropShadow, S),
                    n.setSelectionFilter(H, 0, S),
                    this.addListeners(H, this.radialDataLabels),
                    C.add(H),
                    H.attr({
                        index: 0,
                        j: S
                    });
                    var ie = 0;
                    !this.initialAnim || s.globals.resized || s.globals.dataChanged || (this.animDur = (ie = (_ - u) / 360 * s.config.chart.animations.speed) / (1.2 * i.series.length) + this.animDur,
                    this.animBeginArr.push(this.animDur)),
                    s.globals.dataChanged && (this.animDur = (ie = (_ - u) / 360 * s.config.chart.animations.dynamicAnimation.speed) / (1.2 * i.series.length) + this.animDur,
                    this.animBeginArr.push(this.animDur)),
                    this.animatePaths(H, {
                        centerX: i.centerX,
                        centerY: i.centerY,
                        endAngle: _,
                        startAngle: u,
                        prevEndAngle: X,
                        prevStartAngle: b,
                        size: i.size,
                        i: S,
                        totalItems: 2,
                        animBeginArr: this.animBeginArr,
                        dur: ie,
                        shouldSetPrevPaths: !0,
                        easing: s.globals.easing
                    })
                }
                return {
                    g: o,
                    elHollow: p,
                    dataLabels: v
                }
            }
        }, {
            key: "drawHollow",
            value: function(i) {
                var s = new D(this.ctx).drawCircle(2 * i.size);
                return s.attr({
                    class: "apexcharts-radialbar-hollow",
                    cx: i.centerX,
                    cy: i.centerY,
                    r: i.size,
                    fill: i.fill
                }),
                s
            }
        }, {
            key: "drawHollowImage",
            value: function(i, s, a, r) {
                var n = this.w
                  , o = new ue(this.ctx)
                  , l = M.randomId()
                  , c = n.config.plotOptions.radialBar.hollow.image;
                if (n.config.plotOptions.radialBar.hollow.imageClipped)
                    o.clippedImgArea({
                        width: a,
                        height: a,
                        image: c,
                        patternID: "pattern".concat(n.globals.cuid).concat(l)
                    }),
                    r = "url(#pattern".concat(n.globals.cuid).concat(l, ")");
                else {
                    var d = n.config.plotOptions.radialBar.hollow.imageWidth
                      , g = n.config.plotOptions.radialBar.hollow.imageHeight;
                    if (void 0 === d && void 0 === g) {
                        var p = n.globals.dom.Paper.image(c).loaded(function(x) {
                            this.move(i.centerX - x.width / 2 + n.config.plotOptions.radialBar.hollow.imageOffsetX, i.centerY - x.height / 2 + n.config.plotOptions.radialBar.hollow.imageOffsetY)
                        });
                        s.add(p)
                    } else {
                        var m = n.globals.dom.Paper.image(c).loaded(function(x) {
                            this.move(i.centerX - d / 2 + n.config.plotOptions.radialBar.hollow.imageOffsetX, i.centerY - g / 2 + n.config.plotOptions.radialBar.hollow.imageOffsetY),
                            this.size(d, g)
                        });
                        s.add(m)
                    }
                }
                return r
            }
        }, {
            key: "getStrokeWidth",
            value: function(i) {
                return i.size * (100 - parseInt(this.w.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (i.series.length + 1) - this.margin
            }
        }]),
        t
    }(T)
      , q = function() {
        function y(e) {
            W(this, y),
            this.w = e.w,
            this.lineCtx = e
        }
        return V(y, [{
            key: "sameValueSeriesFix",
            value: function(e, t) {
                var i = this.w;
                if ("line" === i.config.chart.type && ("gradient" === i.config.fill.type || "gradient" === i.config.fill.type[e]) && new xe(this.lineCtx.ctx,i).seriesHaveSameValues(e)) {
                    var s = t[e].slice();
                    s[s.length - 1] = s[s.length - 1] + 1e-6,
                    t[e] = s
                }
                return t
            }
        }, {
            key: "calculatePoints",
            value: function(e) {
                var t = e.series
                  , s = e.x
                  , a = e.y
                  , r = e.i
                  , n = e.j
                  , o = e.prevY
                  , l = this.w
                  , c = []
                  , d = [];
                if (0 === n) {
                    var g = this.lineCtx.categoryAxisCorrection + l.config.markers.offsetX;
                    l.globals.isXNumeric && (g = (l.globals.seriesX[e.realIndex][0] - l.globals.minX) / this.lineCtx.xRatio + l.config.markers.offsetX),
                    c.push(g),
                    d.push(M.isNumber(t[r][0]) ? o + l.config.markers.offsetY : null),
                    c.push(s + l.config.markers.offsetX),
                    d.push(M.isNumber(t[r][n + 1]) ? a + l.config.markers.offsetY : null)
                } else
                    c.push(s + l.config.markers.offsetX),
                    d.push(M.isNumber(t[r][n + 1]) ? a + l.config.markers.offsetY : null);
                return {
                    x: c,
                    y: d
                }
            }
        }, {
            key: "checkPreviousPaths",
            value: function(e) {
                for (var t = e.pathFromLine, i = e.pathFromArea, s = e.realIndex, a = this.w, r = 0; r < a.globals.previousPaths.length; r++) {
                    var n = a.globals.previousPaths[r];
                    ("line" === n.type || "area" === n.type) && n.paths.length > 0 && parseInt(n.realIndex, 10) === parseInt(s, 10) && ("line" === n.type ? (this.lineCtx.appendPathFrom = !1,
                    t = a.globals.previousPaths[r].paths[0].d) : "area" === n.type && (this.lineCtx.appendPathFrom = !1,
                    i = a.globals.previousPaths[r].paths[0].d,
                    a.config.stroke.show && a.globals.previousPaths[r].paths[1] && (t = a.globals.previousPaths[r].paths[1].d)))
                }
                return {
                    pathFromLine: t,
                    pathFromArea: i
                }
            }
        }, {
            key: "determineFirstPrevY",
            value: function(e) {
                var t = e.i
                  , i = e.series
                  , s = e.prevY
                  , a = e.lineYPosition
                  , r = this.w;
                if (void 0 !== i[t][0])
                    s = (a = r.config.chart.stacked && t > 0 ? this.lineCtx.prevSeriesY[t - 1][0] : this.lineCtx.zeroY) - i[t][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] + 2 * (this.lineCtx.isReversed ? i[t][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] : 0);
                else if (r.config.chart.stacked && t > 0 && void 0 === i[t][0])
                    for (var n = t - 1; n >= 0; n--)
                        if (null != i[n][0]) {
                            s = a = this.lineCtx.prevSeriesY[n][0];
                            break
                        }
                return {
                    prevY: s,
                    lineYPosition: a
                }
            }
        }]),
        y
    }()
      , N = function() {
        function y(e, t, i) {
            W(this, y),
            this.ctx = e,
            this.w = e.w,
            this.xyRatios = t,
            this.pointsChart = !("bubble" !== this.w.config.chart.type && "scatter" !== this.w.config.chart.type) || i,
            this.scatter = new _e(this.ctx),
            this.noNegatives = this.w.globals.minX === Number.MAX_VALUE,
            this.lineHelpers = new q(this),
            this.markers = new Ae(this.ctx),
            this.prevSeriesY = [],
            this.categoryAxisCorrection = 0,
            this.yaxisIndex = 0
        }
        return V(y, [{
            key: "draw",
            value: function(e, t, i) {
                var s = this.w
                  , a = new D(this.ctx)
                  , r = s.globals.comboCharts ? t : s.config.chart.type
                  , n = a.group({
                    class: "apexcharts-".concat(r, "-series apexcharts-plot-series")
                })
                  , o = new xe(this.ctx,s);
                this.yRatio = this.xyRatios.yRatio,
                this.zRatio = this.xyRatios.zRatio,
                this.xRatio = this.xyRatios.xRatio,
                this.baseLineY = this.xyRatios.baseLineY,
                e = o.getLogSeries(e),
                this.yRatio = o.getLogYRatios(this.yRatio);
                for (var l = [], c = 0; c < e.length; c++) {
                    e = this.lineHelpers.sameValueSeriesFix(c, e);
                    var d = s.globals.comboCharts ? i[c] : c;
                    this._initSerieVariables(e, c, d);
                    var g = []
                      , p = []
                      , m = s.globals.padHorizontal + this.categoryAxisCorrection;
                    this.ctx.series.addCollapsedClassToSeries(this.elSeries, d),
                    s.globals.isXNumeric && s.globals.seriesX.length > 0 && (m = (s.globals.seriesX[d][0] - s.globals.minX) / this.xRatio),
                    p.push(m);
                    var x, v = m, k = v, S = this.zeroY;
                    S = this.lineHelpers.determineFirstPrevY({
                        i: c,
                        series: e,
                        prevY: S,
                        lineYPosition: 0
                    }).prevY,
                    g.push(S),
                    x = S;
                    var C = this._calculatePathsFrom({
                        series: e,
                        i: c,
                        realIndex: d,
                        prevX: k,
                        prevY: S
                    })
                      , h = this._iterateOverDataPoints({
                        series: e,
                        realIndex: d,
                        i: c,
                        x: m,
                        y: 1,
                        pX: v,
                        pY: x,
                        pathsFrom: C,
                        linePaths: [],
                        areaPaths: [],
                        seriesIndex: i,
                        lineYPosition: 0,
                        xArrj: p,
                        yArrj: g
                    });
                    this._handlePaths({
                        type: r,
                        realIndex: d,
                        i: c,
                        paths: h
                    }),
                    this.elSeries.add(this.elPointsMain),
                    this.elSeries.add(this.elDataLabelsWrap),
                    l.push(this.elSeries)
                }
                if (s.config.chart.stacked)
                    for (var u = l.length; u > 0; u--)
                        n.add(l[u - 1]);
                else
                    for (var b = 0; b < l.length; b++)
                        n.add(l[b]);
                return n
            }
        }, {
            key: "_initSerieVariables",
            value: function(e, t, i) {
                var s = this.w
                  , a = new D(this.ctx);
                this.xDivision = s.globals.gridWidth / (s.globals.dataPoints - ("on" === s.config.xaxis.tickPlacement ? 1 : 0)),
                this.strokeWidth = Array.isArray(s.config.stroke.width) ? s.config.stroke.width[i] : s.config.stroke.width,
                this.yRatio.length > 1 && (this.yaxisIndex = i),
                this.isReversed = s.config.yaxis[this.yaxisIndex] && s.config.yaxis[this.yaxisIndex].reversed,
                this.zeroY = s.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? s.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0),
                this.areaBottomY = this.zeroY,
                (this.zeroY > s.globals.gridHeight || "end" === s.config.plotOptions.area.fillTo) && (this.areaBottomY = s.globals.gridHeight),
                this.categoryAxisCorrection = this.xDivision / 2,
                this.elSeries = a.group({
                    class: "apexcharts-series",
                    seriesName: M.escapeString(s.globals.seriesNames[i])
                }),
                this.elPointsMain = a.group({
                    class: "apexcharts-series-markers-wrap",
                    "data:realIndex": i
                }),
                this.elDataLabelsWrap = a.group({
                    class: "apexcharts-datalabels",
                    "data:realIndex": i
                }),
                this.elSeries.attr({
                    "data:longestSeries": e[t].length === s.globals.dataPoints,
                    rel: t + 1,
                    "data:realIndex": i
                }),
                this.appendPathFrom = !0
            }
        }, {
            key: "_calculatePathsFrom",
            value: function(e) {
                var t, i, s, a, r = e.series, n = e.i, o = e.realIndex, l = e.prevX, c = e.prevY, d = this.w, g = new D(this.ctx);
                if (null === r[n][0]) {
                    for (var p = 0; p < r[n].length; p++)
                        if (null !== r[n][p]) {
                            t = g.move(l = this.xDivision * p, c = this.zeroY - r[n][p] / this.yRatio[this.yaxisIndex]),
                            i = g.move(l, this.areaBottomY);
                            break
                        }
                } else
                    t = g.move(l, c),
                    i = g.move(l, this.areaBottomY) + g.line(l, c);
                if (s = g.move(-1, this.zeroY) + g.line(-1, this.zeroY),
                a = g.move(-1, this.zeroY) + g.line(-1, this.zeroY),
                d.globals.previousPaths.length > 0) {
                    var m = this.lineHelpers.checkPreviousPaths({
                        pathFromLine: s,
                        pathFromArea: a,
                        realIndex: o
                    });
                    s = m.pathFromLine,
                    a = m.pathFromArea
                }
                return {
                    prevX: l,
                    prevY: c,
                    linePath: t,
                    areaPath: i,
                    pathFromLine: s,
                    pathFromArea: a
                }
            }
        }, {
            key: "_handlePaths",
            value: function(e) {
                var t = e.type
                  , i = e.realIndex
                  , s = e.i
                  , a = e.paths
                  , r = this.w
                  , n = new D(this.ctx)
                  , o = new ue(this.ctx);
                this.prevSeriesY.push(a.yArrj),
                r.globals.seriesXvalues[i] = a.xArrj,
                r.globals.seriesYvalues[i] = a.yArrj;
                var l = r.config.forecastDataPoints;
                if (l.count > 0) {
                    var c = r.globals.seriesXvalues[i][r.globals.seriesXvalues[i].length - l.count - 1]
                      , d = n.drawRect(c, 0, r.globals.gridWidth, r.globals.gridHeight, 0);
                    r.globals.dom.elForecastMask.appendChild(d.node);
                    var g = n.drawRect(0, 0, c, r.globals.gridHeight, 0);
                    r.globals.dom.elNonForecastMask.appendChild(g.node)
                }
                this.pointsChart || r.globals.delayedElements.push({
                    el: this.elPointsMain.node,
                    index: i
                });
                var p = {
                    i: s,
                    realIndex: i,
                    animationDelay: s,
                    initialSpeed: r.config.chart.animations.speed,
                    dataChangeSpeed: r.config.chart.animations.dynamicAnimation.speed,
                    className: "apexcharts-".concat(t)
                };
                if ("area" === t)
                    for (var m = o.fillPath({
                        seriesNumber: i
                    }), x = 0; x < a.areaPaths.length; x++) {
                        var v = n.renderPaths(Z(Z({}, p), {}, {
                            pathFrom: a.pathFromArea,
                            pathTo: a.areaPaths[x],
                            stroke: "none",
                            strokeWidth: 0,
                            strokeLineCap: null,
                            fill: m
                        }));
                        this.elSeries.add(v)
                    }
                if (r.config.stroke.show && !this.pointsChart) {
                    var k;
                    k = "line" === t ? o.fillPath({
                        seriesNumber: i,
                        i: s
                    }) : r.globals.stroke.colors[i];
                    for (var S = 0; S < a.linePaths.length; S++) {
                        var C = Z(Z({}, p), {}, {
                            pathFrom: a.pathFromLine,
                            pathTo: a.linePaths[S],
                            stroke: k,
                            strokeWidth: this.strokeWidth,
                            strokeLineCap: r.config.stroke.lineCap,
                            fill: "none"
                        })
                          , h = n.renderPaths(C);
                        if (this.elSeries.add(h),
                        l.count > 0) {
                            var u = n.renderPaths(C);
                            u.node.setAttribute("stroke-dasharray", l.dashArray),
                            l.strokeWidth && u.node.setAttribute("stroke-width", l.strokeWidth),
                            this.elSeries.add(u),
                            u.attr("clip-path", "url(#forecastMask".concat(r.globals.cuid, ")")),
                            h.attr("clip-path", "url(#nonForecastMask".concat(r.globals.cuid, ")"))
                        }
                    }
                }
            }
        }, {
            key: "_iterateOverDataPoints",
            value: function(e) {
                for (var t = e.series, i = e.realIndex, s = e.i, a = e.x, r = e.y, n = e.pX, o = e.pY, l = e.pathsFrom, c = e.linePaths, d = e.areaPaths, g = e.seriesIndex, p = e.lineYPosition, m = e.xArrj, x = e.yArrj, v = this.w, k = new D(this.ctx), S = this.yRatio, C = l.prevY, h = l.linePath, u = l.areaPath, b = l.pathFromLine, w = l.pathFromArea, _ = M.isNumber(v.globals.minYArr[i]) ? v.globals.minYArr[i] : v.globals.minY, X = v.globals.dataPoints > 1 ? v.globals.dataPoints - 1 : v.globals.dataPoints, I = 0; I < X; I++) {
                    var R = null == t[s][I + 1];
                    if (v.globals.isXNumeric) {
                        var H = v.globals.seriesX[i][I + 1];
                        void 0 === v.globals.seriesX[i][I + 1] && (H = v.globals.seriesX[i][X - 1]),
                        a = (H - v.globals.minX) / this.xRatio
                    } else
                        a += this.xDivision;
                    p = v.config.chart.stacked && s > 0 && v.globals.collapsedSeries.length < v.config.series.length - 1 ? this.prevSeriesY[function(ne) {
                        for (var oe = ne, ye = 0; ye < v.globals.series.length; ye++)
                            if (v.globals.collapsedSeriesIndices.indexOf(ne) > -1) {
                                oe--;
                                break
                            }
                        return oe >= 0 ? oe : 0
                    }(s - 1)][I + 1] : this.zeroY,
                    r = R ? p - _ / S[this.yaxisIndex] + 2 * (this.isReversed ? _ / S[this.yaxisIndex] : 0) : p - t[s][I + 1] / S[this.yaxisIndex] + 2 * (this.isReversed ? t[s][I + 1] / S[this.yaxisIndex] : 0),
                    m.push(a),
                    x.push(r);
                    var G = this.lineHelpers.calculatePoints({
                        series: t,
                        x: a,
                        y: r,
                        realIndex: i,
                        i: s,
                        j: I,
                        prevY: C
                    })
                      , ie = this._createPaths({
                        series: t,
                        i: s,
                        realIndex: i,
                        j: I,
                        x: a,
                        y: r,
                        pX: n,
                        pY: o,
                        linePath: h,
                        areaPath: u,
                        linePaths: c,
                        areaPaths: d,
                        seriesIndex: g
                    });
                    d = ie.areaPaths,
                    c = ie.linePaths,
                    n = ie.pX,
                    o = ie.pY,
                    u = ie.areaPath,
                    h = ie.linePath,
                    this.appendPathFrom && (b += k.line(a, this.zeroY),
                    w += k.line(a, this.zeroY)),
                    this.handleNullDataPoints(t, G, s, I, i),
                    this._handleMarkersAndLabels({
                        pointsPos: G,
                        series: t,
                        x: a,
                        y: r,
                        prevY: C,
                        i: s,
                        j: I,
                        realIndex: i
                    })
                }
                return {
                    yArrj: x,
                    xArrj: m,
                    pathFromArea: w,
                    areaPaths: d,
                    pathFromLine: b,
                    linePaths: c
                }
            }
        }, {
            key: "_handleMarkersAndLabels",
            value: function(e) {
                var t = e.pointsPos
                  , i = e.i
                  , s = e.j
                  , a = e.realIndex
                  , r = this.w
                  , n = new Ge(this.ctx);
                if (this.pointsChart)
                    this.scatter.draw(this.elSeries, s, {
                        realIndex: a,
                        pointsPos: t,
                        zRatio: this.zRatio,
                        elParent: this.elPointsMain
                    });
                else {
                    r.globals.series[i].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
                    var o = this.markers.plotChartMarkers(t, a, s + 1);
                    null !== o && this.elPointsMain.add(o)
                }
                var l = n.drawDataLabel(t, a, s + 1, null);
                null !== l && this.elDataLabelsWrap.add(l)
            }
        }, {
            key: "_createPaths",
            value: function(e) {
                var t = e.series
                  , i = e.i
                  , s = e.realIndex
                  , a = e.j
                  , r = e.x
                  , n = e.y
                  , o = e.pX
                  , l = e.pY
                  , c = e.linePath
                  , d = e.areaPath
                  , g = e.linePaths
                  , p = e.areaPaths
                  , m = e.seriesIndex
                  , x = this.w
                  , v = new D(this.ctx)
                  , k = x.config.stroke.curve
                  , S = this.areaBottomY;
                if (Array.isArray(x.config.stroke.curve) && (k = Array.isArray(m) ? x.config.stroke.curve[m[i]] : x.config.stroke.curve[i]),
                "smooth" === k) {
                    var C = .35 * (r - o);
                    x.globals.hasNullValues ? (null !== t[i][a] && (null !== t[i][a + 1] ? (c = v.move(o, l) + v.curve(o + C, l, r - C, n, r + 1, n),
                    d = v.move(o + 1, l) + v.curve(o + C, l, r - C, n, r + 1, n) + v.line(r, S) + v.line(o, S) + "z") : (c = v.move(o, l),
                    d = v.move(o, l) + "z")),
                    g.push(c),
                    p.push(d)) : (c += v.curve(o + C, l, r - C, n, r, n),
                    d += v.curve(o + C, l, r - C, n, r, n)),
                    o = r,
                    l = n,
                    a === t[i].length - 2 && (d = d + v.curve(o, l, r, n, r, S) + v.move(r, n) + "z",
                    x.globals.hasNullValues || (g.push(c),
                    p.push(d)))
                } else
                    null === t[i][a + 1] && (c += v.move(r, n),
                    d = d + v.line(x.globals.isXNumeric ? (x.globals.seriesX[s][a] - x.globals.minX) / this.xRatio : r - this.xDivision, S) + v.move(r, n) + "z"),
                    null === t[i][a] && (c += v.move(r, n),
                    d += v.move(r, S)),
                    "stepline" === k ? (c = c + v.line(r, null, "H") + v.line(null, n, "V"),
                    d = d + v.line(r, null, "H") + v.line(null, n, "V")) : "straight" === k && (c += v.line(r, n),
                    d += v.line(r, n)),
                    a === t[i].length - 2 && (d = d + v.line(r, S) + v.move(r, n) + "z",
                    g.push(c),
                    p.push(d));
                return {
                    linePaths: g,
                    areaPaths: p,
                    pX: o,
                    pY: l,
                    linePath: c,
                    areaPath: d
                }
            }
        }, {
            key: "handleNullDataPoints",
            value: function(e, t, i, s, a) {
                var r = this.w;
                if (null === e[i][s] && r.config.markers.showNullDataPoints || 1 === e[i].length) {
                    var n = this.markers.plotChartMarkers(t, a, s + 1, this.strokeWidth - r.config.markers.strokeWidth / 2, !0);
                    null !== n && this.elPointsMain.add(n)
                }
            }
        }]),
        y
    }();
    window.TreemapSquared = {},
    window.TreemapSquared.generate = function() {
        function y(n, o, l, c) {
            this.xoffset = n,
            this.yoffset = o,
            this.height = c,
            this.width = l,
            this.shortestEdge = function() {
                return Math.min(this.height, this.width)
            }
            ,
            this.getCoordinates = function(d) {
                var g, p = [], m = this.xoffset, x = this.yoffset, v = a(d) / this.height, k = a(d) / this.width;
                if (this.width >= this.height)
                    for (g = 0; g < d.length; g++)
                        p.push([m, x, m + v, x + d[g] / v]),
                        x += d[g] / v;
                else
                    for (g = 0; g < d.length; g++)
                        p.push([m, x, m + d[g] / k, x + k]),
                        m += d[g] / k;
                return p
            }
            ,
            this.cutArea = function(d) {
                var g;
                if (this.width >= this.height) {
                    var p = d / this.height;
                    g = new y(this.xoffset + p,this.yoffset,this.width - p,this.height)
                } else {
                    var x = d / this.width;
                    g = new y(this.xoffset,this.yoffset + x,this.width,this.height - x)
                }
                return g
            }
        }
        function e(n, o, l, c, d) {
            return c = void 0 === c ? 0 : c,
            d = void 0 === d ? 0 : d,
            function(g) {
                var p, m, x = [];
                for (p = 0; p < g.length; p++)
                    for (m = 0; m < g[p].length; m++)
                        x.push(g[p][m]);
                return x
            }(t(function(g, p) {
                var m, x = [], v = p / a(g);
                for (m = 0; m < g.length; m++)
                    x[m] = g[m] * v;
                return x
            }(n, o * l), [], new y(c,d,o,l), []))
        }
        function t(n, o, l, c) {
            var d, g, p, m, x, v, k;
            if (0 !== n.length)
                return d = l.shortestEdge(),
                x = g = n[0],
                v = d,
                0 === (m = o).length || ((k = m.slice()).push(x),
                i(m, v) >= i(k, v)) ? (o.push(g),
                t(n.slice(1), o, l, c)) : (p = l.cutArea(a(o), c),
                c.push(l.getCoordinates(o)),
                t(n, [], p, c)),
                c;
            c.push(l.getCoordinates(o))
        }
        function i(n, o) {
            var l = Math.min.apply(Math, n)
              , c = Math.max.apply(Math, n)
              , d = a(n);
            return Math.max(Math.pow(o, 2) * c / Math.pow(d, 2), Math.pow(d, 2) / (Math.pow(o, 2) * l))
        }
        function s(n) {
            return n && n.constructor === Array
        }
        function a(n) {
            var o, l = 0;
            for (o = 0; o < n.length; o++)
                l += n[o];
            return l
        }
        function r(n) {
            var o, l = 0;
            if (s(n[0]))
                for (o = 0; o < n.length; o++)
                    l += r(n[o]);
            else
                l = a(n);
            return l
        }
        return function n(o, l, c, d, g) {
            d = void 0 === d ? 0 : d,
            g = void 0 === g ? 0 : g;
            var p, m, x = [], v = [];
            if (s(o[0])) {
                for (m = 0; m < o.length; m++)
                    x[m] = r(o[m]);
                for (p = e(x, l, c, d, g),
                m = 0; m < o.length; m++)
                    v.push(n(o[m], p[m][2] - p[m][0], p[m][3] - p[m][1], p[m][0], p[m][1]))
            } else
                v = e(o, l, c, d, g);
            return v
        }
    }();
    var j, B, U = function() {
        function y(e, t) {
            W(this, y),
            this.ctx = e,
            this.w = e.w,
            this.strokeWidth = this.w.config.stroke.width,
            this.helpers = new Ht(e),
            this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation,
            this.labels = []
        }
        return V(y, [{
            key: "draw",
            value: function(e) {
                var t = this
                  , i = this.w
                  , s = new D(this.ctx)
                  , a = new ue(this.ctx)
                  , r = s.group({
                    class: "apexcharts-treemap"
                });
                if (i.globals.noData)
                    return r;
                var n = [];
                return e.forEach(function(o) {
                    var l = o.map(function(c) {
                        return Math.abs(c)
                    });
                    n.push(l)
                }),
                this.negRange = this.helpers.checkColorRange(),
                i.config.series.forEach(function(o, l) {
                    o.data.forEach(function(c) {
                        Array.isArray(t.labels[l]) || (t.labels[l] = []),
                        t.labels[l].push(c.x)
                    })
                }),
                window.TreemapSquared.generate(n, i.globals.gridWidth, i.globals.gridHeight).forEach(function(o, l) {
                    var c = s.group({
                        class: "apexcharts-series apexcharts-treemap-series",
                        seriesName: M.escapeString(i.globals.seriesNames[l]),
                        rel: l + 1,
                        "data:realIndex": l
                    });
                    if (i.config.chart.dropShadow.enabled) {
                        var d = i.config.chart.dropShadow;
                        new me(t.ctx).dropShadow(r, d, l)
                    }
                    var g = s.group({
                        class: "apexcharts-data-labels"
                    });
                    o.forEach(function(p, m) {
                        var x = p[0]
                          , v = p[1]
                          , k = p[2]
                          , S = p[3]
                          , C = s.drawRect(x, v, k - x, S - v, 0, "#fff", 1, t.strokeWidth, i.config.plotOptions.treemap.useFillColorAsStroke ? u : i.globals.stroke.colors[l]);
                        C.attr({
                            cx: x,
                            cy: v,
                            index: l,
                            i: l,
                            j: m,
                            width: k - x,
                            height: S - v
                        });
                        var h = t.helpers.getShadeColor(i.config.chart.type, l, m, t.negRange)
                          , u = h.color;
                        void 0 !== i.config.series[l].data[m] && i.config.series[l].data[m].fillColor && (u = i.config.series[l].data[m].fillColor);
                        var b = a.fillPath({
                            color: u,
                            seriesNumber: l,
                            dataPointIndex: m
                        });
                        C.node.classList.add("apexcharts-treemap-rect"),
                        C.attr({
                            fill: b
                        }),
                        t.helpers.addListeners(C);
                        var w = {
                            x: x + (k - x) / 2,
                            y: v + (S - v) / 2,
                            width: 0,
                            height: 0
                        }
                          , _ = {
                            x,
                            y: v,
                            width: k - x,
                            height: S - v
                        };
                        if (i.config.chart.animations.enabled && !i.globals.dataChanged) {
                            var X = 1;
                            i.globals.resized || (X = i.config.chart.animations.speed),
                            t.animateTreemap(C, w, _, X)
                        }
                        i.globals.dataChanged && t.dynamicAnim.enabled && i.globals.shouldAnimate && (i.globals.previousPaths[l] && i.globals.previousPaths[l][m] && i.globals.previousPaths[l][m].rect && (w = i.globals.previousPaths[l][m].rect),
                        t.animateTreemap(C, w, _, t.dynamicAnim.speed));
                        var R = t.getFontSize(p)
                          , H = i.config.dataLabels.formatter(t.labels[l][m], {
                            value: i.globals.series[l][m],
                            seriesIndex: l,
                            dataPointIndex: m,
                            w: i
                        })
                          , G = t.helpers.calculateDataLabels({
                            text: H,
                            x: (x + k) / 2,
                            y: (v + S) / 2 + t.strokeWidth / 2 + R / 3,
                            i: l,
                            j: m,
                            colorProps: h,
                            fontSize: R,
                            series: e
                        });
                        i.config.dataLabels.enabled && G && t.rotateToFitLabel(G, H, x, v, k, S),
                        c.add(C),
                        null !== G && c.add(G)
                    }),
                    c.add(g),
                    r.add(c)
                }),
                r
            }
        }, {
            key: "getFontSize",
            value: function(e) {
                var r, t = this.w, n = function o(l) {
                    var c, d = 0;
                    if (Array.isArray(l[0]))
                        for (c = 0; c < l.length; c++)
                            d += o(l[c]);
                    else
                        for (c = 0; c < l.length; c++)
                            d += l[c].length;
                    return d
                }(this.labels) / function o(l) {
                    var c, d = 0;
                    if (Array.isArray(l[0]))
                        for (c = 0; c < l.length; c++)
                            d += o(l[c]);
                    else
                        for (c = 0; c < l.length; c++)
                            d += 1;
                    return d
                }(this.labels);
                return r = Math.pow((e[2] - e[0]) * (e[3] - e[1]), .5),
                Math.min(r / n, parseInt(t.config.dataLabels.style.fontSize, 10))
            }
        }, {
            key: "rotateToFitLabel",
            value: function(e, t, i, s, a, r) {
                var n = new D(this.ctx)
                  , o = n.getTextRects(t);
                if (o.width + 5 > a - i && o.width <= r - s) {
                    var l = n.rotateAroundCenter(e.node);
                    e.node.setAttribute("transform", "rotate(-90 ".concat(l.x, " ").concat(l.y, ")"))
                }
            }
        }, {
            key: "animateTreemap",
            value: function(e, t, i, s) {
                var a = new Ce(this.ctx);
                a.animateRect(e, {
                    x: t.x,
                    y: t.y,
                    width: t.width,
                    height: t.height
                }, {
                    x: i.x,
                    y: i.y,
                    width: i.width,
                    height: i.height
                }, s, function() {
                    a.animationCompleted(e)
                })
            }
        }]),
        y
    }(), J = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w,
            this.timeScaleArray = [],
            this.utc = this.w.config.xaxis.labels.datetimeUTC
        }
        return V(y, [{
            key: "calculateTimeScaleTicks",
            value: function(e, t) {
                var i = this
                  , s = this.w;
                if (s.globals.allSeriesCollapsed)
                    return s.globals.labels = [],
                    s.globals.timescaleLabels = [],
                    [];
                var a = new ge(this.ctx)
                  , r = (t - e) / 864e5;
                this.determineInterval(r),
                s.globals.disableZoomIn = !1,
                s.globals.disableZoomOut = !1,
                r < .00011574074074074075 ? s.globals.disableZoomIn = !0 : r > 5e4 && (s.globals.disableZoomOut = !0);
                var n = a.getTimeUnitsfromTimestamp(e, t, this.utc)
                  , o = s.globals.gridWidth / r
                  , l = o / 24
                  , c = l / 60
                  , d = c / 60
                  , g = Math.floor(24 * r)
                  , p = Math.floor(1440 * r)
                  , m = Math.floor(86400 * r)
                  , x = Math.floor(r)
                  , v = Math.floor(r / 30)
                  , k = Math.floor(r / 365)
                  , S = {
                    minMillisecond: n.minMillisecond,
                    minSecond: n.minSecond,
                    minMinute: n.minMinute,
                    minHour: n.minHour,
                    minDate: n.minDate,
                    minMonth: n.minMonth,
                    minYear: n.minYear
                }
                  , C = {
                    firstVal: S,
                    currentMillisecond: S.minMillisecond,
                    currentSecond: S.minSecond,
                    currentMinute: S.minMinute,
                    currentHour: S.minHour,
                    currentMonthDate: S.minDate,
                    currentDate: S.minDate,
                    currentMonth: S.minMonth,
                    currentYear: S.minYear,
                    daysWidthOnXAxis: o,
                    hoursWidthOnXAxis: l,
                    minutesWidthOnXAxis: c,
                    secondsWidthOnXAxis: d,
                    numberOfSeconds: m,
                    numberOfMinutes: p,
                    numberOfHours: g,
                    numberOfDays: x,
                    numberOfMonths: v,
                    numberOfYears: k
                };
                switch (this.tickInterval) {
                case "years":
                    this.generateYearScale(C);
                    break;
                case "months":
                case "half_year":
                    this.generateMonthScale(C);
                    break;
                case "months_days":
                case "months_fortnight":
                case "days":
                case "week_days":
                    this.generateDayScale(C);
                    break;
                case "hours":
                    this.generateHourScale(C);
                    break;
                case "minutes_fives":
                case "minutes":
                    this.generateMinuteScale(C);
                    break;
                case "seconds_tens":
                case "seconds_fives":
                case "seconds":
                    this.generateSecondScale(C)
                }
                var h = this.timeScaleArray.map(function(u) {
                    var b = {
                        position: u.position,
                        unit: u.unit,
                        year: u.year,
                        day: u.day ? u.day : 1,
                        hour: u.hour ? u.hour : 0,
                        month: u.month + 1
                    };
                    return "month" === u.unit ? Z(Z({}, b), {}, {
                        day: 1,
                        value: u.value + 1
                    }) : "day" === u.unit || "hour" === u.unit ? Z(Z({}, b), {}, {
                        value: u.value
                    }) : "minute" === u.unit ? Z(Z({}, b), {}, {
                        value: u.value,
                        minute: u.value
                    }) : "second" === u.unit ? Z(Z({}, b), {}, {
                        value: u.value,
                        minute: u.minute,
                        second: u.second
                    }) : u
                });
                return h.filter(function(u) {
                    var b = 1
                      , w = Math.ceil(s.globals.gridWidth / 120)
                      , _ = u.value;
                    void 0 !== s.config.xaxis.tickAmount && (w = s.config.xaxis.tickAmount),
                    h.length > w && (b = Math.floor(h.length / w));
                    var X = !1
                      , I = !1;
                    switch (i.tickInterval) {
                    case "years":
                        "year" === u.unit && (X = !0);
                        break;
                    case "half_year":
                        b = 7,
                        "year" === u.unit && (X = !0);
                        break;
                    case "months":
                        b = 1,
                        "year" === u.unit && (X = !0);
                        break;
                    case "months_fortnight":
                        b = 15,
                        "year" !== u.unit && "month" !== u.unit || (X = !0),
                        30 === _ && (I = !0);
                        break;
                    case "months_days":
                        b = 10,
                        "month" === u.unit && (X = !0),
                        30 === _ && (I = !0);
                        break;
                    case "week_days":
                        b = 8,
                        "month" === u.unit && (X = !0);
                        break;
                    case "days":
                        b = 1,
                        "month" === u.unit && (X = !0);
                        break;
                    case "hours":
                        "day" === u.unit && (X = !0);
                        break;
                    case "minutes_fives":
                    case "seconds_fives":
                        _ % 5 != 0 && (I = !0);
                        break;
                    case "seconds_tens":
                        _ % 10 != 0 && (I = !0)
                    }
                    if ("hours" === i.tickInterval || "minutes_fives" === i.tickInterval || "seconds_tens" === i.tickInterval || "seconds_fives" === i.tickInterval) {
                        if (!I)
                            return !0
                    } else if ((_ % b == 0 || X) && !I)
                        return !0
                })
            }
        }, {
            key: "recalcDimensionsBasedOnFormat",
            value: function(e, t) {
                var i = this.w
                  , s = this.formatDates(e)
                  , a = this.removeOverlappingTS(s);
                i.globals.timescaleLabels = a.slice(),
                new xt(this.ctx).plotCoords()
            }
        }, {
            key: "determineInterval",
            value: function(e) {
                var t = 24 * e
                  , i = 60 * t;
                switch (!0) {
                case e / 365 > 5:
                    this.tickInterval = "years";
                    break;
                case e > 800:
                    this.tickInterval = "half_year";
                    break;
                case e > 180:
                    this.tickInterval = "months";
                    break;
                case e > 90:
                    this.tickInterval = "months_fortnight";
                    break;
                case e > 60:
                    this.tickInterval = "months_days";
                    break;
                case e > 30:
                    this.tickInterval = "week_days";
                    break;
                case e > 2:
                    this.tickInterval = "days";
                    break;
                case t > 2.4:
                    this.tickInterval = "hours";
                    break;
                case i > 15:
                    this.tickInterval = "minutes_fives";
                    break;
                case i > 5:
                    this.tickInterval = "minutes";
                    break;
                case i > 1:
                    this.tickInterval = "seconds_tens";
                    break;
                case 60 * i > 20:
                    this.tickInterval = "seconds_fives";
                    break;
                default:
                    this.tickInterval = "seconds"
                }
            }
        }, {
            key: "generateYearScale",
            value: function(e) {
                var t = e.firstVal
                  , i = e.currentMonth
                  , s = e.currentYear
                  , a = e.daysWidthOnXAxis
                  , r = e.numberOfYears
                  , n = t.minYear
                  , o = 0
                  , l = new ge(this.ctx)
                  , c = "year";
                if (t.minDate > 1 || t.minMonth > 0) {
                    var d = l.determineRemainingDaysOfYear(t.minYear, t.minMonth, t.minDate);
                    o = (l.determineDaysOfYear(t.minYear) - d + 1) * a,
                    this.timeScaleArray.push({
                        position: o,
                        value: n = t.minYear + 1,
                        unit: c,
                        year: n,
                        month: M.monthMod(i + 1)
                    })
                } else
                    1 === t.minDate && 0 === t.minMonth && this.timeScaleArray.push({
                        position: o,
                        value: n,
                        unit: c,
                        year: s,
                        month: M.monthMod(i + 1)
                    });
                for (var g = n, p = o, m = 0; m < r; m++)
                    g++,
                    p = l.determineDaysOfYear(g - 1) * a + p,
                    this.timeScaleArray.push({
                        position: p,
                        value: g,
                        unit: c,
                        year: g,
                        month: 1
                    })
            }
        }, {
            key: "generateMonthScale",
            value: function(e) {
                var t = e.firstVal
                  , i = e.currentMonthDate
                  , s = e.currentMonth
                  , a = e.currentYear
                  , r = e.daysWidthOnXAxis
                  , n = e.numberOfMonths
                  , o = s
                  , l = 0
                  , c = new ge(this.ctx)
                  , d = "month"
                  , g = 0;
                if (t.minDate > 1) {
                    l = (c.determineDaysOfMonths(s + 1, t.minYear) - i + 1) * r,
                    o = M.monthMod(s + 1);
                    var p = a + g
                      , m = M.monthMod(o)
                      , x = o;
                    0 === o && (d = "year",
                    x = p,
                    m = 1,
                    p += g += 1),
                    this.timeScaleArray.push({
                        position: l,
                        value: x,
                        unit: d,
                        year: p,
                        month: m
                    })
                } else
                    this.timeScaleArray.push({
                        position: l,
                        value: o,
                        unit: d,
                        year: a,
                        month: M.monthMod(s)
                    });
                for (var v = o + 1, k = l, S = 0, C = 1; S < n; S++,
                C++) {
                    0 === (v = M.monthMod(v)) ? (d = "year",
                    g += 1) : d = "month";
                    var h = this._getYear(a, v, g);
                    k = c.determineDaysOfMonths(v, h) * r + k,
                    this.timeScaleArray.push({
                        position: k,
                        value: 0 === v ? h : v,
                        unit: d,
                        year: h,
                        month: 0 === v ? 1 : v
                    }),
                    v++
                }
            }
        }, {
            key: "generateDayScale",
            value: function(e) {
                var t = e.firstVal
                  , i = e.currentMonth
                  , s = e.currentYear
                  , a = e.hoursWidthOnXAxis
                  , r = e.numberOfDays
                  , n = new ge(this.ctx)
                  , o = "day"
                  , l = t.minDate + 1
                  , c = l
                  , d = function(C, h, u) {
                    return C > n.determineDaysOfMonths(h + 1, u) && (c = 1,
                    o = "month",
                    p = h += 1),
                    h
                }
                  , g = (24 - t.minHour) * a
                  , p = l
                  , m = d(c, i, s);
                0 === t.minHour && 1 === t.minDate ? (g = 0,
                p = M.monthMod(t.minMonth),
                o = "month",
                c = t.minDate,
                r++) : 1 !== t.minDate && 0 === t.minHour && 0 === t.minMinute && (g = 0,
                p = l = t.minDate,
                m = d(c = l, i, s)),
                this.timeScaleArray.push({
                    position: g,
                    value: p,
                    unit: o,
                    year: this._getYear(s, m, 0),
                    month: M.monthMod(m),
                    day: c
                });
                for (var x = g, v = 0; v < r; v++) {
                    o = "day",
                    m = d(c += 1, m, this._getYear(s, m, 0));
                    var k = this._getYear(s, m, 0);
                    x = 24 * a + x;
                    var S = 1 === c ? M.monthMod(m) : c;
                    this.timeScaleArray.push({
                        position: x,
                        value: S,
                        unit: o,
                        year: k,
                        month: M.monthMod(m),
                        day: S
                    })
                }
            }
        }, {
            key: "generateHourScale",
            value: function(e) {
                var t = e.firstVal
                  , i = e.currentDate
                  , s = e.currentMonth
                  , a = e.currentYear
                  , r = e.minutesWidthOnXAxis
                  , n = e.numberOfHours
                  , o = new ge(this.ctx)
                  , l = "hour"
                  , d = function(b, w) {
                    return b > o.determineDaysOfMonths(w + 1, a) ? w += 1 : w
                }
                  , g = 60 - (t.minMinute + t.minSecond / 60)
                  , p = g * r
                  , m = t.minHour + 1
                  , x = m + 1;
                60 === g && (p = 0,
                x = (m = t.minHour) + 1);
                var b, w, v = i, k = d(v, s);
                this.timeScaleArray.push({
                    position: p,
                    value: m,
                    unit: l,
                    day: v,
                    hour: x,
                    year: a,
                    month: M.monthMod(k)
                });
                for (var S = p, C = 0; C < n; C++) {
                    l = "hour",
                    x >= 24 && (x = 0,
                    l = "day",
                    k = (b = v += 1,
                    w = k,
                    b > o.determineDaysOfMonths(w + 1, a) && (v = 1,
                    w += 1),
                    {
                        month: w,
                        date: v
                    }).month,
                    k = d(v, k));
                    var h = this._getYear(a, k, 0);
                    this.timeScaleArray.push({
                        position: S = 0 === x && 0 === C ? g * r : 60 * r + S,
                        value: 0 === x ? v : x,
                        unit: l,
                        hour: x,
                        day: v,
                        year: h,
                        month: M.monthMod(k)
                    }),
                    x++
                }
            }
        }, {
            key: "generateMinuteScale",
            value: function(e) {
                for (var l = e.minutesWidthOnXAxis, d = e.numberOfMinutes, g = e.currentMinute + 1, p = e.currentDate, m = e.currentMonth, x = e.currentYear, v = e.currentHour, k = (60 - e.currentSecond - e.currentMillisecond / 1e3) * e.secondsWidthOnXAxis, S = 0; S < d; S++)
                    g >= 60 && (g = 0,
                    24 === (v += 1) && (v = 0)),
                    this.timeScaleArray.push({
                        position: k,
                        value: g,
                        unit: "minute",
                        hour: v,
                        minute: g,
                        day: p,
                        year: this._getYear(x, m, 0),
                        month: M.monthMod(m)
                    }),
                    k += l,
                    g++
            }
        }, {
            key: "generateSecondScale",
            value: function(e) {
                for (var l = e.secondsWidthOnXAxis, c = e.numberOfSeconds, d = e.currentSecond + 1, g = e.currentMinute, p = e.currentDate, m = e.currentMonth, x = e.currentYear, v = e.currentHour, k = (1e3 - e.currentMillisecond) / 1e3 * l, S = 0; S < c; S++)
                    d >= 60 && (d = 0,
                    ++g >= 60 && (g = 0,
                    24 == ++v && (v = 0))),
                    this.timeScaleArray.push({
                        position: k,
                        value: d,
                        unit: "second",
                        hour: v,
                        minute: g,
                        second: d,
                        day: p,
                        year: this._getYear(x, m, 0),
                        month: M.monthMod(m)
                    }),
                    k += l,
                    d++
            }
        }, {
            key: "createRawDateString",
            value: function(e, t) {
                var i = e.year;
                return 0 === e.month && (e.month = 1),
                i += "-" + ("0" + e.month.toString()).slice(-2),
                i += "day" === e.unit ? "day" === e.unit ? "-" + ("0" + t).slice(-2) : "-01" : "-" + ("0" + (e.day ? e.day : "1")).slice(-2),
                i += "hour" === e.unit ? "hour" === e.unit ? "T" + ("0" + t).slice(-2) : "T00" : "T" + ("0" + (e.hour ? e.hour : "0")).slice(-2),
                i += "minute" === e.unit ? ":" + ("0" + t).slice(-2) : ":" + (e.minute ? ("0" + e.minute).slice(-2) : "00"),
                i += "second" === e.unit ? ":" + ("0" + t).slice(-2) : ":00",
                this.utc && (i += ".000Z"),
                i
            }
        }, {
            key: "formatDates",
            value: function(e) {
                var t = this
                  , i = this.w;
                return e.map(function(s) {
                    var a = s.value.toString()
                      , r = new ge(t.ctx)
                      , n = t.createRawDateString(s, a)
                      , o = r.getDate(r.parseDate(n));
                    if (t.utc || (o = r.getDate(r.parseDateWithTimezone(n))),
                    void 0 === i.config.xaxis.labels.format) {
                        var l = "dd MMM"
                          , c = i.config.xaxis.labels.datetimeFormatter;
                        "year" === s.unit && (l = c.year),
                        "month" === s.unit && (l = c.month),
                        "day" === s.unit && (l = c.day),
                        "hour" === s.unit && (l = c.hour),
                        "minute" === s.unit && (l = c.minute),
                        "second" === s.unit && (l = c.second),
                        a = r.formatDate(o, l)
                    } else
                        a = r.formatDate(o, i.config.xaxis.labels.format);
                    return {
                        dateString: n,
                        position: s.position,
                        value: a,
                        unit: s.unit,
                        year: s.year,
                        month: s.month
                    }
                })
            }
        }, {
            key: "removeOverlappingTS",
            value: function(e) {
                var t, i = this, s = new D(this.ctx), a = !1;
                e.length > 0 && e[0].value && e.every(function(o) {
                    return o.value.length === e[0].value.length
                }) && (a = !0,
                t = s.getTextRects(e[0].value).width);
                var r = 0;
                return e.map(function(o, l) {
                    if (l > 0 && i.w.config.xaxis.labels.hideOverlappingLabels) {
                        var c = a ? t : s.getTextRects(e[r].value).width;
                        return o.position > e[r].position + c + 10 ? (r = l,
                        o) : null
                    }
                    return o
                }).filter(function(o) {
                    return null !== o
                })
            }
        }, {
            key: "_getYear",
            value: function(e, t, i) {
                return e + Math.floor(t / 12) + i
            }
        }]),
        y
    }(), Q = function() {
        function y(e, t) {
            W(this, y),
            this.ctx = t,
            this.w = t.w,
            this.el = e
        }
        return V(y, [{
            key: "setupElements",
            value: function() {
                var e = this.w.globals
                  , t = this.w.config
                  , i = t.chart.type;
                e.axisCharts = ["line", "area", "bar", "rangeBar", "candlestick", "boxPlot", "scatter", "bubble", "radar", "heatmap", "treemap"].indexOf(i) > -1,
                e.xyCharts = ["line", "area", "bar", "rangeBar", "candlestick", "boxPlot", "scatter", "bubble"].indexOf(i) > -1,
                e.isBarHorizontal = ("bar" === t.chart.type || "rangeBar" === t.chart.type || "boxPlot" === t.chart.type) && t.plotOptions.bar.horizontal,
                e.chartClass = ".apexcharts" + e.chartID,
                e.dom.baseEl = this.el,
                e.dom.elWrap = document.createElement("div"),
                D.setAttrs(e.dom.elWrap, {
                    id: e.chartClass.substring(1),
                    class: "apexcharts-canvas " + e.chartClass.substring(1)
                }),
                this.el.appendChild(e.dom.elWrap),
                e.dom.Paper = new window.SVG.Doc(e.dom.elWrap),
                e.dom.Paper.attr({
                    class: "apexcharts-svg",
                    "xmlns:data": "ApexChartsNS",
                    transform: "translate(".concat(t.chart.offsetX, ", ").concat(t.chart.offsetY, ")")
                }),
                e.dom.Paper.node.style.background = t.chart.background,
                this.setSVGDimensions(),
                e.dom.elGraphical = e.dom.Paper.group().attr({
                    class: "apexcharts-inner apexcharts-graphical"
                }),
                e.dom.elAnnotations = e.dom.Paper.group().attr({
                    class: "apexcharts-annotations"
                }),
                e.dom.elDefs = e.dom.Paper.defs(),
                e.dom.elLegendWrap = document.createElement("div"),
                e.dom.elLegendWrap.classList.add("apexcharts-legend"),
                e.dom.elWrap.appendChild(e.dom.elLegendWrap),
                e.dom.Paper.add(e.dom.elGraphical),
                e.dom.elGraphical.add(e.dom.elDefs)
            }
        }, {
            key: "plotChartType",
            value: function(e, t) {
                var i = this.w
                  , s = i.config
                  , a = i.globals
                  , r = {
                    series: [],
                    i: []
                }
                  , n = {
                    series: [],
                    i: []
                }
                  , o = {
                    series: [],
                    i: []
                }
                  , l = {
                    series: [],
                    i: []
                }
                  , c = {
                    series: [],
                    i: []
                }
                  , d = {
                    series: [],
                    i: []
                }
                  , g = {
                    series: [],
                    i: []
                };
                a.series.map(function(u, b) {
                    var w = 0;
                    void 0 !== e[b].type ? ("column" === e[b].type || "bar" === e[b].type ? (a.series.length > 1 && s.plotOptions.bar.horizontal && console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"),
                    c.series.push(u),
                    c.i.push(b),
                    w++,
                    i.globals.columnSeries = c.series) : "area" === e[b].type ? (n.series.push(u),
                    n.i.push(b),
                    w++) : "line" === e[b].type ? (r.series.push(u),
                    r.i.push(b),
                    w++) : "scatter" === e[b].type ? (o.series.push(u),
                    o.i.push(b)) : "bubble" === e[b].type ? (l.series.push(u),
                    l.i.push(b),
                    w++) : "candlestick" === e[b].type ? (d.series.push(u),
                    d.i.push(b),
                    w++) : "boxPlot" === e[b].type ? (g.series.push(u),
                    g.i.push(b),
                    w++) : console.warn("You have specified an unrecognized chart type. Available types for this property are line/area/column/bar/scatter/bubble"),
                    w > 1 && (a.comboCharts = !0)) : (r.series.push(u),
                    r.i.push(b))
                });
                var p = new N(this.ctx,t)
                  , m = new Nt(this.ctx,t);
                this.ctx.pie = new T(this.ctx);
                var x = new O(this.ctx);
                this.ctx.rangeBar = new kt(this.ctx,t);
                var v = new z(this.ctx)
                  , k = [];
                if (a.comboCharts) {
                    if (n.series.length > 0 && k.push(p.draw(n.series, "area", n.i)),
                    c.series.length > 0)
                        if (i.config.chart.stacked) {
                            var S = new Ft(this.ctx,t);
                            k.push(S.draw(c.series, c.i))
                        } else
                            this.ctx.bar = new Je(this.ctx,t),
                            k.push(this.ctx.bar.draw(c.series, c.i));
                    if (r.series.length > 0 && k.push(p.draw(r.series, "line", r.i)),
                    d.series.length > 0 && k.push(m.draw(d.series, d.i)),
                    g.series.length > 0 && k.push(m.draw(g.series, g.i)),
                    o.series.length > 0) {
                        var C = new N(this.ctx,t,!0);
                        k.push(C.draw(o.series, "scatter", o.i))
                    }
                    if (l.series.length > 0) {
                        var h = new N(this.ctx,t,!0);
                        k.push(h.draw(l.series, "bubble", l.i))
                    }
                } else
                    switch (s.chart.type) {
                    case "line":
                        k = p.draw(a.series, "line");
                        break;
                    case "area":
                        k = p.draw(a.series, "area");
                        break;
                    case "bar":
                        s.chart.stacked ? k = new Ft(this.ctx,t).draw(a.series) : (this.ctx.bar = new Je(this.ctx,t),
                        k = this.ctx.bar.draw(a.series));
                        break;
                    case "candlestick":
                    case "boxPlot":
                        k = new Nt(this.ctx,t).draw(a.series);
                        break;
                    case "rangeBar":
                        k = this.ctx.rangeBar.draw(a.series);
                        break;
                    case "heatmap":
                        k = new ii(this.ctx,t).draw(a.series);
                        break;
                    case "treemap":
                        k = new U(this.ctx,t).draw(a.series);
                        break;
                    case "pie":
                    case "donut":
                    case "polarArea":
                        k = this.ctx.pie.draw(a.series);
                        break;
                    case "radialBar":
                        k = x.draw(a.series);
                        break;
                    case "radar":
                        k = v.draw(a.series);
                        break;
                    default:
                        k = p.draw(a.series)
                    }
                return k
            }
        }, {
            key: "setSVGDimensions",
            value: function() {
                var e = this.w.globals
                  , t = this.w.config;
                e.svgWidth = t.chart.width,
                e.svgHeight = t.chart.height;
                var i = M.getDimensions(this.el)
                  , s = t.chart.width.toString().split(/[0-9]+/g).pop();
                "%" === s ? M.isNumber(i[0]) && (0 === i[0].width && (i = M.getDimensions(this.el.parentNode)),
                e.svgWidth = i[0] * parseInt(t.chart.width, 10) / 100) : "px" !== s && "" !== s || (e.svgWidth = parseInt(t.chart.width, 10));
                var a = t.chart.height.toString().split(/[0-9]+/g).pop();
                if ("auto" !== e.svgHeight && "" !== e.svgHeight)
                    if ("%" === a) {
                        var r = M.getDimensions(this.el.parentNode);
                        e.svgHeight = r[1] * parseInt(t.chart.height, 10) / 100
                    } else
                        e.svgHeight = parseInt(t.chart.height, 10);
                else
                    e.svgHeight = e.axisCharts ? e.svgWidth / 1.61 : e.svgWidth / 1.2;
                e.svgWidth < 0 && (e.svgWidth = 0),
                e.svgHeight < 0 && (e.svgHeight = 0),
                D.setAttrs(e.dom.Paper.node, {
                    width: e.svgWidth,
                    height: e.svgHeight
                }),
                "%" !== a && (e.dom.Paper.node.parentNode.parentNode.style.minHeight = e.svgHeight + (t.chart.sparkline.enabled ? 0 : e.axisCharts ? t.chart.parentHeightOffset : 0) + "px"),
                e.dom.elWrap.style.width = e.svgWidth + "px",
                e.dom.elWrap.style.height = e.svgHeight + "px"
            }
        }, {
            key: "shiftGraphPosition",
            value: function() {
                var e = this.w.globals;
                D.setAttrs(e.dom.elGraphical.node, {
                    transform: "translate(" + e.translateX + ", " + e.translateY + ")"
                })
            }
        }, {
            key: "resizeNonAxisCharts",
            value: function() {
                var e = this.w
                  , t = e.globals
                  , i = 0
                  , s = e.config.chart.sparkline.enabled ? 1 : 15;
                s += e.config.grid.padding.bottom,
                "top" !== e.config.legend.position && "bottom" !== e.config.legend.position || !e.config.legend.show || e.config.legend.floating || (i = new Oe(this.ctx).legendHelpers.getLegendBBox().clwh + 10);
                var a = e.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie")
                  , r = 2.05 * e.globals.radialSize;
                if (a && !e.config.chart.sparkline.enabled && 0 !== e.config.plotOptions.radialBar.startAngle) {
                    var n = M.getBoundingClientRect(a);
                    r = n.bottom,
                    r = Math.max(2.05 * e.globals.radialSize, n.bottom - n.top)
                }
                var l = r + t.translateY + i + s;
                t.dom.elLegendForeign && t.dom.elLegendForeign.setAttribute("height", l),
                t.dom.elWrap.style.height = l + "px",
                D.setAttrs(t.dom.Paper.node, {
                    height: l
                }),
                t.dom.Paper.node.parentNode.parentNode.style.minHeight = l + "px"
            }
        }, {
            key: "coreCalculations",
            value: function() {
                new pt(this.ctx).init()
            }
        }, {
            key: "resetGlobals",
            value: function() {
                var e = this
                  , t = function() {
                    return e.w.config.series.map(function(a) {
                        return []
                    })
                }
                  , i = new At
                  , s = this.w.globals;
                i.initGlobalVars(s),
                s.seriesXvalues = t(),
                s.seriesYvalues = t()
            }
        }, {
            key: "isMultipleY",
            value: function() {
                if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1)
                    return this.w.globals.isMultipleYAxis = !0,
                    !0
            }
        }, {
            key: "xySettings",
            value: function() {
                var e = null
                  , t = this.w;
                if (t.globals.axisCharts) {
                    if ("back" === t.config.xaxis.crosshairs.position && new je(this.ctx).drawXCrosshairs(),
                    "back" === t.config.yaxis[0].crosshairs.position && new je(this.ctx).drawYCrosshairs(),
                    "datetime" === t.config.xaxis.type && void 0 === t.config.xaxis.labels.formatter) {
                        this.ctx.timeScale = new J(this.ctx);
                        var i = [];
                        isFinite(t.globals.minX) && isFinite(t.globals.maxX) && !t.globals.isBarHorizontal ? i = this.ctx.timeScale.calculateTimeScaleTicks(t.globals.minX, t.globals.maxX) : t.globals.isBarHorizontal && (i = this.ctx.timeScale.calculateTimeScaleTicks(t.globals.minY, t.globals.maxY)),
                        this.ctx.timeScale.recalcDimensionsBasedOnFormat(i)
                    }
                    e = new xe(this.ctx).getCalculatedRatios()
                }
                return e
            }
        }, {
            key: "updateSourceChart",
            value: function(e) {
                this.ctx.w.globals.selection = void 0,
                this.ctx.updateHelpers._updateOptions({
                    chart: {
                        selection: {
                            xaxis: {
                                min: e.w.globals.minX,
                                max: e.w.globals.maxX
                            }
                        }
                    }
                }, !1, !1)
            }
        }, {
            key: "setupBrushHandler",
            value: function() {
                var e = this
                  , t = this.w;
                if (t.config.chart.brush.enabled && "function" != typeof t.config.chart.events.selection) {
                    var i = t.config.chart.brush.targets || [t.config.chart.brush.target];
                    i.forEach(function(s) {
                        var a = ApexCharts.getChartByID(s);
                        a.w.globals.brushSource = e.ctx,
                        "function" != typeof a.w.config.chart.events.zoomed && (a.w.config.chart.events.zoomed = function() {
                            e.updateSourceChart(a)
                        }
                        ),
                        "function" != typeof a.w.config.chart.events.scrolled && (a.w.config.chart.events.scrolled = function() {
                            e.updateSourceChart(a)
                        }
                        )
                    }),
                    t.config.chart.events.selection = function(s, a) {
                        i.forEach(function(r) {
                            var n = ApexCharts.getChartByID(r)
                              , o = M.clone(t.config.yaxis);
                            if (t.config.chart.brush.autoScaleYaxis && 1 === n.w.globals.series.length) {
                                var l = new Be(n);
                                o = l.autoScaleY(n, o, a)
                            }
                            var c = n.w.config.yaxis.reduce(function(d, g, p) {
                                return [].concat(pe(d), [Z(Z({}, n.w.config.yaxis[p]), {}, {
                                    min: o[0].min,
                                    max: o[0].max
                                })])
                            }, []);
                            n.ctx.updateHelpers._updateOptions({
                                xaxis: {
                                    min: a.xaxis.min,
                                    max: a.xaxis.max
                                },
                                yaxis: c
                            }, !1, !1, !1, !1)
                        })
                    }
                }
            }
        }]),
        y
    }(), le = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w
        }
        return V(y, [{
            key: "_updateOptions",
            value: function(e) {
                var t = this
                  , i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
                  , s = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
                  , a = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3]
                  , r = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
                return new Promise(function(n) {
                    var o = [t.ctx];
                    a && (o = t.ctx.getSyncedCharts()),
                    t.ctx.w.globals.isExecCalled && (o = [t.ctx],
                    t.ctx.w.globals.isExecCalled = !1),
                    o.forEach(function(l, c) {
                        var d = l.w;
                        return d.globals.shouldAnimate = s,
                        i || (d.globals.resized = !0,
                        d.globals.dataChanged = !0,
                        s && l.series.getPreviousPaths()),
                        e && "object" === de(e) && (l.config = new F(e),
                        e = xe.extendArrayProps(l.config, e, d),
                        l.w.globals.chartID !== t.ctx.w.globals.chartID && delete e.series,
                        d.config = M.extend(d.config, e),
                        r && (d.globals.lastXAxis = e.xaxis ? M.clone(e.xaxis) : [],
                        d.globals.lastYAxis = e.yaxis ? M.clone(e.yaxis) : [],
                        d.globals.initialConfig = M.extend({}, d.config),
                        d.globals.initialSeries = M.clone(d.config.series))),
                        l.update(e).then(function() {
                            c === o.length - 1 && n(l)
                        })
                    })
                }
                )
            }
        }, {
            key: "_updateSeries",
            value: function(e, t) {
                var i = this
                  , s = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                return new Promise(function(a) {
                    var r, n = i.w;
                    return n.globals.shouldAnimate = t,
                    n.globals.dataChanged = !0,
                    t && i.ctx.series.getPreviousPaths(),
                    n.globals.axisCharts ? (0 === (r = e.map(function(o, l) {
                        return i._extendSeries(o, l)
                    })).length && (r = [{
                        data: []
                    }]),
                    n.config.series = r) : n.config.series = e.slice(),
                    s && (n.globals.initialSeries = M.clone(n.config.series)),
                    i.ctx.update().then(function() {
                        a(i.ctx)
                    })
                }
                )
            }
        }, {
            key: "_extendSeries",
            value: function(e, t) {
                var i = this.w
                  , s = i.config.series[t];
                return Z(Z({}, i.config.series[t]), {}, {
                    name: e.name ? e.name : s && s.name,
                    color: e.color ? e.color : s && s.color,
                    type: e.type ? e.type : s && s.type,
                    data: e.data ? e.data : s && s.data
                })
            }
        }, {
            key: "toggleDataPointSelection",
            value: function(e, t) {
                var i = this.w
                  , s = null
                  , a = ".apexcharts-series[data\\:realIndex='".concat(e, "']");
                return i.globals.axisCharts ? s = i.globals.dom.Paper.select("".concat(a, " path[j='").concat(t, "'], ").concat(a, " circle[j='").concat(t, "'], ").concat(a, " rect[j='").concat(t, "']")).members[0] : void 0 === t && (s = i.globals.dom.Paper.select("".concat(a, " path[j='").concat(e, "']")).members[0],
                "pie" !== i.config.chart.type && "polarArea" !== i.config.chart.type && "donut" !== i.config.chart.type || this.ctx.pie.pieClicked(e)),
                s ? (new D(this.ctx).pathMouseDown(s, null),
                s.node ? s.node : null) : (console.warn("toggleDataPointSelection: Element not found"),
                null)
            }
        }, {
            key: "forceXAxisUpdate",
            value: function(e) {
                var t = this.w;
                if (["min", "max"].forEach(function(s) {
                    void 0 !== e.xaxis[s] && (t.config.xaxis[s] = e.xaxis[s],
                    t.globals.lastXAxis[s] = e.xaxis[s])
                }),
                e.xaxis.categories && e.xaxis.categories.length && (t.config.xaxis.categories = e.xaxis.categories),
                t.config.xaxis.convertedCatToNumeric) {
                    var i = new it(e);
                    e = i.convertCatToNumericXaxis(e, this.ctx)
                }
                return e
            }
        }, {
            key: "forceYAxisUpdate",
            value: function(e) {
                var t = this.w;
                return t.config.chart.stacked && "100%" === t.config.chart.stackType && (Array.isArray(e.yaxis) ? e.yaxis.forEach(function(i, s) {
                    e.yaxis[s].min = 0,
                    e.yaxis[s].max = 100
                }) : (e.yaxis.min = 0,
                e.yaxis.max = 100)),
                e
            }
        }, {
            key: "revertDefaultAxisMinMax",
            value: function(e) {
                var t = this
                  , i = this.w
                  , s = i.globals.lastXAxis
                  , a = i.globals.lastYAxis;
                e && e.xaxis && (s = e.xaxis),
                e && e.yaxis && (a = e.yaxis),
                i.config.xaxis.min = s.min,
                i.config.xaxis.max = s.max,
                i.config.yaxis.map(function(n, o) {
                    i.globals.zoomed || void 0 !== a[o] ? function(n) {
                        void 0 !== a[n] && (i.config.yaxis[n].min = a[n].min,
                        i.config.yaxis[n].max = a[n].max)
                    }(o) : void 0 !== t.ctx.opts.yaxis[o] && (n.min = t.ctx.opts.yaxis[o].min,
                    n.max = t.ctx.opts.yaxis[o].max)
                })
            }
        }]),
        y
    }();
    j = typeof window < "u" ? window : void 0,
    B = function(y, e) {
        var t = (void 0 !== this ? this : y).SVG = function(h) {
            if (t.supported)
                return h = new t.Doc(h),
                t.parser.draw || t.prepare(),
                h
        }
        ;
        if (t.ns = "http://www.w3.org/2000/svg",
        t.xmlns = "http://www.w3.org/2000/xmlns/",
        t.xlink = "http://www.w3.org/1999/xlink",
        t.svgjs = "http://svgjs.dev",
        t.supported = !0,
        !t.supported)
            return !1;
        t.did = 1e3,
        t.eid = function(h) {
            return "Svgjs" + c(h) + t.did++
        }
        ,
        t.create = function(h) {
            var u = e.createElementNS(this.ns, h);
            return u.setAttribute("id", this.eid(h)),
            u
        }
        ,
        t.extend = function() {
            var h, u;
            u = (h = [].slice.call(arguments)).pop();
            for (var b = h.length - 1; b >= 0; b--)
                if (h[b])
                    for (var w in u)
                        h[b].prototype[w] = u[w];
            t.Set && t.Set.inherit && t.Set.inherit()
        }
        ,
        t.invent = function(h) {
            var u = "function" == typeof h.create ? h.create : function() {
                this.constructor.call(this, t.create(h.create))
            }
            ;
            return h.inherit && (u.prototype = new h.inherit),
            h.extend && t.extend(u, h.extend),
            h.construct && t.extend(h.parent || t.Container, h.construct),
            u
        }
        ,
        t.adopt = function(h) {
            return h ? h.instance ? h.instance : ((u = "svg" == h.nodeName ? h.parentNode instanceof y.SVGElement ? new t.Nested : new t.Doc : "linearGradient" == h.nodeName ? new t.Gradient("linear") : "radialGradient" == h.nodeName ? new t.Gradient("radial") : t[c(h.nodeName)] ? new (t[c(h.nodeName)]) : new t.Element(h)).type = h.nodeName,
            u.node = h,
            h.instance = u,
            u instanceof t.Doc && u.namespace().defs(),
            u.setData(JSON.parse(h.getAttribute("svgjs:data")) || {}),
            u) : null;
            var u
        }
        ,
        t.prepare = function() {
            var h = e.getElementsByTagName("body")[0]
              , u = (h ? new t.Doc(h) : t.adopt(e.documentElement).nested()).size(2, 0);
            t.parser = {
                body: h || e.documentElement,
                draw: u.style("opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden").node,
                poly: u.polyline().node,
                path: u.path().node,
                native: t.create("svg")
            }
        }
        ,
        t.parser = {
            native: t.create("svg")
        },
        e.addEventListener("DOMContentLoaded", function() {
            t.parser.draw || t.prepare()
        }, !1),
        t.regex = {
            numberAndUnit: /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i,
            hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
            rgb: /rgb\((\d+),(\d+),(\d+)\)/,
            reference: /#([a-z0-9\-_]+)/i,
            transforms: /\)\s*,?\s*/,
            whitespace: /\s/g,
            isHex: /^#[a-f0-9]{3,6}$/i,
            isRgb: /^rgb\(/,
            isCss: /[^:]+:[^;]+;?/,
            isBlank: /^(\s+)?$/,
            isNumber: /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
            isPercent: /^-?[\d\.]+%$/,
            isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i,
            delimiter: /[\s,]+/,
            hyphen: /([^e])\-/gi,
            pathLetters: /[MLHVCSQTAZ]/gi,
            isPathLetter: /[MLHVCSQTAZ]/i,
            numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi,
            dots: /\./g
        },
        t.utils = {
            map: function(h, u) {
                for (var b = h.length, w = [], _ = 0; _ < b; _++)
                    w.push(u(h[_]));
                return w
            },
            filter: function(h, u) {
                for (var b = h.length, w = [], _ = 0; _ < b; _++)
                    u(h[_]) && w.push(h[_]);
                return w
            },
            filterSVGElements: function(h) {
                return this.filter(h, function(u) {
                    return u instanceof y.SVGElement
                })
            }
        },
        t.defaults = {
            attrs: {
                "fill-opacity": 1,
                "stroke-opacity": 1,
                "stroke-width": 0,
                "stroke-linejoin": "miter",
                "stroke-linecap": "butt",
                fill: "#000000",
                stroke: "#000000",
                opacity: 1,
                x: 0,
                y: 0,
                cx: 0,
                cy: 0,
                width: 0,
                height: 0,
                r: 0,
                rx: 0,
                ry: 0,
                offset: 0,
                "stop-opacity": 1,
                "stop-color": "#000000",
                "font-size": 16,
                "font-family": "Helvetica, Arial, sans-serif",
                "text-anchor": "start"
            }
        },
        t.Color = function(h) {
            var u, b;
            this.r = 0,
            this.g = 0,
            this.b = 0,
            h && ("string" == typeof h ? t.regex.isRgb.test(h) ? (u = t.regex.rgb.exec(h.replace(t.regex.whitespace, "")),
            this.r = parseInt(u[1]),
            this.g = parseInt(u[2]),
            this.b = parseInt(u[3])) : t.regex.isHex.test(h) && (u = t.regex.hex.exec(4 == (b = h).length ? ["#", b.substring(1, 2), b.substring(1, 2), b.substring(2, 3), b.substring(2, 3), b.substring(3, 4), b.substring(3, 4)].join("") : b),
            this.r = parseInt(u[1], 16),
            this.g = parseInt(u[2], 16),
            this.b = parseInt(u[3], 16)) : "object" === de(h) && (this.r = h.r,
            this.g = h.g,
            this.b = h.b))
        }
        ,
        t.extend(t.Color, {
            toString: function() {
                return this.toHex()
            },
            toHex: function() {
                return "#" + d(this.r) + d(this.g) + d(this.b)
            },
            toRgb: function() {
                return "rgb(" + [this.r, this.g, this.b].join() + ")"
            },
            brightness: function() {
                return this.r / 255 * .3 + this.g / 255 * .59 + this.b / 255 * .11
            },
            morph: function(h) {
                return this.destination = new t.Color(h),
                this
            },
            at: function(h) {
                return this.destination ? new t.Color({
                    r: ~~(this.r + (this.destination.r - this.r) * (h = h < 0 ? 0 : h > 1 ? 1 : h)),
                    g: ~~(this.g + (this.destination.g - this.g) * h),
                    b: ~~(this.b + (this.destination.b - this.b) * h)
                }) : this
            }
        }),
        t.Color.test = function(h) {
            return t.regex.isHex.test(h += "") || t.regex.isRgb.test(h)
        }
        ,
        t.Color.isRgb = function(h) {
            return h && "number" == typeof h.r && "number" == typeof h.g && "number" == typeof h.b
        }
        ,
        t.Color.isColor = function(h) {
            return t.Color.isRgb(h) || t.Color.test(h)
        }
        ,
        t.Array = function(h, u) {
            0 == (h = (h || []).valueOf()).length && u && (h = u.valueOf()),
            this.value = this.parse(h)
        }
        ,
        t.extend(t.Array, {
            toString: function() {
                return this.value.join(" ")
            },
            valueOf: function() {
                return this.value
            },
            parse: function(h) {
                return h = h.valueOf(),
                Array.isArray(h) ? h : this.split(h)
            }
        }),
        t.PointArray = function(h, u) {
            t.Array.call(this, h, u || [[0, 0]])
        }
        ,
        t.PointArray.prototype = new t.Array,
        t.PointArray.prototype.constructor = t.PointArray;
        for (var i = {
            M: function(h, u, b) {
                return u.x = b.x = h[0],
                u.y = b.y = h[1],
                ["M", u.x, u.y]
            },
            L: function(h, u) {
                return u.x = h[0],
                u.y = h[1],
                ["L", h[0], h[1]]
            },
            H: function(h, u) {
                return u.x = h[0],
                ["H", h[0]]
            },
            V: function(h, u) {
                return u.y = h[0],
                ["V", h[0]]
            },
            C: function(h, u) {
                return u.x = h[4],
                u.y = h[5],
                ["C", h[0], h[1], h[2], h[3], h[4], h[5]]
            },
            Q: function(h, u) {
                return u.x = h[2],
                u.y = h[3],
                ["Q", h[0], h[1], h[2], h[3]]
            },
            Z: function(h, u, b) {
                return u.x = b.x,
                u.y = b.y,
                ["Z"]
            }
        }, s = "mlhvqtcsaz".split(""), a = 0, r = s.length; a < r; ++a)
            i[s[a]] = function(h) {
                return function(u, b, w) {
                    if ("H" == h)
                        u[0] = u[0] + b.x;
                    else if ("V" == h)
                        u[0] = u[0] + b.y;
                    else if ("A" == h)
                        u[5] = u[5] + b.x,
                        u[6] = u[6] + b.y;
                    else
                        for (var _ = 0, X = u.length; _ < X; ++_)
                            u[_] = u[_] + (_ % 2 ? b.y : b.x);
                    if (i && "function" == typeof i[h])
                        return i[h](u, b, w)
                }
            }(s[a].toUpperCase());
        t.PathArray = function(h, u) {
            t.Array.call(this, h, u || [["M", 0, 0]])
        }
        ,
        t.PathArray.prototype = new t.Array,
        t.PathArray.prototype.constructor = t.PathArray,
        t.extend(t.PathArray, {
            toString: function() {
                return function(h) {
                    for (var u = 0, b = h.length, w = ""; u < b; u++)
                        w += h[u][0],
                        null != h[u][1] && (w += h[u][1],
                        null != h[u][2] && (w += " ",
                        w += h[u][2],
                        null != h[u][3] && (w += " ",
                        w += h[u][3],
                        w += " ",
                        w += h[u][4],
                        null != h[u][5] && (w += " ",
                        w += h[u][5],
                        w += " ",
                        w += h[u][6],
                        null != h[u][7] && (w += " ",
                        w += h[u][7])))));
                    return w + " "
                }(this.value)
            },
            move: function(h, u) {
                return this.bbox(),
                this
            },
            at: function(h) {
                if (!this.destination)
                    return this;
                for (var u = this.value, b = this.destination.value, w = [], _ = new t.PathArray, X = 0, I = u.length; X < I; X++) {
                    w[X] = [u[X][0]];
                    for (var R = 1, H = u[X].length; R < H; R++)
                        w[X][R] = u[X][R] + (b[X][R] - u[X][R]) * h;
                    "A" === w[X][0] && (w[X][4] = +(0 != w[X][4]),
                    w[X][5] = +(0 != w[X][5]))
                }
                return _.value = w,
                _
            },
            parse: function(h) {
                if (h instanceof t.PathArray)
                    return h.valueOf();
                var u, b = {
                    M: 2,
                    L: 2,
                    H: 1,
                    V: 1,
                    C: 6,
                    S: 4,
                    Q: 4,
                    T: 2,
                    A: 7,
                    Z: 0
                };
                h = "string" == typeof h ? h.replace(t.regex.numbersWithDots, o).replace(t.regex.pathLetters, " $& ").replace(t.regex.hyphen, "$1 -").trim().split(t.regex.delimiter) : h.reduce(function(H, G) {
                    return [].concat.call(H, G)
                }, []);
                var w = []
                  , _ = new t.Point
                  , X = new t.Point
                  , I = 0
                  , R = h.length;
                do {
                    t.regex.isPathLetter.test(h[I]) ? (u = h[I],
                    ++I) : "M" == u ? u = "L" : "m" == u && (u = "l"),
                    w.push(i[u].call(null, h.slice(I, I += b[u.toUpperCase()]).map(parseFloat), _, X))
                } while (R > I);
                return w
            },
            bbox: function() {
                return t.parser.draw || t.prepare(),
                t.parser.path.setAttribute("d", this.toString()),
                t.parser.path.getBBox()
            }
        }),
        t.Number = t.invent({
            create: function(h, u) {
                this.value = 0,
                this.unit = u || "",
                "number" == typeof h ? this.value = isNaN(h) ? 0 : isFinite(h) ? h : h < 0 ? -34e37 : 34e37 : "string" == typeof h ? (u = h.match(t.regex.numberAndUnit)) && (this.value = parseFloat(u[1]),
                "%" == u[5] ? this.value /= 100 : "s" == u[5] && (this.value *= 1e3),
                this.unit = u[5]) : h instanceof t.Number && (this.value = h.valueOf(),
                this.unit = h.unit)
            },
            extend: {
                toString: function() {
                    return ("%" == this.unit ? ~~(1e8 * this.value) / 1e6 : "s" == this.unit ? this.value / 1e3 : this.value) + this.unit
                },
                toJSON: function() {
                    return this.toString()
                },
                valueOf: function() {
                    return this.value
                },
                plus: function(h) {
                    return h = new t.Number(h),
                    new t.Number(this + h,this.unit || h.unit)
                },
                minus: function(h) {
                    return h = new t.Number(h),
                    new t.Number(this - h,this.unit || h.unit)
                },
                times: function(h) {
                    return h = new t.Number(h),
                    new t.Number(this * h,this.unit || h.unit)
                },
                divide: function(h) {
                    return h = new t.Number(h),
                    new t.Number(this / h,this.unit || h.unit)
                },
                to: function(h) {
                    var u = new t.Number(this);
                    return "string" == typeof h && (u.unit = h),
                    u
                },
                morph: function(h) {
                    return this.destination = new t.Number(h),
                    h.relative && (this.destination.value += this.value),
                    this
                },
                at: function(h) {
                    return this.destination ? new t.Number(this.destination).minus(this).times(h).plus(this) : this
                }
            }
        }),
        t.Element = t.invent({
            create: function(h) {
                this._stroke = t.defaults.attrs.stroke,
                this._event = null,
                this.dom = {},
                (this.node = h) && (this.type = h.nodeName,
                this.node.instance = this,
                this._stroke = h.getAttribute("stroke") || this._stroke)
            },
            extend: {
                x: function(h) {
                    return this.attr("x", h)
                },
                y: function(h) {
                    return this.attr("y", h)
                },
                cx: function(h) {
                    return null == h ? this.x() + this.width() / 2 : this.x(h - this.width() / 2)
                },
                cy: function(h) {
                    return null == h ? this.y() + this.height() / 2 : this.y(h - this.height() / 2)
                },
                move: function(h, u) {
                    return this.x(h).y(u)
                },
                center: function(h, u) {
                    return this.cx(h).cy(u)
                },
                width: function(h) {
                    return this.attr("width", h)
                },
                height: function(h) {
                    return this.attr("height", h)
                },
                size: function(h, u) {
                    var b = g(this, h, u);
                    return this.width(new t.Number(b.width)).height(new t.Number(b.height))
                },
                clone: function(h) {
                    this.writeDataToDom();
                    var u = x(this.node.cloneNode(!0));
                    return h ? h.add(u) : this.after(u),
                    u
                },
                remove: function() {
                    return this.parent() && this.parent().removeElement(this),
                    this
                },
                replace: function(h) {
                    return this.after(h).remove(),
                    h
                },
                addTo: function(h) {
                    return h.put(this)
                },
                putIn: function(h) {
                    return h.add(this)
                },
                id: function(h) {
                    return this.attr("id", h)
                },
                show: function() {
                    return this.style("display", "")
                },
                hide: function() {
                    return this.style("display", "none")
                },
                visible: function() {
                    return "none" != this.style("display")
                },
                toString: function() {
                    return this.attr("id")
                },
                classes: function() {
                    var h = this.attr("class");
                    return null == h ? [] : h.trim().split(t.regex.delimiter)
                },
                hasClass: function(h) {
                    return -1 != this.classes().indexOf(h)
                },
                addClass: function(h) {
                    if (!this.hasClass(h)) {
                        var u = this.classes();
                        u.push(h),
                        this.attr("class", u.join(" "))
                    }
                    return this
                },
                removeClass: function(h) {
                    return this.hasClass(h) && this.attr("class", this.classes().filter(function(u) {
                        return u != h
                    }).join(" ")),
                    this
                },
                toggleClass: function(h) {
                    return this.hasClass(h) ? this.removeClass(h) : this.addClass(h)
                },
                reference: function(h) {
                    return t.get(this.attr(h))
                },
                parent: function(h) {
                    var u = this;
                    if (!u.node.parentNode)
                        return null;
                    if (u = t.adopt(u.node.parentNode),
                    !h)
                        return u;
                    for (; u && u.node instanceof y.SVGElement; ) {
                        if ("string" == typeof h ? u.matches(h) : u instanceof h)
                            return u;
                        if (!u.node.parentNode || "#document" == u.node.parentNode.nodeName)
                            return null;
                        u = t.adopt(u.node.parentNode)
                    }
                },
                doc: function() {
                    return this instanceof t.Doc ? this : this.parent(t.Doc)
                },
                parents: function(h) {
                    var u = []
                      , b = this;
                    do {
                        if (!(b = b.parent(h)) || !b.node)
                            break;
                        u.push(b)
                    } while (b.parent);
                    return u
                },
                matches: function(h) {
                    return ((u = this.node).matches || u.matchesSelector || u.msMatchesSelector || u.mozMatchesSelector || u.webkitMatchesSelector || u.oMatchesSelector).call(u, h);
                    var u
                },
                native: function() {
                    return this.node
                },
                svg: function(h) {
                    var u = e.createElement("svg");
                    if (!(h && this instanceof t.Parent))
                        return u.appendChild(h = e.createElement("svg")),
                        this.writeDataToDom(),
                        h.appendChild(this.node.cloneNode(!0)),
                        u.innerHTML.replace(/^<svg>/, "").replace(/<\/svg>$/, "");
                    u.innerHTML = "<svg>" + h.replace(/\n/, "").replace(/<([\w:-]+)([^<]+?)\/>/g, "<$1$2></$1>") + "</svg>";
                    for (var b = 0, w = u.firstChild.childNodes.length; b < w; b++)
                        this.node.appendChild(u.firstChild.firstChild);
                    return this
                },
                writeDataToDom: function() {
                    return (this.each || this.lines) && (this.each ? this : this.lines()).each(function() {
                        this.writeDataToDom()
                    }),
                    this.node.removeAttribute("svgjs:data"),
                    Object.keys(this.dom).length && this.node.setAttribute("svgjs:data", JSON.stringify(this.dom)),
                    this
                },
                setData: function(h) {
                    return this.dom = h,
                    this
                },
                is: function(h) {
                    return this instanceof h
                }
            }
        }),
        t.easing = {
            "-": function(h) {
                return h
            },
            "<>": function(h) {
                return -Math.cos(h * Math.PI) / 2 + .5
            },
            ">": function(h) {
                return Math.sin(h * Math.PI / 2)
            },
            "<": function(h) {
                return 1 - Math.cos(h * Math.PI / 2)
            }
        },
        t.morph = function(h) {
            return function(u, b) {
                return new t.MorphObj(u,b).at(h)
            }
        }
        ,
        t.Situation = t.invent({
            create: function(h) {
                this.init = !1,
                this.reversed = !1,
                this.reversing = !1,
                this.duration = new t.Number(h.duration).valueOf(),
                this.delay = new t.Number(h.delay).valueOf(),
                this.start = +new Date + this.delay,
                this.finish = this.start + this.duration,
                this.ease = h.ease,
                this.loop = 0,
                this.loops = !1,
                this.animations = {},
                this.attrs = {},
                this.styles = {},
                this.transforms = [],
                this.once = {}
            }
        }),
        t.FX = t.invent({
            create: function(h) {
                this._target = h,
                this.situations = [],
                this.active = !1,
                this.situation = null,
                this.paused = !1,
                this.lastPos = 0,
                this.pos = 0,
                this.absPos = 0,
                this._speed = 1
            },
            extend: {
                animate: function(h, u, b) {
                    "object" === de(h) && (u = h.ease,
                    b = h.delay,
                    h = h.duration);
                    var w = new t.Situation({
                        duration: h || 1e3,
                        delay: b || 0,
                        ease: t.easing[u || "-"] || u
                    });
                    return this.queue(w),
                    this
                },
                target: function(h) {
                    return h && h instanceof t.Element ? (this._target = h,
                    this) : this._target
                },
                timeToAbsPos: function(h) {
                    return (h - this.situation.start) / (this.situation.duration / this._speed)
                },
                absPosToTime: function(h) {
                    return this.situation.duration / this._speed * h + this.situation.start
                },
                startAnimFrame: function() {
                    this.stopAnimFrame(),
                    this.animationFrame = y.requestAnimationFrame(function() {
                        this.step()
                    }
                    .bind(this))
                },
                stopAnimFrame: function() {
                    y.cancelAnimationFrame(this.animationFrame)
                },
                start: function() {
                    return !this.active && this.situation && (this.active = !0,
                    this.startCurrent()),
                    this
                },
                startCurrent: function() {
                    return this.situation.start = +new Date + this.situation.delay / this._speed,
                    this.situation.finish = this.situation.start + this.situation.duration / this._speed,
                    this.initAnimations().step()
                },
                queue: function(h) {
                    return ("function" == typeof h || h instanceof t.Situation) && this.situations.push(h),
                    this.situation || (this.situation = this.situations.shift()),
                    this
                },
                dequeue: function() {
                    return this.stop(),
                    this.situation = this.situations.shift(),
                    this.situation && (this.situation instanceof t.Situation ? this.start() : this.situation.call(this)),
                    this
                },
                initAnimations: function() {
                    var h, u = this.situation;
                    if (u.init)
                        return this;
                    for (var b in u.animations) {
                        h = this.target()[b](),
                        Array.isArray(h) || (h = [h]),
                        Array.isArray(u.animations[b]) || (u.animations[b] = [u.animations[b]]);
                        for (var w = h.length; w--; )
                            u.animations[b][w]instanceof t.Number && (h[w] = new t.Number(h[w])),
                            u.animations[b][w] = h[w].morph(u.animations[b][w])
                    }
                    for (var b in u.attrs)
                        u.attrs[b] = new t.MorphObj(this.target().attr(b),u.attrs[b]);
                    for (var b in u.styles)
                        u.styles[b] = new t.MorphObj(this.target().style(b),u.styles[b]);
                    return u.initialTransformation = this.target().matrixify(),
                    u.init = !0,
                    this
                },
                clearQueue: function() {
                    return this.situations = [],
                    this
                },
                clearCurrent: function() {
                    return this.situation = null,
                    this
                },
                stop: function(h, u) {
                    var b = this.active;
                    return this.active = !1,
                    u && this.clearQueue(),
                    h && this.situation && (!b && this.startCurrent(),
                    this.atEnd()),
                    this.stopAnimFrame(),
                    this.clearCurrent()
                },
                after: function(h) {
                    var u = this.last();
                    return this.target().on("finished.fx", function b(w) {
                        w.detail.situation == u && (h.call(this, u),
                        this.off("finished.fx", b))
                    }),
                    this._callStart()
                },
                during: function(h) {
                    var u = this.last()
                      , b = function(w) {
                        w.detail.situation == u && h.call(this, w.detail.pos, t.morph(w.detail.pos), w.detail.eased, u)
                    };
                    return this.target().off("during.fx", b).on("during.fx", b),
                    this.after(function() {
                        this.off("during.fx", b)
                    }),
                    this._callStart()
                },
                afterAll: function(h) {
                    var u = function b(w) {
                        h.call(this),
                        this.off("allfinished.fx", b)
                    };
                    return this.target().off("allfinished.fx", u).on("allfinished.fx", u),
                    this._callStart()
                },
                last: function() {
                    return this.situations.length ? this.situations[this.situations.length - 1] : this.situation
                },
                add: function(h, u, b) {
                    return this.last()[b || "animations"][h] = u,
                    this._callStart()
                },
                step: function(h) {
                    var u, b, w;
                    h || (this.absPos = this.timeToAbsPos(+new Date)),
                    !1 !== this.situation.loops ? (u = Math.max(this.absPos, 0),
                    b = Math.floor(u),
                    !0 === this.situation.loops || b < this.situation.loops ? (this.pos = u - b,
                    w = this.situation.loop,
                    this.situation.loop = b) : (this.absPos = this.situation.loops,
                    this.pos = 1,
                    w = this.situation.loop - 1,
                    this.situation.loop = this.situation.loops),
                    this.situation.reversing && (this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - w) % 2))) : (this.absPos = Math.min(this.absPos, 1),
                    this.pos = this.absPos),
                    this.pos < 0 && (this.pos = 0),
                    this.situation.reversed && (this.pos = 1 - this.pos);
                    var _ = this.situation.ease(this.pos);
                    for (var X in this.situation.once)
                        X > this.lastPos && X <= _ && (this.situation.once[X].call(this.target(), this.pos, _),
                        delete this.situation.once[X]);
                    return this.active && this.target().fire("during", {
                        pos: this.pos,
                        eased: _,
                        fx: this,
                        situation: this.situation
                    }),
                    this.situation ? (this.eachAt(),
                    1 == this.pos && !this.situation.reversed || this.situation.reversed && 0 == this.pos ? (this.stopAnimFrame(),
                    this.target().fire("finished", {
                        fx: this,
                        situation: this.situation
                    }),
                    this.situations.length || (this.target().fire("allfinished"),
                    this.situations.length || (this.target().off(".fx"),
                    this.active = !1)),
                    this.active ? this.dequeue() : this.clearCurrent()) : !this.paused && this.active && this.startAnimFrame(),
                    this.lastPos = _,
                    this) : this
                },
                eachAt: function() {
                    var h, u = this, b = this.target(), w = this.situation;
                    for (var _ in w.animations)
                        h = [].concat(w.animations[_]).map(function(R) {
                            return "string" != typeof R && R.at ? R.at(w.ease(u.pos), u.pos) : R
                        }),
                        b[_].apply(b, h);
                    for (var _ in w.attrs)
                        h = [_].concat(w.attrs[_]).map(function(H) {
                            return "string" != typeof H && H.at ? H.at(w.ease(u.pos), u.pos) : H
                        }),
                        b.attr.apply(b, h);
                    for (var _ in w.styles)
                        h = [_].concat(w.styles[_]).map(function(H) {
                            return "string" != typeof H && H.at ? H.at(w.ease(u.pos), u.pos) : H
                        }),
                        b.style.apply(b, h);
                    if (w.transforms.length) {
                        h = w.initialTransformation,
                        _ = 0;
                        for (var X = w.transforms.length; _ < X; _++) {
                            var I = w.transforms[_];
                            I instanceof t.Matrix ? h = I.relative ? h.multiply((new t.Matrix).morph(I).at(w.ease(this.pos))) : h.morph(I).at(w.ease(this.pos)) : (I.relative || I.undo(h.extract()),
                            h = h.multiply(I.at(w.ease(this.pos))))
                        }
                        b.matrix(h)
                    }
                    return this
                },
                once: function(h, u, b) {
                    var w = this.last();
                    return b || (h = w.ease(h)),
                    w.once[h] = u,
                    this
                },
                _callStart: function() {
                    return setTimeout(function() {
                        this.start()
                    }
                    .bind(this), 0),
                    this
                }
            },
            parent: t.Element,
            construct: {
                animate: function(h, u, b) {
                    return (this.fx || (this.fx = new t.FX(this))).animate(h, u, b)
                },
                delay: function(h) {
                    return (this.fx || (this.fx = new t.FX(this))).delay(h)
                },
                stop: function(h, u) {
                    return this.fx && this.fx.stop(h, u),
                    this
                },
                finish: function() {
                    return this.fx && this.fx.finish(),
                    this
                }
            }
        }),
        t.MorphObj = t.invent({
            create: function(h, u) {
                return t.Color.isColor(u) ? new t.Color(h).morph(u) : t.regex.delimiter.test(h) ? t.regex.pathLetters.test(h) ? new t.PathArray(h).morph(u) : new t.Array(h).morph(u) : t.regex.numberAndUnit.test(u) ? new t.Number(h).morph(u) : (this.value = h,
                void (this.destination = u))
            },
            extend: {
                at: function(h, u) {
                    return u < 1 ? this.value : this.destination
                },
                valueOf: function() {
                    return this.value
                }
            }
        }),
        t.extend(t.FX, {
            attr: function(h, u, b) {
                if ("object" === de(h))
                    for (var w in h)
                        this.attr(w, h[w]);
                else
                    this.add(h, u, "attrs");
                return this
            },
            plot: function(h, u, b, w) {
                return 4 == arguments.length ? this.plot([h, u, b, w]) : this.add("plot", new (this.target().morphArray)(h))
            }
        }),
        t.Box = t.invent({
            create: function(h, u, b, w) {
                if (!("object" !== de(h) || h instanceof t.Element))
                    return t.Box.call(this, null != h.left ? h.left : h.x, null != h.top ? h.top : h.y, h.width, h.height);
                4 == arguments.length && (this.x = h,
                this.y = u,
                this.width = b,
                this.height = w),
                v(this)
            }
        }),
        t.BBox = t.invent({
            create: function(h) {
                if (t.Box.apply(this, [].slice.call(arguments)),
                h instanceof t.Element) {
                    var u;
                    try {
                        if (!e.documentElement.contains) {
                            for (var b = h.node; b.parentNode; )
                                b = b.parentNode;
                            if (b != e)
                                throw new Error("Element not in the dom")
                        }
                        u = h.node.getBBox()
                    } catch {
                        if (h instanceof t.Shape) {
                            t.parser.draw || t.prepare();
                            var w = h.clone(t.parser.draw.instance).show();
                            w && w.node && "function" == typeof w.node.getBBox && (u = w.node.getBBox()),
                            w && "function" == typeof w.remove && w.remove()
                        } else
                            u = {
                                x: h.node.clientLeft,
                                y: h.node.clientTop,
                                width: h.node.clientWidth,
                                height: h.node.clientHeight
                            }
                    }
                    t.Box.call(this, u)
                }
            },
            inherit: t.Box,
            parent: t.Element,
            construct: {
                bbox: function() {
                    return new t.BBox(this)
                }
            }
        }),
        t.BBox.prototype.constructor = t.BBox,
        t.Matrix = t.invent({
            create: function(h) {
                var u = m([1, 0, 0, 1, 0, 0]);
                h = null === h ? u : h instanceof t.Element ? h.matrixify() : "string" == typeof h ? m(h.split(t.regex.delimiter).map(parseFloat)) : 6 == arguments.length ? m([].slice.call(arguments)) : Array.isArray(h) ? m(h) : h && "object" === de(h) ? h : u;
                for (var b = S.length - 1; b >= 0; --b)
                    this[S[b]] = null != h[S[b]] ? h[S[b]] : u[S[b]]
            },
            extend: {
                extract: function() {
                    var h = p(this, 0, 1);
                    p(this, 1, 0);
                    var u = 180 / Math.PI * Math.atan2(h.y, h.x) - 90;
                    return {
                        x: this.e,
                        y: this.f,
                        transformedX: (this.e * Math.cos(u * Math.PI / 180) + this.f * Math.sin(u * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b),
                        transformedY: (this.f * Math.cos(u * Math.PI / 180) + this.e * Math.sin(-u * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d),
                        rotation: u,
                        a: this.a,
                        b: this.b,
                        c: this.c,
                        d: this.d,
                        e: this.e,
                        f: this.f,
                        matrix: new t.Matrix(this)
                    }
                },
                clone: function() {
                    return new t.Matrix(this)
                },
                morph: function(h) {
                    return this.destination = new t.Matrix(h),
                    this
                },
                multiply: function(h) {
                    return new t.Matrix(this.native().multiply((u = h,
                    u instanceof t.Matrix || (u = new t.Matrix(u)),
                    u).native()));
                    var u
                },
                inverse: function() {
                    return new t.Matrix(this.native().inverse())
                },
                translate: function(h, u) {
                    return new t.Matrix(this.native().translate(h || 0, u || 0))
                },
                native: function() {
                    for (var h = t.parser.native.createSVGMatrix(), u = S.length - 1; u >= 0; u--)
                        h[S[u]] = this[S[u]];
                    return h
                },
                toString: function() {
                    return "matrix(" + k(this.a) + "," + k(this.b) + "," + k(this.c) + "," + k(this.d) + "," + k(this.e) + "," + k(this.f) + ")"
                }
            },
            parent: t.Element,
            construct: {
                ctm: function() {
                    return new t.Matrix(this.node.getCTM())
                },
                screenCTM: function() {
                    if (this instanceof t.Nested) {
                        var h = this.rect(1, 1)
                          , u = h.node.getScreenCTM();
                        return h.remove(),
                        new t.Matrix(u)
                    }
                    return new t.Matrix(this.node.getScreenCTM())
                }
            }
        }),
        t.Point = t.invent({
            create: function(h, u) {
                var b;
                b = Array.isArray(h) ? {
                    x: h[0],
                    y: h[1]
                } : "object" === de(h) ? {
                    x: h.x,
                    y: h.y
                } : null != h ? {
                    x: h,
                    y: u ?? h
                } : {
                    x: 0,
                    y: 0
                },
                this.x = b.x,
                this.y = b.y
            },
            extend: {
                clone: function() {
                    return new t.Point(this)
                },
                morph: function(h, u) {
                    return this.destination = new t.Point(h,u),
                    this
                }
            }
        }),
        t.extend(t.Element, {
            point: function(h, u) {
                return new t.Point(h,u).transform(this.screenCTM().inverse())
            }
        }),
        t.extend(t.Element, {
            attr: function(h, u, b) {
                if (null == h) {
                    for (h = {},
                    b = (u = this.node.attributes).length - 1; b >= 0; b--)
                        h[u[b].nodeName] = t.regex.isNumber.test(u[b].nodeValue) ? parseFloat(u[b].nodeValue) : u[b].nodeValue;
                    return h
                }
                if ("object" === de(h))
                    for (var w in h)
                        this.attr(w, h[w]);
                else if (null === u)
                    this.node.removeAttribute(h);
                else {
                    if (null == u)
                        return null == (u = this.node.getAttribute(h)) ? t.defaults.attrs[h] : t.regex.isNumber.test(u) ? parseFloat(u) : u;
                    "stroke-width" == h ? this.attr("stroke", parseFloat(u) > 0 ? this._stroke : null) : "stroke" == h && (this._stroke = u),
                    "fill" != h && "stroke" != h || (t.regex.isImage.test(u) && (u = this.doc().defs().image(u, 0, 0)),
                    u instanceof t.Image && (u = this.doc().defs().pattern(0, 0, function() {
                        this.add(u)
                    }))),
                    "number" == typeof u ? u = new t.Number(u) : t.Color.isColor(u) ? u = new t.Color(u) : Array.isArray(u) && (u = new t.Array(u)),
                    "leading" == h ? this.leading && this.leading(u) : "string" == typeof b ? this.node.setAttributeNS(b, h, u.toString()) : this.node.setAttribute(h, u.toString()),
                    !this.rebuild || "font-size" != h && "x" != h || this.rebuild(h, u)
                }
                return this
            }
        }),
        t.extend(t.Element, {
            transform: function(h, u) {
                var b;
                return "object" !== de(h) ? (b = new t.Matrix(this).extract(),
                "string" == typeof h ? b[h] : b) : (b = new t.Matrix(this),
                u = !!u || !!h.relative,
                null != h.a && (b = u ? b.multiply(new t.Matrix(h)) : new t.Matrix(h)),
                this.attr("transform", b))
            }
        }),
        t.extend(t.Element, {
            untransform: function() {
                return this.attr("transform", null)
            },
            matrixify: function() {
                return (this.attr("transform") || "").split(t.regex.transforms).slice(0, -1).map(function(h) {
                    var u = h.trim().split("(");
                    return [u[0], u[1].split(t.regex.delimiter).map(function(b) {
                        return parseFloat(b)
                    })]
                }).reduce(function(h, u) {
                    return "matrix" == u[0] ? h.multiply(m(u[1])) : h[u[0]].apply(h, u[1])
                }, new t.Matrix)
            },
            toParent: function(h) {
                if (this == h)
                    return this;
                var u = this.screenCTM()
                  , b = h.screenCTM().inverse();
                return this.addTo(h).untransform().transform(b.multiply(u)),
                this
            },
            toDoc: function() {
                return this.toParent(this.doc())
            }
        }),
        t.Transformation = t.invent({
            create: function(h, u) {
                if (arguments.length > 1 && "boolean" != typeof u)
                    return this.constructor.call(this, [].slice.call(arguments));
                if (Array.isArray(h))
                    for (var b = 0, w = this.arguments.length; b < w; ++b)
                        this[this.arguments[b]] = h[b];
                else if (h && "object" === de(h))
                    for (b = 0,
                    w = this.arguments.length; b < w; ++b)
                        this[this.arguments[b]] = h[this.arguments[b]];
                this.inversed = !1,
                !0 === u && (this.inversed = !0)
            }
        }),
        t.Translate = t.invent({
            parent: t.Matrix,
            inherit: t.Transformation,
            create: function(h, u) {
                this.constructor.apply(this, [].slice.call(arguments))
            },
            extend: {
                arguments: ["transformedX", "transformedY"],
                method: "translate"
            }
        }),
        t.extend(t.Element, {
            style: function(h, u) {
                if (0 == arguments.length)
                    return this.node.style.cssText || "";
                if (arguments.length < 2)
                    if ("object" === de(h))
                        for (var b in h)
                            this.style(b, h[b]);
                    else {
                        if (!t.regex.isCss.test(h))
                            return this.node.style[l(h)];
                        for (h = h.split(/\s*;\s*/).filter(function(w) {
                            return !!w
                        }).map(function(w) {
                            return w.split(/\s*:\s*/)
                        }); u = h.pop(); )
                            this.style(u[0], u[1])
                    }
                else
                    this.node.style[l(h)] = null === u || t.regex.isBlank.test(u) ? "" : u;
                return this
            }
        }),
        t.Parent = t.invent({
            create: function(h) {
                this.constructor.call(this, h)
            },
            inherit: t.Element,
            extend: {
                children: function() {
                    return t.utils.map(t.utils.filterSVGElements(this.node.childNodes), function(h) {
                        return t.adopt(h)
                    })
                },
                add: function(h, u) {
                    return null == u ? this.node.appendChild(h.node) : h.node != this.node.childNodes[u] && this.node.insertBefore(h.node, this.node.childNodes[u]),
                    this
                },
                put: function(h, u) {
                    return this.add(h, u),
                    h
                },
                has: function(h) {
                    return this.index(h) >= 0
                },
                index: function(h) {
                    return [].slice.call(this.node.childNodes).indexOf(h.node)
                },
                get: function(h) {
                    return t.adopt(this.node.childNodes[h])
                },
                first: function() {
                    return this.get(0)
                },
                last: function() {
                    return this.get(this.node.childNodes.length - 1)
                },
                each: function(h, u) {
                    for (var b = this.children(), w = 0, _ = b.length; w < _; w++)
                        b[w]instanceof t.Element && h.apply(b[w], [w, b]),
                        u && b[w]instanceof t.Container && b[w].each(h, u);
                    return this
                },
                removeElement: function(h) {
                    return this.node.removeChild(h.node),
                    this
                },
                clear: function() {
                    for (; this.node.hasChildNodes(); )
                        this.node.removeChild(this.node.lastChild);
                    return delete this._defs,
                    this
                },
                defs: function() {
                    return this.doc().defs()
                }
            }
        }),
        t.extend(t.Parent, {
            ungroup: function(h, u) {
                return 0 === u || this instanceof t.Defs || this.node == t.parser.draw || (h = h || (this instanceof t.Doc ? this : this.parent(t.Parent)),
                u = u || 1 / 0,
                this.each(function() {
                    return this instanceof t.Defs ? this : this instanceof t.Parent ? this.ungroup(h, u - 1) : this.toParent(h)
                }),
                this.node.firstChild || this.remove()),
                this
            },
            flatten: function(h, u) {
                return this.ungroup(h, u)
            }
        }),
        t.Container = t.invent({
            create: function(h) {
                this.constructor.call(this, h)
            },
            inherit: t.Parent
        }),
        t.ViewBox = t.invent({
            parent: t.Container,
            construct: {}
        }),
        ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel"].forEach(function(h) {
            t.Element.prototype[h] = function(u) {
                return t.on(this.node, h, u),
                this
            }
        }),
        t.listeners = [],
        t.handlerMap = [],
        t.listenerId = 0,
        t.on = function(h, u, b, w, _) {
            var X = b.bind(w || h.instance || h)
              , I = (t.handlerMap.indexOf(h) + 1 || t.handlerMap.push(h)) - 1
              , R = u.split(".")[0]
              , H = u.split(".")[1] || "*";
            t.listeners[I] = t.listeners[I] || {},
            t.listeners[I][R] = t.listeners[I][R] || {},
            t.listeners[I][R][H] = t.listeners[I][R][H] || {},
            b._svgjsListenerId || (b._svgjsListenerId = ++t.listenerId),
            t.listeners[I][R][H][b._svgjsListenerId] = X,
            h.addEventListener(R, X, _ || {
                passive: !0
            })
        }
        ,
        t.off = function(h, u, b) {
            var w = t.handlerMap.indexOf(h)
              , _ = u && u.split(".")[0]
              , X = u && u.split(".")[1]
              , I = "";
            if (-1 != w)
                if (b) {
                    if ("function" == typeof b && (b = b._svgjsListenerId),
                    !b)
                        return;
                    t.listeners[w][_] && t.listeners[w][_][X || "*"] && (h.removeEventListener(_, t.listeners[w][_][X || "*"][b], !1),
                    delete t.listeners[w][_][X || "*"][b])
                } else if (X && _) {
                    if (t.listeners[w][_] && t.listeners[w][_][X]) {
                        for (var R in t.listeners[w][_][X])
                            t.off(h, [_, X].join("."), R);
                        delete t.listeners[w][_][X]
                    }
                } else if (X)
                    for (var H in t.listeners[w])
                        for (var I in t.listeners[w][H])
                            X === I && t.off(h, [H, X].join("."));
                else if (_) {
                    if (t.listeners[w][_]) {
                        for (var I in t.listeners[w][_])
                            t.off(h, [_, I].join("."));
                        delete t.listeners[w][_]
                    }
                } else {
                    for (var H in t.listeners[w])
                        t.off(h, H);
                    delete t.listeners[w],
                    delete t.handlerMap[w]
                }
        }
        ,
        t.extend(t.Element, {
            on: function(h, u, b, w) {
                return t.on(this.node, h, u, b, w),
                this
            },
            off: function(h, u) {
                return t.off(this.node, h, u),
                this
            },
            fire: function(h, u) {
                return this.node.dispatchEvent(h instanceof y.Event ? h : h = new t.CustomEvent(h,{
                    detail: u,
                    cancelable: !0
                })),
                this._event = h,
                this
            },
            event: function() {
                return this._event
            }
        }),
        t.Defs = t.invent({
            create: "defs",
            inherit: t.Container
        }),
        t.G = t.invent({
            create: "g",
            inherit: t.Container,
            extend: {
                x: function(h) {
                    return null == h ? this.transform("x") : this.transform({
                        x: h - this.x()
                    }, !0)
                }
            },
            construct: {
                group: function() {
                    return this.put(new t.G)
                }
            }
        }),
        t.Doc = t.invent({
            create: function(h) {
                h && ("svg" == (h = "string" == typeof h ? e.getElementById(h) : h).nodeName ? this.constructor.call(this, h) : (this.constructor.call(this, t.create("svg")),
                h.appendChild(this.node),
                this.size("100%", "100%")),
                this.namespace().defs())
            },
            inherit: t.Container,
            extend: {
                namespace: function() {
                    return this.attr({
                        xmlns: t.ns,
                        version: "1.1"
                    }).attr("xmlns:xlink", t.xlink, t.xmlns).attr("xmlns:svgjs", t.svgjs, t.xmlns)
                },
                defs: function() {
                    var h;
                    return this._defs || (this._defs = (h = this.node.getElementsByTagName("defs")[0]) ? t.adopt(h) : new t.Defs,
                    this.node.appendChild(this._defs.node)),
                    this._defs
                },
                parent: function() {
                    return this.node.parentNode && "#document" != this.node.parentNode.nodeName ? this.node.parentNode : null
                },
                remove: function() {
                    return this.parent() && this.parent().removeChild(this.node),
                    this
                },
                clear: function() {
                    for (; this.node.hasChildNodes(); )
                        this.node.removeChild(this.node.lastChild);
                    return delete this._defs,
                    t.parser.draw && !t.parser.draw.parentNode && this.node.appendChild(t.parser.draw),
                    this
                },
                clone: function(h) {
                    this.writeDataToDom();
                    var u = this.node
                      , b = x(u.cloneNode(!0));
                    return h ? (h.node || h).appendChild(b.node) : u.parentNode.insertBefore(b.node, u.nextSibling),
                    b
                }
            }
        }),
        t.extend(t.Element, {}),
        t.Gradient = t.invent({
            create: function(h) {
                this.constructor.call(this, t.create(h + "Gradient")),
                this.type = h
            },
            inherit: t.Container,
            extend: {
                at: function(h, u, b) {
                    return this.put(new t.Stop).update(h, u, b)
                },
                update: function(h) {
                    return this.clear(),
                    "function" == typeof h && h.call(this, this),
                    this
                },
                fill: function() {
                    return "url(#" + this.id() + ")"
                },
                toString: function() {
                    return this.fill()
                },
                attr: function(h, u, b) {
                    return "transform" == h && (h = "gradientTransform"),
                    t.Container.prototype.attr.call(this, h, u, b)
                }
            },
            construct: {
                gradient: function(h, u) {
                    return this.defs().gradient(h, u)
                }
            }
        }),
        t.extend(t.Gradient, t.FX, {
            from: function(h, u) {
                return this.attr("radial" == (this._target || this).type ? {
                    fx: new t.Number(h),
                    fy: new t.Number(u)
                } : {
                    x1: new t.Number(h),
                    y1: new t.Number(u)
                })
            },
            to: function(h, u) {
                return this.attr("radial" == (this._target || this).type ? {
                    cx: new t.Number(h),
                    cy: new t.Number(u)
                } : {
                    x2: new t.Number(h),
                    y2: new t.Number(u)
                })
            }
        }),
        t.extend(t.Defs, {
            gradient: function(h, u) {
                return this.put(new t.Gradient(h)).update(u)
            }
        }),
        t.Stop = t.invent({
            create: "stop",
            inherit: t.Element,
            extend: {
                update: function(h) {
                    return ("number" == typeof h || h instanceof t.Number) && (h = {
                        offset: arguments[0],
                        color: arguments[1],
                        opacity: arguments[2]
                    }),
                    null != h.opacity && this.attr("stop-opacity", h.opacity),
                    null != h.color && this.attr("stop-color", h.color),
                    null != h.offset && this.attr("offset", new t.Number(h.offset)),
                    this
                }
            }
        }),
        t.Pattern = t.invent({
            create: "pattern",
            inherit: t.Container,
            extend: {
                fill: function() {
                    return "url(#" + this.id() + ")"
                },
                update: function(h) {
                    return this.clear(),
                    "function" == typeof h && h.call(this, this),
                    this
                },
                toString: function() {
                    return this.fill()
                },
                attr: function(h, u, b) {
                    return "transform" == h && (h = "patternTransform"),
                    t.Container.prototype.attr.call(this, h, u, b)
                }
            },
            construct: {
                pattern: function(h, u, b) {
                    return this.defs().pattern(h, u, b)
                }
            }
        }),
        t.extend(t.Defs, {
            pattern: function(h, u, b) {
                return this.put(new t.Pattern).update(b).attr({
                    x: 0,
                    y: 0,
                    width: h,
                    height: u,
                    patternUnits: "userSpaceOnUse"
                })
            }
        }),
        t.Shape = t.invent({
            create: function(h) {
                this.constructor.call(this, h)
            },
            inherit: t.Element
        }),
        t.Symbol = t.invent({
            create: "symbol",
            inherit: t.Container,
            construct: {
                symbol: function() {
                    return this.put(new t.Symbol)
                }
            }
        }),
        t.Use = t.invent({
            create: "use",
            inherit: t.Shape,
            extend: {
                element: function(h, u) {
                    return this.attr("href", (u || "") + "#" + h, t.xlink)
                }
            },
            construct: {
                use: function(h, u) {
                    return this.put(new t.Use).element(h, u)
                }
            }
        }),
        t.Rect = t.invent({
            create: "rect",
            inherit: t.Shape,
            construct: {
                rect: function(h, u) {
                    return this.put(new t.Rect).size(h, u)
                }
            }
        }),
        t.Circle = t.invent({
            create: "circle",
            inherit: t.Shape,
            construct: {
                circle: function(h) {
                    return this.put(new t.Circle).rx(new t.Number(h).divide(2)).move(0, 0)
                }
            }
        }),
        t.extend(t.Circle, t.FX, {
            rx: function(h) {
                return this.attr("r", h)
            },
            ry: function(h) {
                return this.rx(h)
            }
        }),
        t.Ellipse = t.invent({
            create: "ellipse",
            inherit: t.Shape,
            construct: {
                ellipse: function(h, u) {
                    return this.put(new t.Ellipse).size(h, u).move(0, 0)
                }
            }
        }),
        t.extend(t.Ellipse, t.Rect, t.FX, {
            rx: function(h) {
                return this.attr("rx", h)
            },
            ry: function(h) {
                return this.attr("ry", h)
            }
        }),
        t.extend(t.Circle, t.Ellipse, {
            x: function(h) {
                return null == h ? this.cx() - this.rx() : this.cx(h + this.rx())
            },
            y: function(h) {
                return null == h ? this.cy() - this.ry() : this.cy(h + this.ry())
            },
            cx: function(h) {
                return null == h ? this.attr("cx") : this.attr("cx", h)
            },
            cy: function(h) {
                return null == h ? this.attr("cy") : this.attr("cy", h)
            },
            width: function(h) {
                return null == h ? 2 * this.rx() : this.rx(new t.Number(h).divide(2))
            },
            height: function(h) {
                return null == h ? 2 * this.ry() : this.ry(new t.Number(h).divide(2))
            },
            size: function(h, u) {
                var b = g(this, h, u);
                return this.rx(new t.Number(b.width).divide(2)).ry(new t.Number(b.height).divide(2))
            }
        }),
        t.Line = t.invent({
            create: "line",
            inherit: t.Shape,
            extend: {
                array: function() {
                    return new t.PointArray([[this.attr("x1"), this.attr("y1")], [this.attr("x2"), this.attr("y2")]])
                },
                plot: function(h, u, b, w) {
                    return null == h ? this.array() : (h = void 0 !== u ? {
                        x1: h,
                        y1: u,
                        x2: b,
                        y2: w
                    } : new t.PointArray(h).toLine(),
                    this.attr(h))
                },
                move: function(h, u) {
                    return this.attr(this.array().move(h, u).toLine())
                },
                size: function(h, u) {
                    var b = g(this, h, u);
                    return this.attr(this.array().size(b.width, b.height).toLine())
                }
            },
            construct: {
                line: function(h, u, b, w) {
                    return t.Line.prototype.plot.apply(this.put(new t.Line), null != h ? [h, u, b, w] : [0, 0, 0, 0])
                }
            }
        }),
        t.Polyline = t.invent({
            create: "polyline",
            inherit: t.Shape,
            construct: {
                polyline: function(h) {
                    return this.put(new t.Polyline).plot(h || new t.PointArray)
                }
            }
        }),
        t.Polygon = t.invent({
            create: "polygon",
            inherit: t.Shape,
            construct: {
                polygon: function(h) {
                    return this.put(new t.Polygon).plot(h || new t.PointArray)
                }
            }
        }),
        t.extend(t.Polyline, t.Polygon, {
            array: function() {
                return this._array || (this._array = new t.PointArray(this.attr("points")))
            },
            plot: function(h) {
                return null == h ? this.array() : this.clear().attr("points", "string" == typeof h ? h : this._array = new t.PointArray(h))
            },
            clear: function() {
                return delete this._array,
                this
            },
            move: function(h, u) {
                return this.attr("points", this.array().move(h, u))
            },
            size: function(h, u) {
                var b = g(this, h, u);
                return this.attr("points", this.array().size(b.width, b.height))
            }
        }),
        t.extend(t.Line, t.Polyline, t.Polygon, {
            morphArray: t.PointArray,
            x: function(h) {
                return null == h ? this.bbox().x : this.move(h, this.bbox().y)
            },
            y: function(h) {
                return null == h ? this.bbox().y : this.move(this.bbox().x, h)
            },
            width: function(h) {
                var u = this.bbox();
                return null == h ? u.width : this.size(h, u.height)
            },
            height: function(h) {
                var u = this.bbox();
                return null == h ? u.height : this.size(u.width, h)
            }
        }),
        t.Path = t.invent({
            create: "path",
            inherit: t.Shape,
            extend: {
                morphArray: t.PathArray,
                array: function() {
                    return this._array || (this._array = new t.PathArray(this.attr("d")))
                },
                plot: function(h) {
                    return null == h ? this.array() : this.clear().attr("d", "string" == typeof h ? h : this._array = new t.PathArray(h))
                },
                clear: function() {
                    return delete this._array,
                    this
                }
            },
            construct: {
                path: function(h) {
                    return this.put(new t.Path).plot(h || new t.PathArray)
                }
            }
        }),
        t.Image = t.invent({
            create: "image",
            inherit: t.Shape,
            extend: {
                load: function(h) {
                    if (!h)
                        return this;
                    var u = this
                      , b = new y.Image;
                    return t.on(b, "load", function() {
                        t.off(b);
                        var w = u.parent(t.Pattern);
                        null !== w && (0 == u.width() && 0 == u.height() && u.size(b.width, b.height),
                        w && 0 == w.width() && 0 == w.height() && w.size(u.width(), u.height()),
                        "function" == typeof u._loaded && u._loaded.call(u, {
                            width: b.width,
                            height: b.height,
                            ratio: b.width / b.height,
                            url: h
                        }))
                    }),
                    t.on(b, "error", function(w) {
                        t.off(b),
                        "function" == typeof u._error && u._error.call(u, w)
                    }),
                    this.attr("href", b.src = this.src = h, t.xlink)
                },
                loaded: function(h) {
                    return this._loaded = h,
                    this
                },
                error: function(h) {
                    return this._error = h,
                    this
                }
            },
            construct: {
                image: function(h, u, b) {
                    return this.put(new t.Image).load(h).size(u || 0, b || u || 0)
                }
            }
        }),
        t.Text = t.invent({
            create: function() {
                this.constructor.call(this, t.create("text")),
                this.dom.leading = new t.Number(1.3),
                this._rebuild = !0,
                this._build = !1,
                this.attr("font-family", t.defaults.attrs["font-family"])
            },
            inherit: t.Shape,
            extend: {
                x: function(h) {
                    return null == h ? this.attr("x") : this.attr("x", h)
                },
                text: function(h) {
                    if (void 0 === h) {
                        h = "";
                        for (var u = this.node.childNodes, b = 0, w = u.length; b < w; ++b)
                            0 != b && 3 != u[b].nodeType && 1 == t.adopt(u[b]).dom.newLined && (h += "\n"),
                            h += u[b].textContent;
                        return h
                    }
                    if (this.clear().build(!0),
                    "function" == typeof h)
                        h.call(this, this);
                    else {
                        b = 0;
                        for (var _ = (h = h.split("\n")).length; b < _; b++)
                            this.tspan(h[b]).newLine()
                    }
                    return this.build(!1).rebuild()
                },
                size: function(h) {
                    return this.attr("font-size", h).rebuild()
                },
                leading: function(h) {
                    return null == h ? this.dom.leading : (this.dom.leading = new t.Number(h),
                    this.rebuild())
                },
                lines: function() {
                    var h = (this.textPath && this.textPath() || this).node
                      , u = t.utils.map(t.utils.filterSVGElements(h.childNodes), function(b) {
                        return t.adopt(b)
                    });
                    return new t.Set(u)
                },
                rebuild: function(h) {
                    if ("boolean" == typeof h && (this._rebuild = h),
                    this._rebuild) {
                        var u = this
                          , b = 0
                          , w = this.dom.leading * new t.Number(this.attr("font-size"));
                        this.lines().each(function() {
                            this.dom.newLined && (u.textPath() || this.attr("x", u.attr("x")),
                            "\n" == this.text() ? b += w : (this.attr("dy", w + b),
                            b = 0))
                        }),
                        this.fire("rebuild")
                    }
                    return this
                },
                build: function(h) {
                    return this._build = !!h,
                    this
                },
                setData: function(h) {
                    return this.dom = h,
                    this.dom.leading = new t.Number(h.leading || 1.3),
                    this
                }
            },
            construct: {
                text: function(h) {
                    return this.put(new t.Text).text(h)
                },
                plain: function(h) {
                    return this.put(new t.Text).plain(h)
                }
            }
        }),
        t.Tspan = t.invent({
            create: "tspan",
            inherit: t.Shape,
            extend: {
                text: function(h) {
                    return null == h ? this.node.textContent + (this.dom.newLined ? "\n" : "") : ("function" == typeof h ? h.call(this, this) : this.plain(h),
                    this)
                },
                dx: function(h) {
                    return this.attr("dx", h)
                },
                dy: function(h) {
                    return this.attr("dy", h)
                },
                newLine: function() {
                    var h = this.parent(t.Text);
                    return this.dom.newLined = !0,
                    this.dy(h.dom.leading * h.attr("font-size")).attr("x", h.x())
                }
            }
        }),
        t.extend(t.Text, t.Tspan, {
            plain: function(h) {
                return !1 === this._build && this.clear(),
                this.node.appendChild(e.createTextNode(h)),
                this
            },
            tspan: function(h) {
                var u = (this.textPath && this.textPath() || this).node
                  , b = new t.Tspan;
                return !1 === this._build && this.clear(),
                u.appendChild(b.node),
                b.text(h)
            },
            clear: function() {
                for (var h = (this.textPath && this.textPath() || this).node; h.hasChildNodes(); )
                    h.removeChild(h.lastChild);
                return this
            },
            length: function() {
                return this.node.getComputedTextLength()
            }
        }),
        t.TextPath = t.invent({
            create: "textPath",
            inherit: t.Parent,
            parent: t.Text,
            construct: {
                morphArray: t.PathArray,
                array: function() {
                    var h = this.track();
                    return h ? h.array() : null
                },
                plot: function(h) {
                    var u = this.track()
                      , b = null;
                    return u && (b = u.plot(h)),
                    null == h ? b : this
                },
                track: function() {
                    var h = this.textPath();
                    if (h)
                        return h.reference("href")
                },
                textPath: function() {
                    if (this.node.firstChild && "textPath" == this.node.firstChild.nodeName)
                        return t.adopt(this.node.firstChild)
                }
            }
        }),
        t.Nested = t.invent({
            create: function() {
                this.constructor.call(this, t.create("svg")),
                this.style("overflow", "visible")
            },
            inherit: t.Container,
            construct: {
                nested: function() {
                    return this.put(new t.Nested)
                }
            }
        });
        var n = {
            stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"],
            fill: ["color", "opacity", "rule"],
            prefix: function(h, u) {
                return "color" == u ? h : h + "-" + u
            }
        };
        function o(h, u, b, w) {
            return b + w.replace(t.regex.dots, " .")
        }
        function l(h) {
            return h.toLowerCase().replace(/-(.)/g, function(u, b) {
                return b.toUpperCase()
            })
        }
        function c(h) {
            return h.charAt(0).toUpperCase() + h.slice(1)
        }
        function d(h) {
            var u = h.toString(16);
            return 1 == u.length ? "0" + u : u
        }
        function g(h, u, b) {
            if (null == u || null == b) {
                var w = h.bbox();
                null == u ? u = w.width / w.height * b : null == b && (b = w.height / w.width * u)
            }
            return {
                width: u,
                height: b
            }
        }
        function p(h, u, b) {
            return {
                x: u * h.a + b * h.c + 0,
                y: u * h.b + b * h.d + 0
            }
        }
        function m(h) {
            return {
                a: h[0],
                b: h[1],
                c: h[2],
                d: h[3],
                e: h[4],
                f: h[5]
            }
        }
        function x(h) {
            for (var u = h.childNodes.length - 1; u >= 0; u--)
                h.childNodes[u]instanceof y.SVGElement && x(h.childNodes[u]);
            return t.adopt(h).id(t.eid(h.nodeName))
        }
        function v(h) {
            return null == h.x && (h.x = 0,
            h.y = 0,
            h.width = 0,
            h.height = 0),
            h.w = h.width,
            h.h = h.height,
            h.x2 = h.x + h.width,
            h.y2 = h.y + h.height,
            h.cx = h.x + h.width / 2,
            h.cy = h.y + h.height / 2,
            h
        }
        function k(h) {
            return Math.abs(h) > 1e-37 ? h : 0
        }
        ["fill", "stroke"].forEach(function(h) {
            var u = {};
            u[h] = function(b) {
                if (void 0 === b)
                    return this;
                if ("string" == typeof b || t.Color.isRgb(b) || b && "function" == typeof b.fill)
                    this.attr(h, b);
                else
                    for (var w = n[h].length - 1; w >= 0; w--)
                        null != b[n[h][w]] && this.attr(n.prefix(h, n[h][w]), b[n[h][w]]);
                return this
            }
            ,
            t.extend(t.Element, t.FX, u)
        }),
        t.extend(t.Element, t.FX, {
            translate: function(h, u) {
                return this.transform({
                    x: h,
                    y: u
                })
            },
            matrix: function(h) {
                return this.attr("transform", new t.Matrix(6 == arguments.length ? [].slice.call(arguments) : h))
            },
            opacity: function(h) {
                return this.attr("opacity", h)
            },
            dx: function(h) {
                return this.x(new t.Number(h).plus(this instanceof t.FX ? 0 : this.x()), !0)
            },
            dy: function(h) {
                return this.y(new t.Number(h).plus(this instanceof t.FX ? 0 : this.y()), !0)
            }
        }),
        t.extend(t.Path, {
            length: function() {
                return this.node.getTotalLength()
            },
            pointAt: function(h) {
                return this.node.getPointAtLength(h)
            }
        }),
        t.Set = t.invent({
            create: function(h) {
                Array.isArray(h) ? this.members = h : this.clear()
            },
            extend: {
                add: function() {
                    for (var h = [].slice.call(arguments), u = 0, b = h.length; u < b; u++)
                        this.members.push(h[u]);
                    return this
                },
                remove: function(h) {
                    var u = this.index(h);
                    return u > -1 && this.members.splice(u, 1),
                    this
                },
                each: function(h) {
                    for (var u = 0, b = this.members.length; u < b; u++)
                        h.apply(this.members[u], [u, this.members]);
                    return this
                },
                clear: function() {
                    return this.members = [],
                    this
                },
                length: function() {
                    return this.members.length
                },
                has: function(h) {
                    return this.index(h) >= 0
                },
                index: function(h) {
                    return this.members.indexOf(h)
                },
                get: function(h) {
                    return this.members[h]
                },
                first: function() {
                    return this.get(0)
                },
                last: function() {
                    return this.get(this.members.length - 1)
                },
                valueOf: function() {
                    return this.members
                }
            },
            construct: {
                set: function(h) {
                    return new t.Set(h)
                }
            }
        }),
        t.FX.Set = t.invent({
            create: function(h) {
                this.set = h
            }
        }),
        t.Set.inherit = function() {
            var h = [];
            for (var u in t.Shape.prototype)
                "function" == typeof t.Shape.prototype[u] && "function" != typeof t.Set.prototype[u] && h.push(u);
            for (var u in h.forEach(function(w) {
                t.Set.prototype[w] = function() {
                    for (var _ = 0, X = this.members.length; _ < X; _++)
                        this.members[_] && "function" == typeof this.members[_][w] && this.members[_][w].apply(this.members[_], arguments);
                    return "animate" == w ? this.fx || (this.fx = new t.FX.Set(this)) : this
                }
            }),
            h = [],
            t.FX.prototype)
                "function" == typeof t.FX.prototype[u] && "function" != typeof t.FX.Set.prototype[u] && h.push(u);
            h.forEach(function(b) {
                t.FX.Set.prototype[b] = function() {
                    for (var w = 0, _ = this.set.members.length; w < _; w++)
                        this.set.members[w].fx[b].apply(this.set.members[w].fx, arguments);
                    return this
                }
            })
        }
        ,
        t.extend(t.Element, {}),
        t.extend(t.Element, {
            remember: function(h, u) {
                if ("object" === de(arguments[0]))
                    for (var b in h)
                        this.remember(b, h[b]);
                else {
                    if (1 == arguments.length)
                        return this.memory()[h];
                    this.memory()[h] = u
                }
                return this
            },
            forget: function() {
                if (0 == arguments.length)
                    this._memory = {};
                else
                    for (var h = arguments.length - 1; h >= 0; h--)
                        delete this.memory()[arguments[h]];
                return this
            },
            memory: function() {
                return this._memory || (this._memory = {})
            }
        }),
        t.get = function(h) {
            var u = e.getElementById(function(b) {
                var w = (b || "").toString().match(t.regex.reference);
                if (w)
                    return w[1]
            }(h) || h);
            return t.adopt(u)
        }
        ,
        t.select = function(h, u) {
            return new t.Set(t.utils.map((u || e).querySelectorAll(h), function(b) {
                return t.adopt(b)
            }))
        }
        ,
        t.extend(t.Parent, {
            select: function(h) {
                return t.select(h, this.node)
            }
        });
        var S = "abcdef".split("");
        if ("function" != typeof y.CustomEvent) {
            var C = function(h, u) {
                u = u || {
                    bubbles: !1,
                    cancelable: !1,
                    detail: void 0
                };
                var b = e.createEvent("CustomEvent");
                return b.initCustomEvent(h, u.bubbles, u.cancelable, u.detail),
                b
            };
            C.prototype = y.Event.prototype,
            t.CustomEvent = C
        } else
            t.CustomEvent = y.CustomEvent;
        return t
    }
    ,
    "function" == typeof define && define.amd ? define(function() {
        return B(j, j.document)
    }) : "object" === (typeof exports > "u" ? "undefined" : de(exports)) && typeof module < "u" ? module.exports = j.document ? B(j, j.document) : function(y) {
        return B(y, y.document)
    }
    : j.SVG = B(j, j.document),
    function() {
        SVG.Filter = SVG.invent({
            create: "filter",
            inherit: SVG.Parent,
            extend: {
                source: "SourceGraphic",
                sourceAlpha: "SourceAlpha",
                background: "BackgroundImage",
                backgroundAlpha: "BackgroundAlpha",
                fill: "FillPaint",
                stroke: "StrokePaint",
                autoSetIn: !0,
                put: function(n, o) {
                    return this.add(n, o),
                    !n.attr("in") && this.autoSetIn && n.attr("in", this.source),
                    n.attr("result") || n.attr("result", n),
                    n
                },
                blend: function(n, o, l) {
                    return this.put(new SVG.BlendEffect(n,o,l))
                },
                colorMatrix: function(n, o) {
                    return this.put(new SVG.ColorMatrixEffect(n,o))
                },
                convolveMatrix: function(n) {
                    return this.put(new SVG.ConvolveMatrixEffect(n))
                },
                componentTransfer: function(n) {
                    return this.put(new SVG.ComponentTransferEffect(n))
                },
                composite: function(n, o, l) {
                    return this.put(new SVG.CompositeEffect(n,o,l))
                },
                flood: function(n, o) {
                    return this.put(new SVG.FloodEffect(n,o))
                },
                offset: function(n, o) {
                    return this.put(new SVG.OffsetEffect(n,o))
                },
                image: function(n) {
                    return this.put(new SVG.ImageEffect(n))
                },
                merge: function() {
                    var n = [void 0];
                    for (var o in arguments)
                        n.push(arguments[o]);
                    return this.put(new (SVG.MergeEffect.bind.apply(SVG.MergeEffect, n)))
                },
                gaussianBlur: function(n, o) {
                    return this.put(new SVG.GaussianBlurEffect(n,o))
                },
                morphology: function(n, o) {
                    return this.put(new SVG.MorphologyEffect(n,o))
                },
                diffuseLighting: function(n, o, l) {
                    return this.put(new SVG.DiffuseLightingEffect(n,o,l))
                },
                displacementMap: function(n, o, l, c, d) {
                    return this.put(new SVG.DisplacementMapEffect(n,o,l,c,d))
                },
                specularLighting: function(n, o, l, c) {
                    return this.put(new SVG.SpecularLightingEffect(n,o,l,c))
                },
                tile: function() {
                    return this.put(new SVG.TileEffect)
                },
                turbulence: function(n, o, l, c, d) {
                    return this.put(new SVG.TurbulenceEffect(n,o,l,c,d))
                },
                toString: function() {
                    return "url(#" + this.attr("id") + ")"
                }
            }
        }),
        SVG.extend(SVG.Defs, {
            filter: function(n) {
                var o = this.put(new SVG.Filter);
                return "function" == typeof n && n.call(o, o),
                o
            }
        }),
        SVG.extend(SVG.Container, {
            filter: function(n) {
                return this.defs().filter(n)
            }
        }),
        SVG.extend(SVG.Element, SVG.G, SVG.Nested, {
            filter: function(n) {
                return this.filterer = n instanceof SVG.Element ? n : this.doc().filter(n),
                this.doc() && this.filterer.doc() !== this.doc() && this.doc().defs().add(this.filterer),
                this.attr("filter", this.filterer),
                this.filterer
            },
            unfilter: function(n) {
                return this.filterer && !0 === n && this.filterer.remove(),
                delete this.filterer,
                this.attr("filter", null)
            }
        }),
        SVG.Effect = SVG.invent({
            create: function() {
                this.constructor.call(this)
            },
            inherit: SVG.Element,
            extend: {
                in: function(n) {
                    return null == n ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", n)
                },
                result: function(n) {
                    return null == n ? this.attr("result") : this.attr("result", n)
                },
                toString: function() {
                    return this.result()
                }
            }
        }),
        SVG.ParentEffect = SVG.invent({
            create: function() {
                this.constructor.call(this)
            },
            inherit: SVG.Parent,
            extend: {
                in: function(n) {
                    return null == n ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", n)
                },
                result: function(n) {
                    return null == n ? this.attr("result") : this.attr("result", n)
                },
                toString: function() {
                    return this.result()
                }
            }
        });
        var y = {
            blend: function(n, o) {
                return this.parent() && this.parent().blend(this, n, o)
            },
            colorMatrix: function(n, o) {
                return this.parent() && this.parent().colorMatrix(n, o).in(this)
            },
            convolveMatrix: function(n) {
                return this.parent() && this.parent().convolveMatrix(n).in(this)
            },
            componentTransfer: function(n) {
                return this.parent() && this.parent().componentTransfer(n).in(this)
            },
            composite: function(n, o) {
                return this.parent() && this.parent().composite(this, n, o)
            },
            flood: function(n, o) {
                return this.parent() && this.parent().flood(n, o)
            },
            offset: function(n, o) {
                return this.parent() && this.parent().offset(n, o).in(this)
            },
            image: function(n) {
                return this.parent() && this.parent().image(n)
            },
            merge: function() {
                return this.parent() && this.parent().merge.apply(this.parent(), [this].concat(arguments))
            },
            gaussianBlur: function(n, o) {
                return this.parent() && this.parent().gaussianBlur(n, o).in(this)
            },
            morphology: function(n, o) {
                return this.parent() && this.parent().morphology(n, o).in(this)
            },
            diffuseLighting: function(n, o, l) {
                return this.parent() && this.parent().diffuseLighting(n, o, l).in(this)
            },
            displacementMap: function(n, o, l, c) {
                return this.parent() && this.parent().displacementMap(this, n, o, l, c)
            },
            specularLighting: function(n, o, l, c) {
                return this.parent() && this.parent().specularLighting(n, o, l, c).in(this)
            },
            tile: function() {
                return this.parent() && this.parent().tile().in(this)
            },
            turbulence: function(n, o, l, c, d) {
                return this.parent() && this.parent().turbulence(n, o, l, c, d).in(this)
            }
        };
        SVG.extend(SVG.Effect, y),
        SVG.extend(SVG.ParentEffect, y),
        SVG.ChildEffect = SVG.invent({
            create: function() {
                this.constructor.call(this)
            },
            inherit: SVG.Element,
            extend: {
                in: function(n) {
                    this.attr("in", n)
                }
            }
        });
        var e = {
            blend: function(n, o, l) {
                this.attr({
                    in: n,
                    in2: o,
                    mode: l || "normal"
                })
            },
            colorMatrix: function(n, o) {
                "matrix" == n && (o = s(o)),
                this.attr({
                    type: n,
                    values: void 0 === o ? null : o
                })
            },
            convolveMatrix: function(n) {
                n = s(n),
                this.attr({
                    order: Math.sqrt(n.split(" ").length),
                    kernelMatrix: n
                })
            },
            composite: function(n, o, l) {
                this.attr({
                    in: n,
                    in2: o,
                    operator: l
                })
            },
            flood: function(n, o) {
                this.attr("flood-color", n),
                null != o && this.attr("flood-opacity", o)
            },
            offset: function(n, o) {
                this.attr({
                    dx: n,
                    dy: o
                })
            },
            image: function(n) {
                this.attr("href", n, SVG.xlink)
            },
            displacementMap: function(n, o, l, c, d) {
                this.attr({
                    in: n,
                    in2: o,
                    scale: l,
                    xChannelSelector: c,
                    yChannelSelector: d
                })
            },
            gaussianBlur: function(n, o) {
                this.attr("stdDeviation", null != n || null != o ? a(Array.prototype.slice.call(arguments)) : "0 0")
            },
            morphology: function(n, o) {
                this.attr({
                    operator: n,
                    radius: o
                })
            },
            tile: function() {},
            turbulence: function(n, o, l, c, d) {
                this.attr({
                    numOctaves: o,
                    seed: l,
                    stitchTiles: c,
                    baseFrequency: n,
                    type: d
                })
            }
        }
          , t = {
            merge: function() {
                var n;
                if (arguments[0]instanceof SVG.Set) {
                    var o = this;
                    arguments[0].each(function(c) {
                        this instanceof SVG.MergeNode ? o.put(this) : (this instanceof SVG.Effect || this instanceof SVG.ParentEffect) && o.put(new SVG.MergeNode(this))
                    })
                } else {
                    n = Array.isArray(arguments[0]) ? arguments[0] : arguments;
                    for (var l = 0; l < n.length; l++)
                        n[l]instanceof SVG.MergeNode ? this.put(n[l]) : this.put(new SVG.MergeNode(n[l]))
                }
            },
            componentTransfer: function(n) {
                if (this.rgb = new SVG.Set,
                ["r", "g", "b", "a"].forEach(function(l) {
                    this[l] = new (SVG["Func" + l.toUpperCase()])("identity"),
                    this.rgb.add(this[l]),
                    this.node.appendChild(this[l].node)
                }
                .bind(this)),
                n)
                    for (var o in n.rgb && (["r", "g", "b"].forEach(function(l) {
                        this[l].attr(n.rgb)
                    }
                    .bind(this)),
                    delete n.rgb),
                    n)
                        this[o].attr(n[o])
            },
            diffuseLighting: function(n, o, l) {
                this.attr({
                    surfaceScale: n,
                    diffuseConstant: o,
                    kernelUnitLength: l
                })
            },
            specularLighting: function(n, o, l, c) {
                this.attr({
                    surfaceScale: n,
                    diffuseConstant: o,
                    specularExponent: l,
                    kernelUnitLength: c
                })
            }
        }
          , i = {
            distantLight: function(n, o) {
                this.attr({
                    azimuth: n,
                    elevation: o
                })
            },
            pointLight: function(n, o, l) {
                this.attr({
                    x: n,
                    y: o,
                    z: l
                })
            },
            spotLight: function(n, o, l, c, d, g) {
                this.attr({
                    x: n,
                    y: o,
                    z: l,
                    pointsAtX: c,
                    pointsAtY: d,
                    pointsAtZ: g
                })
            },
            mergeNode: function(n) {
                this.attr("in", n)
            }
        };
        function s(n) {
            return Array.isArray(n) && (n = new SVG.Array(n)),
            n.toString().replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ")
        }
        function a(n) {
            if (!Array.isArray(n))
                return n;
            for (var o = 0, l = n.length, c = []; o < l; o++)
                c.push(n[o]);
            return c.join(" ")
        }
        function r() {
            var n = function() {};
            for (var o in "function" == typeof arguments[arguments.length - 1] && (n = arguments[arguments.length - 1],
            Array.prototype.splice.call(arguments, arguments.length - 1, 1)),
            arguments)
                for (var l in arguments[o])
                    n(arguments[o][l], l, arguments[o])
        }
        ["r", "g", "b", "a"].forEach(function(n) {
            i["Func" + n.toUpperCase()] = function(o) {
                switch (this.attr("type", o),
                o) {
                case "table":
                    this.attr("tableValues", arguments[1]);
                    break;
                case "linear":
                    this.attr("slope", arguments[1]),
                    this.attr("intercept", arguments[2]);
                    break;
                case "gamma":
                    this.attr("amplitude", arguments[1]),
                    this.attr("exponent", arguments[2]),
                    this.attr("offset", arguments[2])
                }
            }
        }),
        r(e, function(n, o) {
            var l = o.charAt(0).toUpperCase() + o.slice(1);
            SVG[l + "Effect"] = SVG.invent({
                create: function() {
                    this.constructor.call(this, SVG.create("fe" + l)),
                    n.apply(this, arguments),
                    this.result(this.attr("id") + "Out")
                },
                inherit: SVG.Effect,
                extend: {}
            })
        }),
        r(t, function(n, o) {
            var l = o.charAt(0).toUpperCase() + o.slice(1);
            SVG[l + "Effect"] = SVG.invent({
                create: function() {
                    this.constructor.call(this, SVG.create("fe" + l)),
                    n.apply(this, arguments),
                    this.result(this.attr("id") + "Out")
                },
                inherit: SVG.ParentEffect,
                extend: {}
            })
        }),
        r(i, function(n, o) {
            var l = o.charAt(0).toUpperCase() + o.slice(1);
            SVG[l] = SVG.invent({
                create: function() {
                    this.constructor.call(this, SVG.create("fe" + l)),
                    n.apply(this, arguments)
                },
                inherit: SVG.ChildEffect,
                extend: {}
            })
        }),
        SVG.extend(SVG.MergeEffect, {
            in: function(n) {
                return n instanceof SVG.MergeNode ? this.add(n, 0) : this.add(new SVG.MergeNode(n), 0),
                this
            }
        }),
        SVG.extend(SVG.CompositeEffect, SVG.BlendEffect, SVG.DisplacementMapEffect, {
            in2: function(n) {
                return null == n ? this.parent() && this.parent().select('[result="' + this.attr("in2") + '"]').get(0) || this.attr("in2") : this.attr("in2", n)
            }
        }),
        SVG.filter = {
            sepiatone: [.343, .669, .119, 0, 0, .249, .626, .13, 0, 0, .172, .334, .111, 0, 0, 0, 0, 0, 1, 0]
        }
    }
    .call(void 0),
    function() {
        function y(a, r, n, o, l, c, d) {
            for (var g = a.slice(r, n || d), p = o.slice(l, c || d), m = 0, x = {
                pos: [0, 0],
                start: [0, 0]
            }, v = {
                pos: [0, 0],
                start: [0, 0]
            }; g[m] = e.call(x, g[m]),
            p[m] = e.call(v, p[m]),
            g[m][0] != p[m][0] || "M" == g[m][0] || "A" == g[m][0] && (g[m][4] != p[m][4] || g[m][5] != p[m][5]) ? (Array.prototype.splice.apply(g, [m, 1].concat(i.call(x, g[m]))),
            Array.prototype.splice.apply(p, [m, 1].concat(i.call(v, p[m])))) : (g[m] = t.call(x, g[m]),
            p[m] = t.call(v, p[m])),
            ++m != g.length || m != p.length; )
                m == g.length && g.push(["C", x.pos[0], x.pos[1], x.pos[0], x.pos[1], x.pos[0], x.pos[1]]),
                m == p.length && p.push(["C", v.pos[0], v.pos[1], v.pos[0], v.pos[1], v.pos[0], v.pos[1]]);
            return {
                start: g,
                dest: p
            }
        }
        function e(a) {
            switch (a[0]) {
            case "z":
            case "Z":
                a[0] = "L",
                a[1] = this.start[0],
                a[2] = this.start[1];
                break;
            case "H":
                a[0] = "L",
                a[2] = this.pos[1];
                break;
            case "V":
                a[0] = "L",
                a[2] = a[1],
                a[1] = this.pos[0];
                break;
            case "T":
                a[0] = "Q",
                a[3] = a[1],
                a[4] = a[2],
                a[1] = this.reflection[1],
                a[2] = this.reflection[0];
                break;
            case "S":
                a[0] = "C",
                a[6] = a[4],
                a[5] = a[3],
                a[4] = a[2],
                a[3] = a[1],
                a[2] = this.reflection[1],
                a[1] = this.reflection[0]
            }
            return a
        }
        function t(a) {
            var r = a.length;
            return this.pos = [a[r - 2], a[r - 1]],
            -1 != "SCQT".indexOf(a[0]) && (this.reflection = [2 * this.pos[0] - a[r - 4], 2 * this.pos[1] - a[r - 3]]),
            a
        }
        function i(a) {
            var r = [a];
            switch (a[0]) {
            case "M":
                return this.pos = this.start = [a[1], a[2]],
                r;
            case "L":
                a[5] = a[3] = a[1],
                a[6] = a[4] = a[2],
                a[1] = this.pos[0],
                a[2] = this.pos[1];
                break;
            case "Q":
                a[6] = a[4],
                a[5] = a[3],
                a[4] = 1 * a[4] / 3 + 2 * a[2] / 3,
                a[3] = 1 * a[3] / 3 + 2 * a[1] / 3,
                a[2] = 1 * this.pos[1] / 3 + 2 * a[2] / 3,
                a[1] = 1 * this.pos[0] / 3 + 2 * a[1] / 3;
                break;
            case "A":
                a = (r = function(n, o) {
                    var l, c, d, g, p, m, x, v, k, S, C, h, u, b, w, _, X, I, R, H, G, ie, ne, oe, ye, Le, De = Math.abs(o[1]), qe = Math.abs(o[2]), et = o[3] % 360, Lt = o[4], Ze = o[5], ft = o[6], mt = o[7], Pe = new SVG.Point(n), we = new SVG.Point(ft,mt), Pt = [];
                    if (0 === De || 0 === qe || Pe.x === we.x && Pe.y === we.y)
                        return [["C", Pe.x, Pe.y, we.x, we.y, we.x, we.y]];
                    for ((c = (l = new SVG.Point((Pe.x - we.x) / 2,(Pe.y - we.y) / 2).transform((new SVG.Matrix).rotate(et))).x * l.x / (De * De) + l.y * l.y / (qe * qe)) > 1 && (De *= c = Math.sqrt(c),
                    qe *= c),
                    d = (new SVG.Matrix).rotate(et).scale(1 / De, 1 / qe).rotate(-et),
                    Pe = Pe.transform(d),
                    m = (g = [(we = we.transform(d)).x - Pe.x, we.y - Pe.y])[0] * g[0] + g[1] * g[1],
                    p = Math.sqrt(m),
                    g[0] /= p,
                    g[1] /= p,
                    x = m < 4 ? Math.sqrt(1 - m / 4) : 0,
                    Lt === Ze && (x *= -1),
                    v = new SVG.Point((we.x + Pe.x) / 2 + x * -g[1],(we.y + Pe.y) / 2 + x * g[0]),
                    k = new SVG.Point(Pe.x - v.x,Pe.y - v.y),
                    S = new SVG.Point(we.x - v.x,we.y - v.y),
                    C = Math.acos(k.x / Math.sqrt(k.x * k.x + k.y * k.y)),
                    k.y < 0 && (C *= -1),
                    h = Math.acos(S.x / Math.sqrt(S.x * S.x + S.y * S.y)),
                    S.y < 0 && (h *= -1),
                    Ze && C > h && (h += 2 * Math.PI),
                    !Ze && C < h && (h -= 2 * Math.PI),
                    _ = [],
                    X = C,
                    u = (h - C) / (b = Math.ceil(2 * Math.abs(C - h) / Math.PI)),
                    w = 4 * Math.tan(u / 4) / 3,
                    G = 0; G <= b; G++)
                        R = Math.cos(X),
                        I = Math.sin(X),
                        H = new SVG.Point(v.x + R,v.y + I),
                        _[G] = [new SVG.Point(H.x + w * I,H.y - w * R), H, new SVG.Point(H.x - w * I,H.y + w * R)],
                        X += u;
                    for (_[0][0] = _[0][1].clone(),
                    _[_.length - 1][2] = _[_.length - 1][1].clone(),
                    d = (new SVG.Matrix).rotate(et).scale(De, qe).rotate(-et),
                    G = 0,
                    ie = _.length; G < ie; G++)
                        _[G][0] = _[G][0].transform(d),
                        _[G][1] = _[G][1].transform(d),
                        _[G][2] = _[G][2].transform(d);
                    for (G = 1,
                    ie = _.length; G < ie; G++)
                        ne = (H = _[G - 1][2]).x,
                        oe = H.y,
                        ye = (H = _[G][0]).x,
                        Le = H.y,
                        ft = (H = _[G][1]).x,
                        Pt.push(["C", ne, oe, ye, Le, ft, mt = H.y]);
                    return Pt
                }(this.pos, a))[0]
            }
            return a[0] = "C",
            this.pos = [a[5], a[6]],
            this.reflection = [2 * a[5] - a[3], 2 * a[6] - a[4]],
            r
        }
        function s(a, r) {
            if (!1 === r)
                return !1;
            for (var n = r, o = a.length; n < o; ++n)
                if ("M" == a[n][0])
                    return n;
            return !1
        }
        SVG.extend(SVG.PathArray, {
            morph: function(a) {
                for (var r = this.value, n = this.parse(a), o = 0, l = 0, c = !1, d = !1; !1 !== o || !1 !== l; ) {
                    var g;
                    c = s(r, !1 !== o && o + 1),
                    d = s(n, !1 !== l && l + 1),
                    !1 === o && (o = 0 == (g = new SVG.PathArray(p.start).bbox()).height || 0 == g.width ? r.push(r[0]) - 1 : r.push(["M", g.x + g.width / 2, g.y + g.height / 2]) - 1),
                    !1 === l && (l = 0 == (g = new SVG.PathArray(p.dest).bbox()).height || 0 == g.width ? n.push(n[0]) - 1 : n.push(["M", g.x + g.width / 2, g.y + g.height / 2]) - 1);
                    var p = y(r, o, c, n, l, d);
                    r = r.slice(0, o).concat(p.start, !1 === c ? [] : r.slice(c)),
                    n = n.slice(0, l).concat(p.dest, !1 === d ? [] : n.slice(d)),
                    o = !1 !== c && o + p.start.length,
                    l = !1 !== d && l + p.dest.length
                }
                return this.value = r,
                this.destination = new SVG.PathArray,
                this.destination.value = n,
                this
            }
        })
    }(),
    function() {
        function y(e) {
            e.remember("_draggable", this),
            this.el = e
        }
        y.prototype.init = function(e, t) {
            var i = this;
            this.constraint = e,
            this.value = t,
            this.el.on("mousedown.drag", function(s) {
                i.start(s)
            }),
            this.el.on("touchstart.drag", function(s) {
                i.start(s)
            })
        }
        ,
        y.prototype.transformPoint = function(e, t) {
            var i = (e = e || window.event).changedTouches && e.changedTouches[0] || e;
            return this.p.x = i.clientX - (t || 0),
            this.p.y = i.clientY,
            this.p.matrixTransform(this.m)
        }
        ,
        y.prototype.getBBox = function() {
            var e = this.el.bbox();
            return this.el instanceof SVG.Nested && (e = this.el.rbox()),
            (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) && (e.x = this.el.x(),
            e.y = this.el.y()),
            e
        }
        ,
        y.prototype.start = function(e) {
            if ("click" != e.type && "mousedown" != e.type && "mousemove" != e.type || 1 == (e.which || e.buttons)) {
                var t = this;
                if (this.el.fire("beforedrag", {
                    event: e,
                    handler: this
                }),
                !this.el.event().defaultPrevented) {
                    e.preventDefault(),
                    e.stopPropagation(),
                    this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc),
                    this.p = this.parent.node.createSVGPoint(),
                    this.m = this.el.node.getScreenCTM().inverse();
                    var i, s = this.getBBox();
                    if (this.el instanceof SVG.Text)
                        switch (i = this.el.node.getComputedTextLength(),
                        this.el.attr("text-anchor")) {
                        case "middle":
                            i /= 2;
                            break;
                        case "start":
                            i = 0
                        }
                    this.startPoints = {
                        point: this.transformPoint(e, i),
                        box: s,
                        transform: this.el.transform()
                    },
                    SVG.on(window, "mousemove.drag", function(a) {
                        t.drag(a)
                    }),
                    SVG.on(window, "touchmove.drag", function(a) {
                        t.drag(a)
                    }),
                    SVG.on(window, "mouseup.drag", function(a) {
                        t.end(a)
                    }),
                    SVG.on(window, "touchend.drag", function(a) {
                        t.end(a)
                    }),
                    this.el.fire("dragstart", {
                        event: e,
                        p: this.startPoints.point,
                        m: this.m,
                        handler: this
                    })
                }
            }
        }
        ,
        y.prototype.drag = function(e) {
            var t = this.getBBox()
              , i = this.transformPoint(e)
              , s = this.startPoints.box.x + i.x - this.startPoints.point.x
              , a = this.startPoints.box.y + i.y - this.startPoints.point.y
              , r = this.constraint
              , n = i.x - this.startPoints.point.x
              , o = i.y - this.startPoints.point.y;
            if (this.el.fire("dragmove", {
                event: e,
                p: i,
                m: this.m,
                handler: this
            }),
            this.el.event().defaultPrevented)
                return i;
            if ("function" == typeof r) {
                var l = r.call(this.el, s, a, this.m);
                "boolean" == typeof l && (l = {
                    x: l,
                    y: l
                }),
                !0 === l.x ? this.el.x(s) : !1 !== l.x && this.el.x(l.x),
                !0 === l.y ? this.el.y(a) : !1 !== l.y && this.el.y(l.y)
            } else
                "object" == typeof r && (null != r.minX && s < r.minX ? n = (s = r.minX) - this.startPoints.box.x : null != r.maxX && s > r.maxX - t.width && (n = (s = r.maxX - t.width) - this.startPoints.box.x),
                null != r.minY && a < r.minY ? o = (a = r.minY) - this.startPoints.box.y : null != r.maxY && a > r.maxY - t.height && (o = (a = r.maxY - t.height) - this.startPoints.box.y),
                null != r.snapToGrid && (s -= s % r.snapToGrid,
                a -= a % r.snapToGrid,
                n -= n % r.snapToGrid,
                o -= o % r.snapToGrid),
                this.el instanceof SVG.G ? this.el.matrix(this.startPoints.transform).transform({
                    x: n,
                    y: o
                }, !0) : this.el.move(s, a));
            return i
        }
        ,
        y.prototype.end = function(e) {
            var t = this.drag(e);
            this.el.fire("dragend", {
                event: e,
                p: t,
                m: this.m,
                handler: this
            }),
            SVG.off(window, "mousemove.drag"),
            SVG.off(window, "touchmove.drag"),
            SVG.off(window, "mouseup.drag"),
            SVG.off(window, "touchend.drag")
        }
        ,
        SVG.extend(SVG.Element, {
            draggable: function(e, t) {
                "function" != typeof e && "object" != typeof e || (t = e,
                e = !0);
                var i = this.remember("_draggable") || new y(this);
                return (e = void 0 === e || e) ? i.init(t || {}, e) : (this.off("mousedown.drag"),
                this.off("touchstart.drag")),
                this
            }
        })
    }
    .call(void 0),
    function() {
        function y(e) {
            this.el = e,
            e.remember("_selectHandler", this),
            this.pointSelection = {
                isSelected: !1
            },
            this.rectSelection = {
                isSelected: !1
            },
            this.pointsList = {
                lt: [0, 0],
                rt: ["width", 0],
                rb: ["width", "height"],
                lb: [0, "height"],
                t: ["width", 0],
                r: ["width", "height"],
                b: ["width", "height"],
                l: [0, "height"]
            },
            this.pointCoord = function(t, i, s) {
                var a = "string" != typeof t ? t : i[t];
                return s ? a / 2 : a
            }
            ,
            this.pointCoords = function(t, i) {
                var s = this.pointsList[t];
                return {
                    x: this.pointCoord(s[0], i, "t" === t || "b" === t),
                    y: this.pointCoord(s[1], i, "r" === t || "l" === t)
                }
            }
        }
        y.prototype.init = function(e, t) {
            var i = this.el.bbox();
            this.options = {};
            var s = this.el.selectize.defaults.points;
            for (var a in this.el.selectize.defaults)
                this.options[a] = this.el.selectize.defaults[a],
                void 0 !== t[a] && (this.options[a] = t[a]);
            var r = ["points", "pointsExclude"];
            for (var a in r) {
                var n = this.options[r[a]];
                "string" == typeof n ? n = n.length > 0 ? n.split(/\s*,\s*/i) : [] : "boolean" == typeof n && "points" === r[a] && (n = n ? s : []),
                this.options[r[a]] = n
            }
            this.options.points = [s, this.options.points].reduce(function(o, l) {
                return o.filter(function(c) {
                    return l.indexOf(c) > -1
                })
            }),
            this.options.points = [this.options.points, this.options.pointsExclude].reduce(function(o, l) {
                return o.filter(function(c) {
                    return l.indexOf(c) < 0
                })
            }),
            this.parent = this.el.parent(),
            this.nested = this.nested || this.parent.group(),
            this.nested.matrix(new SVG.Matrix(this.el).translate(i.x, i.y)),
            this.options.deepSelect && -1 !== ["line", "polyline", "polygon"].indexOf(this.el.type) ? this.selectPoints(e) : this.selectRect(e),
            this.observe(),
            this.cleanup()
        }
        ,
        y.prototype.selectPoints = function(e) {
            return this.pointSelection.isSelected = e,
            this.pointSelection.set || (this.pointSelection.set = this.parent.set(),
            this.drawPoints()),
            this
        }
        ,
        y.prototype.getPointArray = function() {
            var e = this.el.bbox();
            return this.el.array().valueOf().map(function(t) {
                return [t[0] - e.x, t[1] - e.y]
            })
        }
        ,
        y.prototype.drawPoints = function() {
            for (var e = this, t = this.getPointArray(), i = 0, s = t.length; i < s; ++i) {
                var a = function(n) {
                    return function(o) {
                        (o = o || window.event).preventDefault ? o.preventDefault() : o.returnValue = !1,
                        o.stopPropagation(),
                        e.el.fire("point", {
                            x: o.pageX || o.touches[0].pageX,
                            y: o.pageY || o.touches[0].pageY,
                            i: n,
                            event: o
                        })
                    }
                }(i)
                  , r = this.drawPoint(t[i][0], t[i][1]).addClass(this.options.classPoints).addClass(this.options.classPoints + "_point").on("touchstart", a).on("mousedown", a);
                this.pointSelection.set.add(r)
            }
        }
        ,
        y.prototype.drawPoint = function(e, t) {
            var i = this.options.pointType;
            switch (i) {
            case "circle":
                return this.drawCircle(e, t);
            case "rect":
                return this.drawRect(e, t);
            default:
                if ("function" == typeof i)
                    return i.call(this, e, t);
                throw new Error("Unknown " + i + " point type!")
            }
        }
        ,
        y.prototype.drawCircle = function(e, t) {
            return this.nested.circle(this.options.pointSize).center(e, t)
        }
        ,
        y.prototype.drawRect = function(e, t) {
            return this.nested.rect(this.options.pointSize, this.options.pointSize).center(e, t)
        }
        ,
        y.prototype.updatePointSelection = function() {
            var e = this.getPointArray();
            this.pointSelection.set.each(function(t) {
                this.cx() === e[t][0] && this.cy() === e[t][1] || this.center(e[t][0], e[t][1])
            })
        }
        ,
        y.prototype.updateRectSelection = function() {
            var e = this
              , t = this.el.bbox();
            if (this.rectSelection.set.get(0).attr({
                width: t.width,
                height: t.height
            }),
            this.options.points.length && this.options.points.map(function(s, a) {
                var r = e.pointCoords(s, t);
                e.rectSelection.set.get(a + 1).center(r.x, r.y)
            }),
            this.options.rotationPoint) {
                var i = this.rectSelection.set.length();
                this.rectSelection.set.get(i - 1).center(t.width / 2, 20)
            }
        }
        ,
        y.prototype.selectRect = function(e) {
            var t = this
              , i = this.el.bbox();
            function s(n) {
                return function(o) {
                    (o = o || window.event).preventDefault ? o.preventDefault() : o.returnValue = !1,
                    o.stopPropagation(),
                    t.el.fire(n, {
                        x: o.pageX || o.touches[0].pageX,
                        y: o.pageY || o.touches[0].pageY,
                        event: o
                    })
                }
            }
            if (this.rectSelection.isSelected = e,
            this.rectSelection.set = this.rectSelection.set || this.parent.set(),
            this.rectSelection.set.get(0) || this.rectSelection.set.add(this.nested.rect(i.width, i.height).addClass(this.options.classRect)),
            this.options.points.length && this.rectSelection.set.length() < 2 && (this.options.points.map(function(n, o) {
                var l = t.pointCoords(n, i)
                  , c = t.drawPoint(l.x, l.y).attr("class", t.options.classPoints + "_" + n).on("mousedown", s(n)).on("touchstart", s(n));
                t.rectSelection.set.add(c)
            }),
            this.rectSelection.set.each(function() {
                this.addClass(t.options.classPoints)
            })),
            this.options.rotationPoint && (this.options.points && !this.rectSelection.set.get(9) || !this.options.points && !this.rectSelection.set.get(1))) {
                var a = function(n) {
                    (n = n || window.event).preventDefault ? n.preventDefault() : n.returnValue = !1,
                    n.stopPropagation(),
                    t.el.fire("rot", {
                        x: n.pageX || n.touches[0].pageX,
                        y: n.pageY || n.touches[0].pageY,
                        event: n
                    })
                }
                  , r = this.drawPoint(i.width / 2, 20).attr("class", this.options.classPoints + "_rot").on("touchstart", a).on("mousedown", a);
                this.rectSelection.set.add(r)
            }
        }
        ,
        y.prototype.handler = function() {
            var e = this.el.bbox();
            this.nested.matrix(new SVG.Matrix(this.el).translate(e.x, e.y)),
            this.rectSelection.isSelected && this.updateRectSelection(),
            this.pointSelection.isSelected && this.updatePointSelection()
        }
        ,
        y.prototype.observe = function() {
            var e = this;
            if (MutationObserver)
                if (this.rectSelection.isSelected || this.pointSelection.isSelected)
                    this.observerInst = this.observerInst || new MutationObserver(function() {
                        e.handler()
                    }
                    ),
                    this.observerInst.observe(this.el.node, {
                        attributes: !0
                    });
                else
                    try {
                        this.observerInst.disconnect(),
                        delete this.observerInst
                    } catch {}
            else
                this.el.off("DOMAttrModified.select"),
                (this.rectSelection.isSelected || this.pointSelection.isSelected) && this.el.on("DOMAttrModified.select", function() {
                    e.handler()
                })
        }
        ,
        y.prototype.cleanup = function() {
            !this.rectSelection.isSelected && this.rectSelection.set && (this.rectSelection.set.each(function() {
                this.remove()
            }),
            this.rectSelection.set.clear(),
            delete this.rectSelection.set),
            !this.pointSelection.isSelected && this.pointSelection.set && (this.pointSelection.set.each(function() {
                this.remove()
            }),
            this.pointSelection.set.clear(),
            delete this.pointSelection.set),
            this.pointSelection.isSelected || this.rectSelection.isSelected || (this.nested.remove(),
            delete this.nested)
        }
        ,
        SVG.extend(SVG.Element, {
            selectize: function(e, t) {
                return "object" == typeof e && (t = e,
                e = !0),
                (this.remember("_selectHandler") || new y(this)).init(void 0 === e || e, t || {}),
                this
            }
        }),
        SVG.Element.prototype.selectize.defaults = {
            points: ["lt", "rt", "rb", "lb", "t", "r", "b", "l"],
            pointsExclude: [],
            classRect: "svg_select_boundingRect",
            classPoints: "svg_select_points",
            pointSize: 7,
            rotationPoint: !0,
            deepSelect: !1,
            pointType: "circle"
        }
    }(),
    function() {
        (function() {
            function y(e) {
                e.remember("_resizeHandler", this),
                this.el = e,
                this.parameters = {},
                this.lastUpdateCall = null,
                this.p = e.doc().node.createSVGPoint()
            }
            y.prototype.transformPoint = function(e, t, i) {
                return this.p.x = e - (this.offset.x - window.pageXOffset),
                this.p.y = t - (this.offset.y - window.pageYOffset),
                this.p.matrixTransform(i || this.m)
            }
            ,
            y.prototype._extractPosition = function(e) {
                return {
                    x: null != e.clientX ? e.clientX : e.touches[0].clientX,
                    y: null != e.clientY ? e.clientY : e.touches[0].clientY
                }
            }
            ,
            y.prototype.init = function(e) {
                var t = this;
                if (this.stop(),
                "stop" !== e) {
                    for (var i in this.options = {},
                    this.el.resize.defaults)
                        this.options[i] = this.el.resize.defaults[i],
                        void 0 !== e[i] && (this.options[i] = e[i]);
                    this.el.on("lt.resize", function(s) {
                        t.resize(s || window.event)
                    }),
                    this.el.on("rt.resize", function(s) {
                        t.resize(s || window.event)
                    }),
                    this.el.on("rb.resize", function(s) {
                        t.resize(s || window.event)
                    }),
                    this.el.on("lb.resize", function(s) {
                        t.resize(s || window.event)
                    }),
                    this.el.on("t.resize", function(s) {
                        t.resize(s || window.event)
                    }),
                    this.el.on("r.resize", function(s) {
                        t.resize(s || window.event)
                    }),
                    this.el.on("b.resize", function(s) {
                        t.resize(s || window.event)
                    }),
                    this.el.on("l.resize", function(s) {
                        t.resize(s || window.event)
                    }),
                    this.el.on("rot.resize", function(s) {
                        t.resize(s || window.event)
                    }),
                    this.el.on("point.resize", function(s) {
                        t.resize(s || window.event)
                    }),
                    this.update()
                }
            }
            ,
            y.prototype.stop = function() {
                return this.el.off("lt.resize"),
                this.el.off("rt.resize"),
                this.el.off("rb.resize"),
                this.el.off("lb.resize"),
                this.el.off("t.resize"),
                this.el.off("r.resize"),
                this.el.off("b.resize"),
                this.el.off("l.resize"),
                this.el.off("rot.resize"),
                this.el.off("point.resize"),
                this
            }
            ,
            y.prototype.resize = function(e) {
                var t = this;
                this.m = this.el.node.getScreenCTM().inverse(),
                this.offset = {
                    x: window.pageXOffset,
                    y: window.pageYOffset
                };
                var i = this._extractPosition(e.detail.event);
                if (this.parameters = {
                    type: this.el.type,
                    p: this.transformPoint(i.x, i.y),
                    x: e.detail.x,
                    y: e.detail.y,
                    box: this.el.bbox(),
                    rotation: this.el.transform().rotation
                },
                "text" === this.el.type && (this.parameters.fontSize = this.el.attr()["font-size"]),
                void 0 !== e.detail.i) {
                    var s = this.el.array().valueOf();
                    this.parameters.i = e.detail.i,
                    this.parameters.pointCoords = [s[e.detail.i][0], s[e.detail.i][1]]
                }
                switch (e.type) {
                case "lt":
                    this.calc = function(a, r) {
                        var n = this.snapToGrid(a, r);
                        if (this.parameters.box.width - n[0] > 0 && this.parameters.box.height - n[1] > 0) {
                            if ("text" === this.parameters.type)
                                return this.el.move(this.parameters.box.x + n[0], this.parameters.box.y),
                                void this.el.attr("font-size", this.parameters.fontSize - n[0]);
                            n = this.checkAspectRatio(n),
                            this.el.move(this.parameters.box.x + n[0], this.parameters.box.y + n[1]).size(this.parameters.box.width - n[0], this.parameters.box.height - n[1])
                        }
                    }
                    ;
                    break;
                case "rt":
                    this.calc = function(a, r) {
                        var n = this.snapToGrid(a, r, 2);
                        if (this.parameters.box.width + n[0] > 0 && this.parameters.box.height - n[1] > 0) {
                            if ("text" === this.parameters.type)
                                return this.el.move(this.parameters.box.x - n[0], this.parameters.box.y),
                                void this.el.attr("font-size", this.parameters.fontSize + n[0]);
                            n = this.checkAspectRatio(n, !0),
                            this.el.move(this.parameters.box.x, this.parameters.box.y + n[1]).size(this.parameters.box.width + n[0], this.parameters.box.height - n[1])
                        }
                    }
                    ;
                    break;
                case "rb":
                    this.calc = function(a, r) {
                        var n = this.snapToGrid(a, r, 0);
                        if (this.parameters.box.width + n[0] > 0 && this.parameters.box.height + n[1] > 0) {
                            if ("text" === this.parameters.type)
                                return this.el.move(this.parameters.box.x - n[0], this.parameters.box.y),
                                void this.el.attr("font-size", this.parameters.fontSize + n[0]);
                            n = this.checkAspectRatio(n),
                            this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + n[0], this.parameters.box.height + n[1])
                        }
                    }
                    ;
                    break;
                case "lb":
                    this.calc = function(a, r) {
                        var n = this.snapToGrid(a, r, 1);
                        if (this.parameters.box.width - n[0] > 0 && this.parameters.box.height + n[1] > 0) {
                            if ("text" === this.parameters.type)
                                return this.el.move(this.parameters.box.x + n[0], this.parameters.box.y),
                                void this.el.attr("font-size", this.parameters.fontSize - n[0]);
                            n = this.checkAspectRatio(n, !0),
                            this.el.move(this.parameters.box.x + n[0], this.parameters.box.y).size(this.parameters.box.width - n[0], this.parameters.box.height + n[1])
                        }
                    }
                    ;
                    break;
                case "t":
                    this.calc = function(a, r) {
                        var n = this.snapToGrid(a, r, 2);
                        if (this.parameters.box.height - n[1] > 0) {
                            if ("text" === this.parameters.type)
                                return;
                            this.el.move(this.parameters.box.x, this.parameters.box.y + n[1]).height(this.parameters.box.height - n[1])
                        }
                    }
                    ;
                    break;
                case "r":
                    this.calc = function(a, r) {
                        var n = this.snapToGrid(a, r, 0);
                        if (this.parameters.box.width + n[0] > 0) {
                            if ("text" === this.parameters.type)
                                return;
                            this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + n[0])
                        }
                    }
                    ;
                    break;
                case "b":
                    this.calc = function(a, r) {
                        var n = this.snapToGrid(a, r, 0);
                        if (this.parameters.box.height + n[1] > 0) {
                            if ("text" === this.parameters.type)
                                return;
                            this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + n[1])
                        }
                    }
                    ;
                    break;
                case "l":
                    this.calc = function(a, r) {
                        var n = this.snapToGrid(a, r, 1);
                        if (this.parameters.box.width - n[0] > 0) {
                            if ("text" === this.parameters.type)
                                return;
                            this.el.move(this.parameters.box.x + n[0], this.parameters.box.y).width(this.parameters.box.width - n[0])
                        }
                    }
                    ;
                    break;
                case "rot":
                    this.calc = function(a, r) {
                        var n = a + this.parameters.p.x
                          , o = r + this.parameters.p.y
                          , l = Math.atan2(this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2, this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2)
                          , c = Math.atan2(o - this.parameters.box.y - this.parameters.box.height / 2, n - this.parameters.box.x - this.parameters.box.width / 2)
                          , d = this.parameters.rotation + 180 * (c - l) / Math.PI + this.options.snapToAngle / 2;
                        this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(d - d % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy)
                    }
                    ;
                    break;
                case "point":
                    this.calc = function(a, r) {
                        var n = this.snapToGrid(a, r, this.parameters.pointCoords[0], this.parameters.pointCoords[1])
                          , o = this.el.array().valueOf();
                        o[this.parameters.i][0] = this.parameters.pointCoords[0] + n[0],
                        o[this.parameters.i][1] = this.parameters.pointCoords[1] + n[1],
                        this.el.plot(o)
                    }
                }
                this.el.fire("resizestart", {
                    dx: this.parameters.x,
                    dy: this.parameters.y,
                    event: e
                }),
                SVG.on(window, "touchmove.resize", function(a) {
                    t.update(a || window.event)
                }),
                SVG.on(window, "touchend.resize", function() {
                    t.done()
                }),
                SVG.on(window, "mousemove.resize", function(a) {
                    t.update(a || window.event)
                }),
                SVG.on(window, "mouseup.resize", function() {
                    t.done()
                })
            }
            ,
            y.prototype.update = function(e) {
                if (e) {
                    var t = this._extractPosition(e)
                      , i = this.transformPoint(t.x, t.y)
                      , s = i.x - this.parameters.p.x
                      , a = i.y - this.parameters.p.y;
                    this.lastUpdateCall = [s, a],
                    this.calc(s, a),
                    this.el.fire("resizing", {
                        dx: s,
                        dy: a,
                        event: e
                    })
                } else
                    this.lastUpdateCall && this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1])
            }
            ,
            y.prototype.done = function() {
                this.lastUpdateCall = null,
                SVG.off(window, "mousemove.resize"),
                SVG.off(window, "mouseup.resize"),
                SVG.off(window, "touchmove.resize"),
                SVG.off(window, "touchend.resize"),
                this.el.fire("resizedone")
            }
            ,
            y.prototype.snapToGrid = function(e, t, i, s) {
                var a;
                return a = void 0 !== s ? [(i + e) % this.options.snapToGrid, (s + t) % this.options.snapToGrid] : [(this.parameters.box.x + e + (1 & (i = i ?? 3) ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + t + (2 & i ? 0 : this.parameters.box.height)) % this.options.snapToGrid],
                e < 0 && (a[0] -= this.options.snapToGrid),
                t < 0 && (a[1] -= this.options.snapToGrid),
                e -= Math.abs(a[0]) < this.options.snapToGrid / 2 ? a[0] : a[0] - (e < 0 ? -this.options.snapToGrid : this.options.snapToGrid),
                t -= Math.abs(a[1]) < this.options.snapToGrid / 2 ? a[1] : a[1] - (t < 0 ? -this.options.snapToGrid : this.options.snapToGrid),
                this.constraintToBox(e, t, i, s)
            }
            ,
            y.prototype.constraintToBox = function(e, t, i, s) {
                var a, r, n = this.options.constraint || {};
                return void 0 !== s ? (a = i,
                r = s) : (a = this.parameters.box.x + (1 & i ? 0 : this.parameters.box.width),
                r = this.parameters.box.y + (2 & i ? 0 : this.parameters.box.height)),
                void 0 !== n.minX && a + e < n.minX && (e = n.minX - a),
                void 0 !== n.maxX && a + e > n.maxX && (e = n.maxX - a),
                void 0 !== n.minY && r + t < n.minY && (t = n.minY - r),
                void 0 !== n.maxY && r + t > n.maxY && (t = n.maxY - r),
                [e, t]
            }
            ,
            y.prototype.checkAspectRatio = function(e, t) {
                if (!this.options.saveAspectRatio)
                    return e;
                var i = e.slice()
                  , s = this.parameters.box.width / this.parameters.box.height
                  , a = this.parameters.box.width + e[0]
                  , r = this.parameters.box.height - e[1]
                  , n = a / r;
                return n < s ? (i[1] = a / s - this.parameters.box.height,
                t && (i[1] = -i[1])) : n > s && (i[0] = this.parameters.box.width - r * s,
                t && (i[0] = -i[0])),
                i
            }
            ,
            SVG.extend(SVG.Element, {
                resize: function(e) {
                    return (this.remember("_resizeHandler") || new y(this)).init(e || {}),
                    this
                }
            }),
            SVG.Element.prototype.resize.defaults = {
                snapToAngle: .1,
                snapToGrid: 1,
                constraint: {},
                saveAspectRatio: !1
            }
        }
        ).call(this)
    }(),
    void 0 === window.Apex && (window.Apex = {});
    var se = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w
        }
        return V(y, [{
            key: "initModules",
            value: function() {
                this.ctx.publicMethods = ["updateOptions", "updateSeries", "appendData", "appendSeries", "toggleSeries", "showSeries", "hideSeries", "setLocale", "resetSeries", "zoomX", "toggleDataPointSelection", "dataURI", "addXaxisAnnotation", "addYaxisAnnotation", "addPointAnnotation", "clearAnnotations", "removeAnnotation", "paper", "destroy"],
                this.ctx.eventList = ["click", "mousedown", "mousemove", "mouseleave", "touchstart", "touchmove", "touchleave", "mouseup", "touchend"],
                this.ctx.animations = new Ce(this.ctx),
                this.ctx.axes = new Mt(this.ctx),
                this.ctx.core = new Q(this.ctx.el,this.ctx),
                this.ctx.config = new F({}),
                this.ctx.data = new ct(this.ctx),
                this.ctx.grid = new te(this.ctx),
                this.ctx.graphics = new D(this.ctx),
                this.ctx.coreUtils = new xe(this.ctx),
                this.ctx.crosshairs = new je(this.ctx),
                this.ctx.events = new dt(this.ctx),
                this.ctx.exports = new fe(this.ctx),
                this.ctx.localization = new ut(this.ctx),
                this.ctx.options = new He,
                this.ctx.responsive = new Ue(this.ctx),
                this.ctx.series = new ve(this.ctx),
                this.ctx.theme = new zt(this.ctx),
                this.ctx.formatters = new ze(this.ctx),
                this.ctx.titleSubtitle = new Xt(this.ctx),
                this.ctx.legend = new Oe(this.ctx),
                this.ctx.toolbar = new Yt(this.ctx),
                this.ctx.dimensions = new xt(this.ctx),
                this.ctx.updateHelpers = new le(this.ctx),
                this.ctx.zoomPanSelection = new gt(this.ctx),
                this.ctx.w.globals.tooltip = new Kt(this.ctx)
            }
        }]),
        y
    }()
      , re = function() {
        function y(e) {
            W(this, y),
            this.ctx = e,
            this.w = e.w
        }
        return V(y, [{
            key: "clear",
            value: function(e) {
                var t = e.isUpdating;
                this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(),
                this.ctx.toolbar && this.ctx.toolbar.destroy(),
                this.ctx.animations = null,
                this.ctx.axes = null,
                this.ctx.annotations = null,
                this.ctx.core = null,
                this.ctx.data = null,
                this.ctx.grid = null,
                this.ctx.series = null,
                this.ctx.responsive = null,
                this.ctx.theme = null,
                this.ctx.formatters = null,
                this.ctx.titleSubtitle = null,
                this.ctx.legend = null,
                this.ctx.dimensions = null,
                this.ctx.options = null,
                this.ctx.crosshairs = null,
                this.ctx.zoomPanSelection = null,
                this.ctx.updateHelpers = null,
                this.ctx.toolbar = null,
                this.ctx.localization = null,
                this.ctx.w.globals.tooltip = null,
                this.clearDomElements({
                    isUpdating: t
                })
            }
        }, {
            key: "killSVG",
            value: function(e) {
                e.each(function(t, i) {
                    this.removeClass("*"),
                    this.off(),
                    this.stop()
                }, !0),
                e.ungroup(),
                e.clear()
            }
        }, {
            key: "clearDomElements",
            value: function(e) {
                var t = this
                  , s = this.w.globals.dom.Paper.node;
                s.parentNode && s.parentNode.parentNode && !e.isUpdating && (s.parentNode.parentNode.style.minHeight = "unset");
                var a = this.w.globals.dom.baseEl;
                a && this.ctx.eventList.forEach(function(n) {
                    a.removeEventListener(n, t.ctx.events.documentEvent)
                });
                var r = this.w.globals.dom;
                if (null !== this.ctx.el)
                    for (; this.ctx.el.firstChild; )
                        this.ctx.el.removeChild(this.ctx.el.firstChild);
                this.killSVG(r.Paper),
                r.Paper.remove(),
                r.elWrap = null,
                r.elGraphical = null,
                r.elAnnotations = null,
                r.elLegendWrap = null,
                r.baseEl = null,
                r.elGridRect = null,
                r.elGridRectMask = null,
                r.elGridRectMarkerMask = null,
                r.elForecastMask = null,
                r.elNonForecastMask = null,
                r.elDefs = null
            }
        }]),
        y
    }()
      , ae = new WeakMap;
    return function() {
        function y(e, t) {
            W(this, y),
            this.opts = t,
            this.ctx = this,
            this.w = new It(t).init(),
            this.el = e,
            this.w.globals.cuid = M.randomId(),
            this.w.globals.chartID = this.w.config.chart.id ? M.escapeString(this.w.config.chart.id) : this.w.globals.cuid,
            new se(this).initModules(),
            this.create = M.bind(this.create, this),
            this.windowResizeHandler = this._windowResizeHandler.bind(this),
            this.parentResizeHandler = this._parentResizeCallback.bind(this)
        }
        return V(y, [{
            key: "render",
            value: function() {
                var e = this;
                return new Promise(function(t, i) {
                    if (null !== e.el) {
                        void 0 === Apex._chartInstances && (Apex._chartInstances = []),
                        e.w.config.chart.id && Apex._chartInstances.push({
                            id: e.w.globals.chartID,
                            group: e.w.config.chart.group,
                            chart: e
                        }),
                        e.setLocale(e.w.config.chart.defaultLocale);
                        var s = e.w.config.chart.events.beforeMount;
                        if ("function" == typeof s && s(e, e.w),
                        e.events.fireEvent("beforeMount", [e, e.w]),
                        window.addEventListener("resize", e.windowResizeHandler),
                        c = e.el.parentNode,
                        d = e.parentResizeHandler,
                        g = !1,
                        p = new ResizeObserver(function(m) {
                            g && d.call(c, m),
                            g = !0
                        }
                        ),
                        c.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Array.from(c.children).forEach(function(m) {
                            return p.observe(m)
                        }) : p.observe(c),
                        ae.set(d, p),
                        !e.css) {
                            var a = e.el.getRootNode && e.el.getRootNode()
                              , r = M.is("ShadowRoot", a)
                              , n = e.el.ownerDocument
                              , o = n.getElementById("apexcharts-css");
                            !r && o || (e.css = document.createElement("style"),
                            e.css.id = "apexcharts-css",
                            e.css.textContent = '.apexcharts-canvas {\n  position: relative;\n  user-select: none;\n  /* cannot give overflow: hidden as it will crop tooltips which overflow outside chart area */\n}\n\n\n/* scrollbar is not visible by default for legend, hence forcing the visibility */\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px;\n}\n\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0, 0, 0, .5);\n  box-shadow: 0 0 1px rgba(255, 255, 255, .5);\n  -webkit-box-shadow: 0 0 1px rgba(255, 255, 255, .5);\n}\n\n\n.apexcharts-inner {\n  position: relative;\n}\n\n.apexcharts-text tspan {\n  font-family: inherit;\n}\n\n.legend-mouseover-inactive {\n  transition: 0.15s ease all;\n  opacity: 0.20;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0;\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-tooltip.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-tooltip.apexcharts-theme-light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255, 255, 255, 0.96);\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark {\n  color: #fff;\n  background: rgba(30, 30, 30, 0.8);\n}\n\n.apexcharts-tooltip * {\n  font-family: inherit;\n}\n\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px;\n}\n\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\n  background: #ECEFF1;\n  border-bottom: 1px solid #ddd;\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\n  background: rgba(0, 0, 0, 0.7);\n  border-bottom: 1px solid #333;\n}\n\n.apexcharts-tooltip-text-y-value,\n.apexcharts-tooltip-text-goals-value,\n.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  font-weight: 600;\n  margin-left: 5px;\n}\n\n.apexcharts-tooltip-title:empty,\n.apexcharts-tooltip-text-y-label:empty,\n.apexcharts-tooltip-text-y-value:empty,\n.apexcharts-tooltip-text-goals-label:empty,\n.apexcharts-tooltip-text-goals-value:empty,\n.apexcharts-tooltip-text-z-value:empty {\n  display: none;\n}\n\n.apexcharts-tooltip-text-y-value,\n.apexcharts-tooltip-text-goals-value,\n.apexcharts-tooltip-text-z-value {\n  font-weight: 600;\n}\n\n.apexcharts-tooltip-text-goals-label, \n.apexcharts-tooltip-text-goals-value {\n  padding: 6px 0 5px;\n}\n\n.apexcharts-tooltip-goals-group, \n.apexcharts-tooltip-text-goals-label, \n.apexcharts-tooltip-text-goals-value {\n  display: flex;\n}\n.apexcharts-tooltip-text-goals-label:not(:empty),\n.apexcharts-tooltip-text-goals-value:not(:empty) {\n  margin-top: -6px;\n}\n\n.apexcharts-tooltip-marker {\n  width: 12px;\n  height: 12px;\n  position: relative;\n  top: 0px;\n  margin-right: 10px;\n  border-radius: 50%;\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center;\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\n  opacity: 1;\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active,\n.apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px;\n}\n\n.apexcharts-tooltip-series-group-hidden {\n  opacity: 0;\n  height: 0;\n  line-height: 0;\n  padding: 0 !important;\n}\n\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px;\n}\n\n.apexcharts-tooltip-box, .apexcharts-custom-tooltip {\n  padding: 4px 8px;\n}\n\n.apexcharts-tooltip-boxPlot {\n  display: flex;\n  flex-direction: column-reverse;\n}\n\n.apexcharts-tooltip-box>div {\n  margin: 4px 0;\n}\n\n.apexcharts-tooltip-box span.value {\n  font-weight: bold;\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px;\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777;\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: bold;\n  display: block;\n  margin-bottom: 5px;\n}\n\n.apexcharts-xaxistooltip {\n  opacity: 0;\n  padding: 9px 10px;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #ECEFF1;\n  border: 1px solid #90A4AE;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, 0.7);\n  border: 1px solid rgba(0, 0, 0, 0.5);\n  color: #fff;\n}\n\n.apexcharts-xaxistooltip:after,\n.apexcharts-xaxistooltip:before {\n  left: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n\n.apexcharts-xaxistooltip:after {\n  border-color: rgba(236, 239, 241, 0);\n  border-width: 6px;\n  margin-left: -6px;\n}\n\n.apexcharts-xaxistooltip:before {\n  border-color: rgba(144, 164, 174, 0);\n  border-width: 7px;\n  margin-left: -7px;\n}\n\n.apexcharts-xaxistooltip-bottom:after,\n.apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%;\n}\n\n.apexcharts-xaxistooltip-top:after,\n.apexcharts-xaxistooltip-top:before {\n  top: 100%;\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #ECEFF1;\n}\n\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90A4AE;\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after {\n  border-bottom-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\n  border-bottom-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color: #ECEFF1\n}\n\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90A4AE;\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after {\n  border-top-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\n  border-top-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-yaxistooltip {\n  opacity: 0;\n  padding: 4px 10px;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #ECEFF1;\n  border: 1px solid #90A4AE;\n}\n\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, 0.7);\n  border: 1px solid rgba(0, 0, 0, 0.5);\n  color: #fff;\n}\n\n.apexcharts-yaxistooltip:after,\n.apexcharts-yaxistooltip:before {\n  top: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n\n.apexcharts-yaxistooltip:after {\n  border-color: rgba(236, 239, 241, 0);\n  border-width: 6px;\n  margin-top: -6px;\n}\n\n.apexcharts-yaxistooltip:before {\n  border-color: rgba(144, 164, 174, 0);\n  border-width: 7px;\n  margin-top: -7px;\n}\n\n.apexcharts-yaxistooltip-left:after,\n.apexcharts-yaxistooltip-left:before {\n  left: 100%;\n}\n\n.apexcharts-yaxistooltip-right:after,\n.apexcharts-yaxistooltip-right:before {\n  right: 100%;\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #ECEFF1;\n}\n\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90A4AE;\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after {\n  border-left-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\n  border-left-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #ECEFF1;\n}\n\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90A4AE;\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after {\n  border-right-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\n  border-right-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip.apexcharts-active {\n  opacity: 1;\n}\n\n.apexcharts-yaxistooltip-hidden {\n  display: none;\n}\n\n.apexcharts-xcrosshairs,\n.apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-xcrosshairs.apexcharts-active,\n.apexcharts-ycrosshairs.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0;\n}\n\n.apexcharts-selection-rect {\n  cursor: move;\n}\n\n.svg_select_boundingRect, .svg_select_points_rot {\n  pointer-events: none;\n  opacity: 0;\n  visibility: hidden;\n}\n.apexcharts-selection-rect + g .svg_select_boundingRect,\n.apexcharts-selection-rect + g .svg_select_points_rot {\n  opacity: 0;\n  visibility: hidden;\n}\n\n.apexcharts-selection-rect + g .svg_select_points_l,\n.apexcharts-selection-rect + g .svg_select_points_r {\n  cursor: ew-resize;\n  opacity: 1;\n  visibility: visible;\n}\n\n.svg_select_points {\n  fill: #efefef;\n  stroke: #333;\n  rx: 2;\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-zoom {\n  cursor: crosshair\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-pan {\n  cursor: move\n}\n\n.apexcharts-zoom-icon,\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon,\n.apexcharts-reset-icon,\n.apexcharts-pan-icon,\n.apexcharts-selection-icon,\n.apexcharts-menu-icon,\n.apexcharts-toolbar-custom-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6E8192;\n  text-align: center;\n}\n\n.apexcharts-zoom-icon svg,\n.apexcharts-zoomin-icon svg,\n.apexcharts-zoomout-icon svg,\n.apexcharts-reset-icon svg,\n.apexcharts-menu-icon svg {\n  fill: #6E8192;\n}\n\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(0.76)\n}\n\n.apexcharts-theme-dark .apexcharts-zoom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomin-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomout-icon svg,\n.apexcharts-theme-dark .apexcharts-reset-icon svg,\n.apexcharts-theme-dark .apexcharts-pan-icon svg,\n.apexcharts-theme-dark .apexcharts-selection-icon svg,\n.apexcharts-theme-dark .apexcharts-menu-icon svg,\n.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg {\n  fill: #f3f4f5;\n}\n\n.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg {\n  fill: #008FFB;\n}\n\n.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,\n.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg,\n.apexcharts-theme-light .apexcharts-reset-icon:hover svg,\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg {\n  fill: #333;\n}\n\n.apexcharts-selection-icon,\n.apexcharts-menu-icon {\n  position: relative;\n}\n\n.apexcharts-reset-icon {\n  margin-left: 5px;\n}\n\n.apexcharts-zoom-icon,\n.apexcharts-reset-icon,\n.apexcharts-menu-icon {\n  transform: scale(0.85);\n}\n\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  transform: scale(0.7)\n}\n\n.apexcharts-zoomout-icon {\n  margin-right: 3px;\n}\n\n.apexcharts-pan-icon {\n  transform: scale(0.62);\n  position: relative;\n  left: 1px;\n  top: 0px;\n}\n\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6E8192;\n  stroke-width: 2;\n}\n\n.apexcharts-pan-icon.apexcharts-selected svg {\n  stroke: #008FFB;\n}\n\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\n  stroke: #333;\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0px 6px 2px 6px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: 0.15s ease all;\n  pointer-events: none;\n}\n\n.apexcharts-menu.apexcharts-menu-open {\n  opacity: 1;\n  pointer-events: all;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer;\n}\n\n.apexcharts-theme-light .apexcharts-menu-item:hover {\n  background: #eee;\n}\n\n.apexcharts-theme-dark .apexcharts-menu {\n  background: rgba(0, 0, 0, 0.7);\n  color: #fff;\n}\n\n@media screen and (min-width: 768px) {\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n    opacity: 1;\n  }\n}\n\n.apexcharts-datalabel.apexcharts-element-hidden {\n  opacity: 0;\n}\n\n.apexcharts-pie-label,\n.apexcharts-datalabels,\n.apexcharts-datalabel,\n.apexcharts-datalabel-label,\n.apexcharts-datalabel-value {\n  cursor: default;\n  pointer-events: none;\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: 0.3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease;\n}\n\n.apexcharts-canvas .apexcharts-element-hidden {\n  opacity: 0;\n}\n\n.apexcharts-hide .apexcharts-series-points {\n  opacity: 0;\n}\n\n.apexcharts-gridline,\n.apexcharts-annotation-rect,\n.apexcharts-tooltip .apexcharts-marker,\n.apexcharts-area-series .apexcharts-area,\n.apexcharts-line,\n.apexcharts-zoom-rect,\n.apexcharts-toolbar svg,\n.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-radar-series path,\n.apexcharts-radar-series polygon {\n  pointer-events: none;\n}\n\n\n/* markers */\n\n.apexcharts-marker {\n  transition: 0.15s ease all;\n}\n\n@keyframes opaque {\n  0% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n\n\n/* Resize generated styles */\n\n@keyframes resizeanim {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.resize-triggers {\n  animation: 1ms resizeanim;\n  visibility: hidden;\n  opacity: 0;\n}\n\n.resize-triggers,\n.resize-triggers>div,\n.contract-trigger:before {\n  content: " ";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden;\n}\n\n.resize-triggers>div {\n  background: #eee;\n  overflow: auto;\n}\n\n.contract-trigger:before {\n  width: 200%;\n  height: 200%;\n}',
                            r ? a.prepend(e.css) : n.head.appendChild(e.css))
                        }
                        var l = e.create(e.w.config.series, {});
                        if (!l)
                            return t(e);
                        e.mount(l).then(function() {
                            "function" == typeof e.w.config.chart.events.mounted && e.w.config.chart.events.mounted(e, e.w),
                            e.events.fireEvent("mounted", [e, e.w]),
                            t(l)
                        }).catch(function(m) {
                            i(m)
                        })
                    } else
                        i(new Error("Element not found"));
                    var c, d, g, p
                }
                )
            }
        }, {
            key: "create",
            value: function(e, t) {
                var i = this.w;
                new se(this).initModules();
                var s = this.w.globals;
                if (s.noData = !1,
                s.animationEnded = !1,
                this.responsive.checkResponsiveConfig(t),
                i.config.xaxis.convertedCatToNumeric && new it(i.config).convertCatToNumericXaxis(i.config, this.ctx),
                null === this.el || (this.core.setupElements(),
                "treemap" === i.config.chart.type && (i.config.grid.show = !1,
                i.config.yaxis[0].show = !1),
                0 === s.svgWidth))
                    return s.animationEnded = !0,
                    null;
                var a = xe.checkComboSeries(e);
                s.comboCharts = a.comboCharts,
                s.comboBarCount = a.comboBarCount;
                var r = e.every(function(d) {
                    return d.data && 0 === d.data.length
                });
                (0 === e.length || r) && this.series.handleNoData(),
                this.events.setupEventHandlers(),
                this.data.parseData(e),
                this.theme.init(),
                new Ae(this).setGlobalMarkerSize(),
                this.formatters.setLabelFormatters(),
                this.titleSubtitle.draw(),
                s.noData && s.collapsedSeries.length !== s.series.length && !i.config.legend.showForSingleSeries || this.legend.init(),
                this.series.hasAllSeriesEqualX(),
                s.axisCharts && (this.core.coreCalculations(),
                "category" !== i.config.xaxis.type && this.formatters.setLabelFormatters(),
                this.ctx.toolbar.minX = i.globals.minX,
                this.ctx.toolbar.maxX = i.globals.maxX),
                this.formatters.heatmapLabelFormatters(),
                this.dimensions.plotCoords();
                var n = this.core.xySettings();
                this.grid.createGridMask();
                var o = this.core.plotChartType(e, n)
                  , l = new Ge(this);
                return l.bringForward(),
                i.config.dataLabels.background.enabled && l.dataLabelsBackground(),
                this.core.shiftGraphPosition(),
                {
                    elGraph: o,
                    xyRatios: n,
                    elInner: i.globals.dom.elGraphical,
                    dimensions: {
                        plot: {
                            left: i.globals.translateX,
                            top: i.globals.translateY,
                            width: i.globals.gridWidth,
                            height: i.globals.gridHeight
                        }
                    }
                }
            }
        }, {
            key: "mount",
            value: function() {
                var e = this
                  , t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
                  , i = this
                  , s = i.w;
                return new Promise(function(a, r) {
                    if (null === i.el)
                        return r(new Error("Not enough data to display or target element not found"));
                    (null === t || s.globals.allSeriesCollapsed) && i.series.handleNoData(),
                    "treemap" !== s.config.chart.type && i.axes.drawAxis(s.config.chart.type, t.xyRatios),
                    i.grid = new te(i);
                    var n = i.grid.drawGrid();
                    i.annotations = new Se(i),
                    i.annotations.drawImageAnnos(),
                    i.annotations.drawTextAnnos(),
                    "back" === s.config.grid.position && n && s.globals.dom.elGraphical.add(n.el);
                    var o = new Xe(e.ctx)
                      , l = new St(e.ctx);
                    if (null !== n && (o.xAxisLabelCorrections(n.xAxisTickWidth),
                    l.setYAxisTextAlignments(),
                    s.config.yaxis.map(function(g, p) {
                        -1 === s.globals.ignoreYAxisIndexes.indexOf(p) && l.yAxisTitleRotate(p, g.opposite)
                    })),
                    "back" === s.config.annotations.position && (s.globals.dom.Paper.add(s.globals.dom.elAnnotations),
                    i.annotations.drawAxesAnnotations()),
                    Array.isArray(t.elGraph))
                        for (var c = 0; c < t.elGraph.length; c++)
                            s.globals.dom.elGraphical.add(t.elGraph[c]);
                    else
                        s.globals.dom.elGraphical.add(t.elGraph);
                    if ("front" === s.config.grid.position && n && s.globals.dom.elGraphical.add(n.el),
                    "front" === s.config.xaxis.crosshairs.position && i.crosshairs.drawXCrosshairs(),
                    "front" === s.config.yaxis[0].crosshairs.position && i.crosshairs.drawYCrosshairs(),
                    "front" === s.config.annotations.position && (s.globals.dom.Paper.add(s.globals.dom.elAnnotations),
                    i.annotations.drawAxesAnnotations()),
                    !s.globals.noData) {
                        if (s.config.tooltip.enabled && !s.globals.noData && i.w.globals.tooltip.drawTooltip(t.xyRatios),
                        s.globals.axisCharts && (s.globals.isXNumeric || s.config.xaxis.convertedCatToNumeric || s.globals.isRangeBar))
                            (s.config.chart.zoom.enabled || s.config.chart.selection && s.config.chart.selection.enabled || s.config.chart.pan && s.config.chart.pan.enabled) && i.zoomPanSelection.init({
                                xyRatios: t.xyRatios
                            });
                        else {
                            var d = s.config.chart.toolbar.tools;
                            ["zoom", "zoomin", "zoomout", "selection", "pan", "reset"].forEach(function(g) {
                                d[g] = !1
                            })
                        }
                        s.config.chart.toolbar.show && !s.globals.allSeriesCollapsed && i.toolbar.createToolbar()
                    }
                    s.globals.memory.methodsToExec.length > 0 && s.globals.memory.methodsToExec.forEach(function(g) {
                        g.method(g.params, !1, g.context)
                    }),
                    s.globals.axisCharts || s.globals.noData || i.core.resizeNonAxisCharts(),
                    a(i)
                }
                )
            }
        }, {
            key: "destroy",
            value: function() {
                var e, t;
                window.removeEventListener("resize", this.windowResizeHandler),
                (t = ae.get(e = this.parentResizeHandler)) && (t.disconnect(),
                ae.delete(e));
                var i = this.w.config.chart.id;
                i && Apex._chartInstances.forEach(function(s, a) {
                    s.id === M.escapeString(i) && Apex._chartInstances.splice(a, 1)
                }),
                new re(this.ctx).clear({
                    isUpdating: !1
                })
            }
        }, {
            key: "updateOptions",
            value: function(e) {
                var t = this
                  , i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
                  , s = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
                  , a = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3]
                  , r = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4]
                  , n = this.w;
                return n.globals.selection = void 0,
                e.series && (this.series.resetSeries(!1, !0, !1),
                e.series.length && e.series[0].data && (e.series = e.series.map(function(o, l) {
                    return t.updateHelpers._extendSeries(o, l)
                })),
                this.updateHelpers.revertDefaultAxisMinMax()),
                e.xaxis && (e = this.updateHelpers.forceXAxisUpdate(e)),
                e.yaxis && (e = this.updateHelpers.forceYAxisUpdate(e)),
                n.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(),
                e.theme && (e = this.theme.updateThemeOptions(e)),
                this.updateHelpers._updateOptions(e, i, s, a, r)
            }
        }, {
            key: "updateSeries",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                  , t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                  , i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                return this.series.resetSeries(!1),
                this.updateHelpers.revertDefaultAxisMinMax(),
                this.updateHelpers._updateSeries(e, t, i)
            }
        }, {
            key: "appendSeries",
            value: function(e) {
                var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                  , i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
                  , s = this.w.config.series.slice();
                return s.push(e),
                this.series.resetSeries(!1),
                this.updateHelpers.revertDefaultAxisMinMax(),
                this.updateHelpers._updateSeries(s, t, i)
            }
        }, {
            key: "appendData",
            value: function(e) {
                var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                  , i = this;
                i.w.globals.dataChanged = !0,
                i.series.getPreviousPaths();
                for (var s = i.w.config.series.slice(), a = 0; a < s.length; a++)
                    if (null != e[a])
                        for (var r = 0; r < e[a].data.length; r++)
                            s[a].data.push(e[a].data[r]);
                return i.w.config.series = s,
                t && (i.w.globals.initialSeries = M.clone(i.w.config.series)),
                this.update()
            }
        }, {
            key: "update",
            value: function(e) {
                var t = this;
                return new Promise(function(i, s) {
                    new re(t.ctx).clear({
                        isUpdating: !0
                    });
                    var a = t.create(t.w.config.series, e);
                    if (!a)
                        return i(t);
                    t.mount(a).then(function() {
                        "function" == typeof t.w.config.chart.events.updated && t.w.config.chart.events.updated(t, t.w),
                        t.events.fireEvent("updated", [t, t.w]),
                        t.w.globals.isDirty = !0,
                        i(t)
                    }).catch(function(r) {
                        s(r)
                    })
                }
                )
            }
        }, {
            key: "getSyncedCharts",
            value: function() {
                var e = this.getGroupedCharts()
                  , t = [this];
                return e.length && (t = [],
                e.forEach(function(i) {
                    t.push(i)
                })),
                t
            }
        }, {
            key: "getGroupedCharts",
            value: function() {
                var e = this;
                return Apex._chartInstances.filter(function(t) {
                    if (t.group)
                        return !0
                }).map(function(t) {
                    return e.w.config.chart.group === t.group ? t.chart : e
                })
            }
        }, {
            key: "toggleSeries",
            value: function(e) {
                return this.series.toggleSeries(e)
            }
        }, {
            key: "highlightSeriesOnLegendHover",
            value: function(e, t) {
                return this.series.toggleSeriesOnHover(e, t)
            }
        }, {
            key: "showSeries",
            value: function(e) {
                this.series.showSeries(e)
            }
        }, {
            key: "hideSeries",
            value: function(e) {
                this.series.hideSeries(e)
            }
        }, {
            key: "resetSeries",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]
                  , t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                this.series.resetSeries(e, t)
            }
        }, {
            key: "addEventListener",
            value: function(e, t) {
                this.events.addEventListener(e, t)
            }
        }, {
            key: "removeEventListener",
            value: function(e, t) {
                this.events.removeEventListener(e, t)
            }
        }, {
            key: "addXaxisAnnotation",
            value: function(e) {
                var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                  , i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0
                  , s = this;
                i && (s = i),
                s.annotations.addXaxisAnnotationExternal(e, t, s)
            }
        }, {
            key: "addYaxisAnnotation",
            value: function(e) {
                var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                  , i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0
                  , s = this;
                i && (s = i),
                s.annotations.addYaxisAnnotationExternal(e, t, s)
            }
        }, {
            key: "addPointAnnotation",
            value: function(e) {
                var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                  , i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0
                  , s = this;
                i && (s = i),
                s.annotations.addPointAnnotationExternal(e, t, s)
            }
        }, {
            key: "clearAnnotations",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0
                  , t = this;
                e && (t = e),
                t.annotations.clearAnnotations(t)
            }
        }, {
            key: "removeAnnotation",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0
                  , i = this;
                t && (i = t),
                i.annotations.removeAnnotation(i, e)
            }
        }, {
            key: "getChartArea",
            value: function() {
                return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner")
            }
        }, {
            key: "getSeriesTotalXRange",
            value: function(e, t) {
                return this.coreUtils.getSeriesTotalsXRange(e, t)
            }
        }, {
            key: "getHighestValueInSeries",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                  , t = new pt(this.ctx);
                return t.getMinYMaxY(e).highestY
            }
        }, {
            key: "getLowestValueInSeries",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                  , t = new pt(this.ctx);
                return t.getMinYMaxY(e).lowestY
            }
        }, {
            key: "getSeriesTotal",
            value: function() {
                return this.w.globals.seriesTotals
            }
        }, {
            key: "toggleDataPointSelection",
            value: function(e, t) {
                return this.updateHelpers.toggleDataPointSelection(e, t)
            }
        }, {
            key: "zoomX",
            value: function(e, t) {
                this.ctx.toolbar.zoomUpdateOptions(e, t)
            }
        }, {
            key: "setLocale",
            value: function(e) {
                this.localization.setCurrentLocaleValues(e)
            }
        }, {
            key: "dataURI",
            value: function(e) {
                return new fe(this.ctx).dataURI(e)
            }
        }, {
            key: "paper",
            value: function() {
                return this.w.globals.dom.Paper
            }
        }, {
            key: "_parentResizeCallback",
            value: function() {
                this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize()
            }
        }, {
            key: "_windowResize",
            value: function() {
                var e = this;
                clearTimeout(this.w.globals.resizeTimer),
                this.w.globals.resizeTimer = window.setTimeout(function() {
                    e.w.globals.resized = !0,
                    e.w.globals.dataChanged = !1,
                    e.ctx.update()
                }, 150)
            }
        }, {
            key: "_windowResizeHandler",
            value: function() {
                var e = this.w.config.chart.redrawOnWindowResize;
                "function" == typeof e && (e = e()),
                e && this._windowResize()
            }
        }], [{
            key: "getChartByID",
            value: function(e) {
                var t = M.escapeString(e)
                  , i = Apex._chartInstances.filter(function(s) {
                    return s.id === t
                })[0];
                return i && i.chart
            }
        }, {
            key: "initOnLoad",
            value: function() {
                for (var e = document.querySelectorAll("[data-apexcharts]"), t = 0; t < e.length; t++)
                    new y(e[t],JSON.parse(e[t].getAttribute("data-options"))).render()
            }
        }, {
            key: "exec",
            value: function(e, t) {
                var i = this.getChartByID(e);
                if (i) {
                    i.w.globals.isExecCalled = !0;
                    var s = null;
                    if (-1 !== i.publicMethods.indexOf(t)) {
                        for (var a = arguments.length, r = new Array(a > 2 ? a - 2 : 0), n = 2; n < a; n++)
                            r[n - 2] = arguments[n];
                        s = i[t].apply(i, r)
                    }
                    return s
                }
            }
        }, {
            key: "merge",
            value: function(e, t) {
                return M.extend(e, t)
            }
        }]),
        y
    }()
});
